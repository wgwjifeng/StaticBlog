<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows kernel learning: 4. Object Management]]></title>
    <url>%2FStaticBlog%2F2017%2FWindows-kernel-learning%2F4-Object-Management%2F</url>
    <content type="text"><![CDATA[对象管理是 Windows Executive 的一个子系统实现, 用于管理 Windows 资源. 资源包括物理设备, 文件, 文件目录, 注册表条目, 正在运行的进程等等. 所有子系统访问资源都必须通过对象管理子系统. 对象实际上就是一组数据结构加操作(函数). 各种 Object 的共有的信息 (例如, 对象类型, 对象的引用计数, 句柄数等信息) 保存在 OBJECT_HEADER 与其他的几个结构中. 换而言之, 在对象管理器内部, 不同类型的对象具有相同的 Object Header, 但 Object Body 部分却是不同的. Windows 有三种类型的对象: 内核对象 (Kernel objects) , 执行体对象 (Executive objects), 和 GDI/User 对象. 内核对象: 表示一些基本资源, 如物理设备, 同步服务等等. 用户态的程序不能访问内核对象. 执行体对象: 用户态的系统服务与应用程序使用执行对象, 这是 Windows Executive 对外暴露的对象, 用来封装一个或多个内核对象. 执行对象还用于实现 NT 子系统或 POSIX 子系统的一些功能. 用户对象: 每个对象仅有一个句柄, 句柄不能复制或继承, 不能引用其他用户会话中的进程的用户句柄. 任何进程只要有对某个用户句柄访问权限, 即可以访问该用户对象. 一个进程最多有 65536 个用户对象句柄.用户对象包括: 快捷键表 HACCEL, 插入点光标, 鼠标指针 HCURSOR, DDE 会话, 窗口钩子, 图标 HICON, 菜单 HMENU, 窗口 HWND, 窗口位置. GDI 对象: 每个对象仅有一个句柄, 句柄为进程私有. 一个进程最多有 65536 个 GDI 对象句柄.GDI 对象包括: 位图 HBITMAP, 画刷 HBRUSH, 设备环境 (DC) HDC, 增强型图元文件 (EMF) , EMF 设备环境, 字体 HFONT, 内存 DC, 图元文件, 图元文件 DC, 调色板 HPALETTE, 画笔 HPEN, 区域 (Region) HRGN. Windows NT 暴露的执行对象 对象类型 结构 代表含义 Process _EPROCESS 执行一组线程对象所必须的虚拟地址空间和控制信息 Thread _ETHREAD 进程内部的一个可执行实体 Job _EJOB 指一组进程, 通过作业机制, 可以像单个实体那样来管理他们 Section _SECTION_OBJECT 共享内存的一个区域 (也称为 File mapping) File _FILE_OBJECT 一个已打开的文件或者 I/O 设备的实例 Token _TOKEN 一个进程或者线程的安全轮廓 (安全ID, 用户权限等) Event _KEVENT 一种具有持久状态 (有信号或无信号的) 对象,可用于同步或者通知 Semaphore _KSEMAPHORE 信号量是一个计数器, 提供资源门控制能力, 对于该信号量所保护的资源只允许某个最大数目的线程访问 Mutex _KMUTEX 用于顺序访问一个资源的一种同步机制 Timer _ETIMER 这是一种当固定长度的时间过去时通知某个线程的机制 IoCompletion 使线程能够将 “I/O 操作完成通知” 进出队列的一种方法 Key _CM_KEY_BODY 一种引用注册表中数据的机制. 虽然键出现在对象管理器的命名空间中, 但是却是由配置管理器来管理的, 其管理方式类似于文件系统驱动程序管理文件对象的方式. 与该键对象关联在一起的有零个或多个键值; 一个键值中包含有关该键的数据 Directory 对象管理器中命名空间的虚拟目录, 负责包含其他的对象或对象目录 TpWorkerFactory 负责执行一组特定任务的线程集合. Windows 通过线程池的方式暴露工作者工厂对象 Tm (资源管理器), TmTx (事务), TmTm (事务管理器), TmEn (登记) 内核事务管理器 (KTM) 为各种事物或登记而使用的对象, 他们是资源管理器或事务管理器的一部分. WindowStation tagWINDOWSTATION 该对象包含一个剪贴板, 一组全局原子, 一组桌面对象 Desktop tagDESKTOP 这是一个包含在窗口站内部的对象. 它有一个逻辑显示器表面, 包含了窗口, 菜单 和 钩子. PowerRequest 该对象与一个线程关联在一起, 该线程执行 SetThreadExecutionState 调用请求指定的电源改变, 比如防止睡眠. EtwConsumer 代表一个已连接的 ETW 实时消费者已经通过 StartTrace API 进行了注册 EtwRegistration 代表一个注册对象, 它与某个用户模式(或内核模式) ETW 提供者关联 SymbolicLink _OBJECT_SYMBOLIC_LINK 被创建用来支持别名,这些别名可以来用帮助映射网络共享 Type _OBJECT_TYPE 通过元数据来描述所有其他对象常见属性的一个对象 其他对象参考 Windows Object Categories 除了以上这些对象之外, 还有 Device, Driver, Adapter 等用于设备驱动的对象类型, 这些对象类型并由有专用的系统调用, 而是借用 NtCreateFile() 作为创建/打开的方法 对象结构 如图所示, 每个对象都有一个对象头和一个对象体. 每个对象头中有一个索引, 指向一个被称为类型对象的特殊对象, 该对象包含的信息对于它的每个实例是公共的. 另外,还可以有多达 7 个可选的子头: 名称信息头(_OBJECT_HEADER_NAME_INFO) 配额信息头(_OBJECT_HEADER_QUOTA_INFO) 进程信息头(_OBJECT_HEADER_PROCESS_INFO) 句柄信息头(_OBJECT_HEADER_HANDLE_INFO) 创建者信息头(_OBJECT_HEADER_CREATOR_INFO) 审计信息头(_OBJECT_HEADER_AUDIT_INFO) 填充信息头(_OBJECT_HEADER_PADDING_INFO) 对象头我们来看下对象头的定义: 1234567891011121314151617181920212223240: kd&gt; dt nt!_OBJECT_HEADER +0x000 PointerCount : Int8B +0x008 HandleCount : Int8B +0x008 NextToFree : Ptr64 Void +0x010 Lock : _EX_PUSH_LOCK +0x018 TypeIndex : UChar +0x019 TraceFlags : UChar +0x019 DbgRefTrace : Pos 0, 1 Bit +0x019 DbgTracePermanent : Pos 1, 1 Bit +0x01a InfoMask : UChar +0x01b Flags : UChar +0x01b NewObject : Pos 0, 1 Bit +0x01b KernelObject : Pos 1, 1 Bit +0x01b KernelOnlyAccess : Pos 2, 1 Bit +0x01b ExclusiveObject : Pos 3, 1 Bit +0x01b PermanentObject : Pos 4, 1 Bit +0x01b DefaultSecurityQuota : Pos 5, 1 Bit +0x01b SingleHandleEntry : Pos 6, 1 Bit +0x01b DeletedInline : Pos 7, 1 Bit +0x01c Spare : Uint4B +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION +0x020 QuotaBlockCharged : Ptr64 Void +0x028 SecurityDescriptor : Ptr64 Void +0x030 Body : _QUAD ; 占位符, 对象体的位置 Body 就是具体对象类型的数据结构本身, 即一个数据结构的起点. 对象头中的域 域 用途 HandleCount 维护一个计数值, 记录了当前打开打开的指向该对象的句柄数 PointerCount 维护一个计数值, 记录了该对象的引用个数 (每个句柄也算一次引用). 内核模式组件可以不通过句柄, 而直接用指针来引用对象. SecurityDescriptor 决定谁可以使用该对象, 以及允许他们如何使用它. (根据定义, 没有名称的对象是没有安全性的) TypeIndex 包含一个指向类型对象的索引, 该类型对象包含了这种类型对象的公共属性, 所有的类型对象都存储在 nt!ObTypeIndexTable 表中 InfoMask 可选头掩码, 除了创建者信息子头外, 只要存在, 就位于对象的前面. 该掩码通过 nt!ObpInfoMaskToOffset 表被转换成一个负的偏移;每个可选头都有一个与之关联的 1 字节索引, 将该可选头置于相对其他子头出现的位置 Flags 对象的特征和对象属性 Lock 针对每个对象的锁, 当修改该对象头部的域或者任何子头的域时, 需要用到该锁 TraceFlags 追踪开启标志, 用来调试引用计数问题 对象 Flags 属性标志 头标志 用途 OBJ_INHERIT 保存在句柄表项中 决定指向对象的句柄将来是否被子进程继承, 以及进程是否可以使用 DuplicateHandle 来执行句柄复制 OBJ_PERMANENT OB_FLAG_PERMANENT_OBJECT 定义与引用计数相关的对象保持力行为 OBJ_EXCLUSIVE OB_FLAG_EXCLUSIVE_OBJECT 决定一个对象只能被创建该对象的进程所使用 OBJ_CASE_INSENSITIVE 保存在句柄表项中 指定在命名空间中查找该对象应该按大小写无关的方式进行 OBJ_OPENIF 不保存, 仅在运行时使用 如果将此标志指定给创建对象的例程, 并且该对象已存在, 则例程应打开该对象. 否则, 创建对象的例程将返回 STATUS_OBJECT_NAME_COLLISION 的 NTSTATUS 代码. OBJ_OPENLINK 不保存, 仅在运行时使用 指定对象管理器应该打开一个指向符号链接的句柄, 而不是指向目标对象的句柄 OBJ_KERNEL_HANDLE OB_FLAG_KERNEL_OBJECT 指定指向该对象的句柄应该是一个内核句柄 OBJ_FORCE_ACCESS_CHECK 不保存, 仅在运行时使用 指定即使该对象是用内核模式中打开的, 也要执行完全的访问检查 OBJ_KERNEL_EXCLUSIVE OB_FLAG_KERNEL_ONLY_ACCESS 禁止任何用户模式进程打开指向该对象的句柄, 用于保护 /Device/PhysicalMemory 内存区对象 - OB_FLAG_DEFAULT_SECURITY_QUOTA 指定该对象的安全描述符使用模式的 2KB 配额 - OB_FLAG_SINGLE_HANDLE_ENTRY 指定句柄信息可选头仅包含一项, 而不是一个数据库 - OB_FLAG_NEW_OBJECT 指定该对象已被创建, 但是尚未被插入到对象命名空间中 - OB_FLAG_DEFER_DELETE_INLINE 指定该对象正在通过一个延迟删除的辅助线程删除 可选对象头一个对象的可选头包含了用于描述该对象各种类型的元数据. 很明显, 因为它们是可选的, 所以并不是所有的类型的对象都拥有可选头;甚至于相同类型对象的不同实例也可能包含可选头的不同组合. 这些结构的位置是从对象头的开始减去一个并不固定的偏移量, 此偏移值取决于与对象头相关联的可选头的数量. 对于所有可选头各种可能的情形, 都存在一个响应的偏移量, 但是因为可选头总是按照固定不变的顺序来分配,所以对于一个给定的头, 它可能出现的位置的数量, 与优先于它而出现的最多可选头数量相同. 偏移的计算公式为: Offset = ObpInfoMaskToOffset[OBJECT_HEADER-&gt;InfoMask &amp; (DesiredHeaderBit | (DesiredHeaderBit-1))] (DesiredHeaderBit | (DesiredHeaderBit-1)) 表示包含在此可选头结构之前的可选头结构. 名称 结构 掩位码 偏移 用途 创建者信息 _OBJECT_HEADER_CREATOR_INFO 0 (0x01) ObpInfoMaskToOffset[0x01] 对于所有同一类型的对象, 链接成一个列表, 并记录下创建该对象的进程, 以及一个后向跟踪项 名称信息 _OBJECT_HEADER_NAME_INFO 1 (0x02) ObpInfoMaskToOffset[0x03] 包含对象名称和一个指向对象目录的指针. 对象名称使用该对象对于其他进程也可见, 从而可以共享; 对象目录提供了存储对象名称的层次结构. 句柄信息 _OBJECT_HEADER_HANDLE_INFO 2 (0X04) ObpInfoMaskToOffset[0X07] 包含一个进程项数据库 (或只有一项), 这些进程都有一个已打开的句柄指向该对象 (以及一个针对每个进程的句柄计数) 配额信息 _OBJECT_HEADER_QUOTA_INFO 3 (0x08) ObpInfoMaskToOffset[0x0F] 列出了当一个进程打开指向该对象的句柄时需要消耗的资源花费 进程信息 _OBJECT_HEADER_PROCESS_INFO 4 (0x10) ObpInfoMaskToOffset[0x1F] 如果这是一个排它性对象, 则包含一个指向所有者进程的指针 审计信息 _OBJECT_HEADER_AUDIT_INFO 5 (0x20) ObpInfoMaskToOffset[0x3F] 未知 填充信息? _OBJECT_HEADER_PADDING_INFO 6 (0x40) ObpInfoMaskToOffset[0x7F] 未知 对象可选头出现的条件 名称 条件 创建者信息 对象类型必须已经打开维护类型列表标志. 如果驱动程序检验器被启用, 则驱动程序对象已设置此标志. 然而, 若全局标志维护对象类型列表打开, 所有对象的维护类型列表标志也随之打开, 类型对象总是设置该标志 名称信息 对象创建时必须指定名称 句柄信息 对象类型必须已打开维护句柄计数标志. 文件对象, ALPC 对象, 窗口站对象和桌面对象已在其对象类型结构中设置了此标志 配额信息 对象必须不是由初始系统进程或空闲进程创建的 进程信息 对象创建时必须指定排他性对象标志 审计信息 开启对象访问审核功能时使用? 本地组策略有这么个选项… 填充信息 未知 “对象类型” 对象 (_OBJECT_TYPE)对象类型对象包含一些对于某种特定类型的所有对象皆为常数的数据. _OBJECT_HEADER 的 TypeIndex 成员是 nt!ObTypeIndexTable (一个类型对象 _OBJECT_TYPE 的数组) 的索引. 我们来看一下结构定义: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691: kd&gt; dtx -r nt!_OBJECT_TYPE +0x000 TypeList : _LIST_ENTRY +0x010 Name : _UNICODE_STRING +0x020 DefaultObject : Ptr64 Void +0x028 Index : UChar +0x02c TotalNumberOfObjects : Uint4B +0x030 TotalNumberOfHandles : Uint4B +0x034 HighWaterNumberOfObjects : Uint4B +0x038 HighWaterNumberOfHandles : Uint4B +0x040 TypeInfo : _OBJECT_TYPE_INITIALIZER +0x000 Length : Uint2B +0x002 ObjectTypeFlags : UChar +0x002 CaseInsensitive : Pos 0, 1 Bit ; 是否大小写敏感 +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit ; 是否永远不会有名称 +0x002 UseDefaultObject : Pos 2, 1 Bit ; 是否使用默认对象 +0x002 SecurityRequired : Pos 3, 1 Bit ; 是否要求安全描述符 +0x002 MaintainHandleCount : Pos 4, 1 Bit ; 是否一共维护句柄数据库 (句柄信息可选头) +0x002 MaintainTypeList : Pos 5, 1 Bit ; 是否应该维护类型列表链接关系 (创建者信息可选头) +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit ; 是否支持对象过滤回调 +0x002 CacheAligned : Pos 7, 1 Bit +0x004 ObjectTypeCode : Uint4B +0x008 InvalidAttributes : Uint4B +0x00c GenericMapping : _GENERIC_MAPPING +0x000 GenericRead : Uint4B +0x004 GenericWrite : Uint4B +0x008 GenericExecute : Uint4B +0x00c GenericAll : Uint4B +0x01c ValidAccessMask : Uint4B +0x020 RetainAccess : Uint4B +0x024 PoolType : NonPagedPool = 0n0 NonPagedPoolExecute = 0n0 PagedPool = 0n1 NonPagedPoolMustSucceed = 0n2 DontUseThisType = 0n3 NonPagedPoolCacheAligned = 0n4 PagedPoolCacheAligned = 0n5 NonPagedPoolCacheAlignedMustS = 0n6 MaxPoolType = 0n7 NonPagedPoolBase = 0n0 NonPagedPoolBaseMustSucceed = 0n2 NonPagedPoolBaseCacheAligned = 0n4 NonPagedPoolBaseCacheAlignedMustS = 0n6 NonPagedPoolSession = 0n32 PagedPoolSession = 0n33 NonPagedPoolMustSucceedSession = 0n34 DontUseThisTypeSession = 0n35 NonPagedPoolCacheAlignedSession = 0n36 PagedPoolCacheAlignedSession = 0n37 NonPagedPoolCacheAlignedMustSSession = 0n38 NonPagedPoolNx = 0n512 NonPagedPoolNxCacheAligned = 0n516 NonPagedPoolSessionNx = 0n544 +0x028 DefaultPagedPoolCharge : Uint4B +0x02c DefaultNonPagedPoolCharge : Uint4B +0x030 DumpProcedure : Ptr64 void +0x038 OpenProcedure : Ptr64 long +0x040 CloseProcedure : Ptr64 void +0x048 DeleteProcedure : Ptr64 void +0x050 ParseProcedure : Ptr64 long +0x058 SecurityProcedure : Ptr64 long +0x060 QueryNameProcedure : Ptr64 long +0x068 OkayToCloseProcedure : Ptr64 unsigned char +0x070 WaitObjectFlagMask : Uint4B +0x074 WaitObjectFlagOffset : Uint2B +0x076 WaitObjectPointerOffset : Uint2B +0x0b8 TypeLock : _EX_PUSH_LOCK +0x0c0 Key : Uint4B ; 一个 4 字节的标签用于唯一标识分配包含特定类型对象的内存 +0x0c8 CallbackList : _LIST_ENTRY _OBJECT_TYPE 结构和 _OBJECT_TYPE_INITIALIZER 结构中的域: 域 用途 Name 类型对象的名称 (Process, Event, Port 等等) PoolType 指明了这种类型的对象应该从换页的还是非换页的内存分配 DefaultPagedPoolCharge &amp; DefaultNonPagedPoolCharge 默认的配额花费, 默认从进程配额中扣除的换页内存值和非换页内存值 ValidAccessMask 线程在打开某个指向该类型的对象时, 可以请求的访问类型 GenericMapping 通用访问权限的映射关系, 在四种通用的访问权限和特属于该类型的访问权限之间的映射关系 ObjectTypeFlags 对象标志, 具体标志在结构中已注解 ObjectTypeCode 用于描述这种对象的类型 (对应于另一种方法, 比较名称值). 文件对象设置该类型码为 1, 同步对象设置为 2, 线程对象设置为 4, ALPC 也利用该域来保存一条消息关联的句柄属性信息 InvalidAttributes 指明了对象属性标志对此对象类型无效 DefaultObject 指定了在等待此对象过程中应该使用的对象管理器内部事件(如果对象类型创建者请求一个默认对象的话). 注意: 特定的对象, 比如文件对象和 ALPC 端口对象, 已经包含了他们自己内嵌的分发器对象. 在这种情况下, 该域是对象体内部的偏移量. 例如, FILE_OBJECT 结构内部的事件位于内嵌的 Event 域中. XXXXProcedure 在一个对象的生命期的特点上, 对象管理器自动调用一个或者多个例程来满足功能 {% note success %} 同步是一个对于 Windows 应用程序可见的属性, 它指的是, 一个线程通过等待某个对象从一种状态改成成另一种状态, 从而达到同步其执行过程的能力. 一个线程可以通过执行体的作业, 进程, 线程, 文件, 事件, 信号量, 互斥体和定时器对象来进行同步.其他的执行体对象不支持同步. 一个对象支持同步的能力基于以下三种可能性: * 该执行体对象是一个分发器对象的包装对象, 它包含一个分发器头; 分发器头是一个内核结构. * 对象类型的创建者请求一个默认对象, 而对象管理器提供默认对象. * 执行体对象有一个内嵌的分发器对象, 比如在对象体内部某处的一个事件; 该对象呢的所有者在注册此对象类型时向对象管理器提供了此内嵌对象的偏移量. {% endnote %} 对象方法_OBJECT_TYPE_INITIALIZER 结构中 XXXXProcedure 域, 即方法, 是一组内部例程构成的.之所以设计这些对象方法, 是为了针对这样的事实: 某些特定的对象操作是通用的 (关闭, 复制, 安全等). 要将这些通用的操作完全一般化将要求对象管理器设计者必须预知所有的对象类型. 对象方法: 方法 何时调用 Open 当对象句柄被打开时 Close 当对象句柄被关闭时 Delete 在对象管理器删除对象之前 QueryName 当线程请求在一个从属命名空间中查询一个对象的名称时(比如文件对象) Parse 当对象管理器在一个从属命名空间中搜索一个对象名称时 Dump 未使用 OkayToClose 当对象管理器接到指令要关闭句柄时, 针对恶意或者不正确关闭句柄的一个额外保护层 Security 当进程读取或改变一个对象在其从属命名空间中的保护属性时 这一规则的一个例外是安全(Security)例程, 该例程除非另行指明, 否则默认指向 SeDefaultObjectMethod. 此默认例程不需要知道对象的内部结构, 因为它只处理对象的安全描述符.而安全描述符的指针存储在所有对象都适用的对象头, 而不是对象体中. 对象句柄和进程句柄表对象目录内核池]]></content>
      <categories>
        <category>Windows kernel learning</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 hexo NexT 添加 Gitment 评论插件]]></title>
    <url>%2FStaticBlog%2F2017%2FNexT%2BGitment%2F</url>
    <content type="text"><![CDATA[Gitment 是作者imsun实现的一款基于 GitHub Issues 的评论系统. 支持在前端直接引入, 不需要任何后端代码. 可以在页面进行登录, 查看, 评论, 点赞等操作. 同时有完整的 Markdown / GFM 和代码高亮支持. 尤为适合各种基于 GitHub Pages 的静态博客或项目页面. 这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件, 并且增加一个点开显示评论的按钮, 对于 Gitment 的使用请参考 imsun 的博客. 另外, 本教程的按钮样式和代码均直接取自 ehlxr 博主. “显示 Gitment 评论” 的按钮样式在 next/source/css/_common/components 目录中新建一个 gitment.styl 的 css 样式文件, 复制以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.gitment_title:hover &#123; color: #fff; background: #0a9caf; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(10, 156, 175);&#125;.gitment_title &#123; border: 1px solid #0a9caf; border-top-color: rgb(10, 156, 175); border-top-style: solid; border-top-width: 1px; border-right-color: rgb(10, 156, 175); border-right-style: solid; border-right-width: 1px; border-bottom-color: rgb(10, 156, 175); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(10, 156, 175); border-left-style: solid; border-left-width: 1px; border-image-source: initial; border-image-slice: initial; border-image-width: initial; border-image-outset: initial; border-image-repeat: initial; border-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;&#125;.gitment_title &#123; display: inline-block; padding: 0 15px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; color: #0a9caf; cursor: pointer; font-size: 14px;&#125; 然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句 @import &quot;gitment&quot;; 添加 Gitment 插件打开 /next/layout/_partials/comments.swig 文件, 在最后一个 elseif 代码块下面添加 Gitment 的内容. 例如我的就是这样 12345678910111213141516171819202122232425262728293031323334353637383940... // 上面内容省略了..&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div id="SOHUCS"&gt;&lt;/div&gt;&#123;% elseif theme.gitment.enable %&#125; &lt;div onclick="showGitment()" id="gitment_title" class="gitment_title"&gt;显示 Gitment 评论&lt;/div&gt; &lt;div id="container" style="display:none"&gt;&lt;/div&gt; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &lt;script&gt; const myTheme = &#123; render(state, instance) &#123; const container = document.createElement('div'); container.lang = "en-US"; container.className = 'gitment-container gitment-root-container'; container.appendChild(instance.renderHeader(state, instance)); container.appendChild(instance.renderEditor(state, instance)); container.appendChild(instance.renderComments(state, instance)); container.appendChild(instance.renderFooter(state, instance)); return container; &#125; &#125; function showGitment() &#123; $("#gitment_title").attr("style", "display:none"); $("#container").attr("style", "").addClass("gitment_container"); var gitment = new Gitment(&#123; id: window.location.pathname, theme: myTheme, owner: '&#123;&#123; theme.gitment.owner &#125;&#125;', repo: '&#123;&#123; theme.gitment.repo &#125;&#125;', oauth: &#123; client_id: '&#123;&#123; theme.gitment.client_id &#125;&#125;', client_secret: '&#123;&#123; theme.gitment.client_secret &#125;&#125;' &#125; &#125;); gitment.render('container'); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后打开 NexT 主题的 _config.yml 文件, 在评论相关设置的区域添加下面的代码, 并根据 Gitment 文档说明来添加相应的值 1234567# Gitment commentsgitment: enable: true owner: xxxx repo: xxxx client_id: xxxx client_secret: xxxx 最终效果见本博客下方~]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDU 编码规则]]></title>
    <url>%2FStaticBlog%2F2017%2FPDU-Encode%2F</url>
    <content type="text"><![CDATA[PDU模式不仅支持中文短信，也能发送英文短信。PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据消息，UCS2编码用于发送Unicode字符。 PDU 内容总长度 140 个字节 (1120位)，支持采用三种编码方式：7-bit、8-bit 和 UCS2 编码。7-bit 编码——用于发送普通的 ASCII 字符，ASCII码表最大到0x7X，最高位为0，总 7-bit，实际编码时则可把8-bit的最高位比特使用起来，所以可支持1120/7=160个字符；8-bit 编码——用于发送数据消息，比如图片和铃声、二进制数据等，此类数据无法使用 7-bit 编码，因为那样会丢掉一位，也不能用下面UCS2编码，因为不符合 UNICODE 编码检查（范围）。8-bit 编码最多支持 140 个字节数据。UCS2 编码——用于发送 Unicode 字符，每个中文（韩文、日文），占用 2 字节，只要短信里包含这些多字节编码文字，那么即使还有英文，英文也需要安装 UCS2 编码，也占用 2 字节，所以，最多支持 70 个中文字（或中英混合短信） 编码格式一般的PDU编码由A B C D E F G H I J K L M十三项组成: SCA (短信中心) 结构部分：AT指令中 AT+CMGS= Len不包含此段位组的长度 Index Item Description A &lt;sc_len&gt; B+C的长度, 1Byte B &lt;type_addr&gt; SMSC地址类型, 1Byte C &lt;number&gt; SMSC 号码 TPUD 结构部分： Index Item Description D &lt;option&gt; 基本参数(TP-MTI/VFP), 1Byte E &lt;MR&gt; 短信标识符(TP-MR), 1Byte F v 目标号码长度, 1Byte G &lt;DA&gt; 被叫号码类型, 1Byte H ^ 被叫号码, 长度由F中的数据决定 I &lt;PID&gt; 协议标识(TP-PID), 1Byte J &lt;DCS&gt; 数据编码(TP-DCS), 1Byte K &lt;VP&gt; 有效期(TP-VP), 1Byte L &lt;UDL&gt; 用户数据长度(TP-UDL), 1Byte M &lt;UD&gt; 用户数据 SCA 结构部分详细说明&lt;sc_len&gt;：表示 （短信中心号码）的长度，包含两个字符，指示 和 所占字符的个数除于 2。 &lt;type_addr&gt;：表示号码地址类型，包含两个字符，其结构如下： 123bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit01 Type-of-number Numbering-plan-identification1 0 0 1 0 0 0 1 bit7 固定为 1 Type-of-number (bit6-bit4) 取值如下： value Descation 000 若用户不能识别目标地址号码时，选用此值。此时地址号码由网络侧决定。 001 若用户能识别是国际号码或者或者认为是国内范围时，选用此值。 010 国内号码，不允许加前缀或者后缀。在用户发送国内电话时，选用此值。 011 本网络内的特定号码，用于管理或者服务，用户不能选用此值。 101 号码类型为 GSM 的缺省 7-bit 编码方式。 110 短小号码，暂不使用。 111 扩展保留，暂不使用。 Numbering-plan-identification (bit3-bit0) 取值如下：(注：当 bit6-bit4 取值为 000, 001, 010 时才有效，其他情况 bit3-bit0 无效) value Descation 0000 号码由网络侧的号码方案确定 0001 ISDN/电话号码方案 0011 数据号码方案，暂不使用 0100 Telex 号码方案，暂不使用 1000 国内号码方案，暂不使用 1001 私人号码方案，暂不使用 1010 ERMES 号码方案，暂不使用 &lt;numbers&gt;：表示地址号码，一个字节储存两个数字，且 bit3~bit0 储存第一个数字，bit7~bit4 储存第二个数字，如果号码为奇数，则最后一位补F后，再进行反转。如果为偶数，则不需要补F。像是反序的 8421 BCD 码，可如下例所示： 例如有13 81 23 45 67 8存储为21 18 32 54 76 F8 TPDU 结构部分&lt;option&gt;： 12RP UDHI SRR VPF RD MTIbit7 bit6 bit5 bit4-3 bit2 bit1-0 &lt;MTI&gt;：表示短消息类型。 bit1 bit0 Descrption 0 0 SMS-DELIVER (SC 到 MT 方向) 0 0 SMS-DELIVER-REPORT (MT 到 SC 方向) 1 0 SMS-STATUS-REPORT (SC 到 MT 方向) 1 0 SMS-COMMAND (MT 到 SC 方向) 0 1 SMS-SUBMIT (MT 到 SC 方向) 0 1 SMS-SUBMIT-REPROT (SC 到 MT 方向) 1 1 保留 &lt;RD&gt;：指示 SC 是否需要接受一个仍保存在 SC 中，与以前同一 OA 发出具有相同的 MR 和 DA 的短消息。 0 接受1 不接受 &lt;VPF&gt;：指示 VP 字段格式的有效性，格式指示。 bit1 bit0 Descrption 0 0 VP 字段无效 1 0 VP 字段有效，格式为 “relative” 0 1 VP 字段有效，格式为 “enhanced” 1 1 VP 字段有效，格式为 “absolute” &lt;RP&gt;：回复短信路径的设置指示，与短信发送时的设置相同。 0 没有设置1 设置，指示回复短信与发送时具有相同的 SC 号码设置，返回路径相同。 UDHI：用户数据头的指示。 0 用户数据段只有短消息的内容1 用户数据段除了短消息外，还包含有一个数据头 &lt;SRR&gt;：状态报告请求指示。 0 不需要一个短信成功发送的状态报告信息1 需要一个短信成功发送的状态报告信息 &lt;MR&gt;：表示短信标识符，取值范围为 0～255。 &lt;DA&gt;：目标地址信息，结构同 SCA，但是有一点不同需要注意！就是 len 字段不再是 type 和 number 的字节长度，而是 number 的字符长度 &lt;PID&gt;：协议指示。 Bit7-6 : Bit7 Bit6 (目前， Bit 7=0 和 Bit 6=0) 0 0 分配 bits 0-5 1 0 分配 bits 0-5 0 1 保留 1 1 分配 bits 0-5，为 SC 的特殊用途 Bit5 : 0 无交互操作，但有 SME-to-CSME 协议1 Telematic 交互操作 （此情况下， bit 4-0 的取值有效） Bit4-0 : 若取值为 10010，则表示 Email ，其它取值暂不支持。 &lt;DSC&gt;：表示用户数据的编码方式。 00 7-bit 编码 (英文)04 8-bit 编码 (图片和铃声)08 16-bit 编码 (UCS2) Bit No.7与Bit No.6：一般设置为00 Bit No.5：0-文本未压缩1-文本用GSM标准压缩算法压缩 Bit No.4：0-指示Bit No.1 Bit No.0为保留位，不含信息类型信息1-指示Bit No.1 Bit No.0含信息类型信息 Bit No.3与Bit No.2：00-默认的字符集，每字符占7bit，此时最大可发送160字符01-8bit，此时最大可发送140字符10-USC2（16bit），发送双字节字符集11-预留 Bit N0.1与Bit No.0：00-Class 0，短消息直接显示在屏幕上01-Class 1，10-Class 2（SIM卡特定信息），11-Class 3 &lt;VP&gt;：表示有效期，时间从短消息被 SC 接收到开始计算。如果 =00，则该字段缺失，时间表示如下： VP 取值 说明 0~143 (VP + 1) x 5 minutes 144~167 12 hours + ((VP - 143) x 30 minutes) 168~196 (VP - 166) x 1 day 197~255 (VP - 192) x 1 week &lt;UDL&gt;：表示用户数据长度，取值取决于具体的编码方式。 若是 7-bit 缺省编码， 表示共有多少个 septets。 若是 8-bit 编码， 表示共有多少个 Octets。 若是 UCS2 编码， 表示共有多少个 Octets。 若是有压缩的 7-bit 或 8-bit 或 UCS2 编码， 表示压缩后共有多少个 Octets。 对压缩的短信编码， 的数据长度不超过 160 septets；对无压缩编码的短信， 长度不超过 140 Octets。 &lt;UD&gt;：表示用户数据，其有效数据由参数 决定。 举个栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849AT+CMGW=300891683108705505F011000791680180F60008AA1200480065006C006C006F002055B555B5FF01AT 指令后面这个长度是 &lt;TPUD 结构的8位字节个数&gt;首先看下 SCA 结构 0891683108705505F00x08SCA 号码类型和号码的长度0x91SCA 号码为国际号码，即 &quot;+&quot;683108705505F0可解析短信中心号码为 8613800755500然后看下 TPUD 结构 11000791680180F60008AA1200480065006C006C006F002055B555B5FF010x11 optionsBit No. 7 6 5 4 3 2 1 0 RP UDHI SRR VPF VPF RD MTI MTI 0 0 0 1 0 0 0 10x00 MR置为00即可0791680180F6 DA解析为 07 91 86100860x00 PID对于标准情况下的MS-to-SC短消息传送，只需设置PID为000x08 DCSUSC2（16bit）双字节字符集0xAA 有效期第一种情况（相对的）：VPF=10 VP=AAH（四天），在这里是第一种第二种情况（绝对的）：VPF=11年 月 日 时 分 秒 时区30 80 02 90 54 33 20 表示：03-08-20 09:45:330x12 UDL18 个8位字节0048 0065 006C 006C 006F 0020 55B5 55B5 FF01H e l l o 空格 喵 喵 ！]]></content>
      <tags>
        <tag>PDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows kernel learning: 3. Memory Management]]></title>
    <url>%2FStaticBlog%2F2017%2FWindows-kernel-learning%2FWindows-kernel-learning-3-Memory-Management%2F</url>
    <content type="text"><![CDATA[一个操作系统要称为现代意义上的操作系统就必须提供对内核的保护, 对不同用户程序之间的隔离, 并允许软件的载入位置浮动.而满足这些基本要求的手段, 就是采用基于页面映射的 “虚拟内存” 机制, 或者说提供 “分页内存管理”. 在硬件上, 这是由 CPU 芯片的 “存储管理单元” MMU 支持的. 而在软件商, 则由操作系统内核中的内存管理模块实现. 采用分页内存管理时, 程序中所使用的内存地址, 即 CPU 中的运算单元 ALU 所发出的都是 “虚拟地址”, “虚拟地址” 是不能直接用来访问物理内存的, 需要 MMU 将其 “映射” 到某个物理页面上转换成 “物理地址” 才能访问. 这种映射是以页面为单位的,而不是以单个地址为单位的. 此外, MMU 还担负着检查访问权限的任务, 可以根据 CPU 的当前状态和访问形式决定是否允许访问. 为什么要有这样的映射呢? 每个进程的虚拟地址的范围是相同的, 但是实际映射的确是物理内存中不同的部位, 这样就实现了软件载入(物理)地址的浮动. 不同进程的虚拟地址被映射到物理内存中不同的页面集合, 每个进程都有自己的映射, 互相之间没有交集, 解决了进程间隔离的问题. 把 CPU 的运行状态分成 “用户态” 和 “内核态”, 其虚拟地址范围也分成两个部分, 一部分属于内核, 另一部分属于用户程序. 并使 CPU 运行于用户态时就没有访问内核部分的权限, 这就解决了保护内核的问题. MMU 怎么知道哪一个虚拟页面应当被映射到哪一个物理页面呢? 为此就需要有个 “页面映射表”. 页面映射表实际上是个以虚拟内存页面号为下标的数组, 数组中的元素称为页面映射表项, 表项的内容决定了相应的虚拟内存页面是否有映射, 映射到哪一个物理页面, 以及该物理页面的保护模式 (权限要求和所允许的访问模式). 每个进程都有自己的页面映射表. CPU 在执行哪一个进程的程序, 就使用哪一个进程的页面映射表. CPU 有个专门的控制寄存器 CR3, 这个寄存器总是指向当前进程的页面映射表 (使用物理地址). CPU 根据实际需要把当前用到的页面映射表项告诉混存在内部的 TLB (地址转换便查缓冲区) 中, 是 CPU 内部一块专用的, 特殊的 (只读) 高速缓存. 每当需要使用一个页面映射表项时, MMU 首先在 TLB 中寻找, 找到就不需要访问物理内存了, 找不到才从物理内存装入所需的表项. 在 CPU 的页面映射机制中, MMU 的作用是: 根据虚拟内存地址计算出该地址所属的页面; 再根据页面映射表的起始地址计算出该页面映射表项所在的物理地址; 根据物理地址在高速缓存的 TLB 中寻找该表象的内容; 如果该表项不在 TLB 中, 就从内存将其内容装载到 TLB 中; 检查该表项的 PA_PRESENT 标志位, 如果为1就表示映射的目标为某个物理页面, 因而可以访问这个页面, 但是需要进一步检查是否具有所要求的访问权限, 权限不足就会产生一次页面异常. 如果 PA_PRESENT 标志位为0, 则说明该虚拟内存页面的映像不在内存中, 当前指令因此失败, CPU 为此产生一次页面异常, 此时响应的异常处理程序采取响应措施: 如果整个页面映射表象为 0, 就说明该虚拟内存页面尚无映射, 对策是检查该虚拟内存页面是否落在已分配使用的区间, 如果是就为其分配物理页面并建立映射,然后重新执行失败的指令; 如果不是就属于越界访问, 应该引起更高层次的出错处理, 直至终止当前进程的运行. 如果整个页面映射表项非 0, 就说明虚拟内存页面的映像存在某个页面倒换文件之中, 对策是为其分配物理页面, 从页面倒换文件读入该页面的映像, 并将该页面映射表项修改为指向此物理页面, 然后重新执行失败的指令. 不过系统的分页内存管理实际上是段式内存管理机制基础之上的分页内存管理, 即二者结合.机器指令中所用的地址其实是以 “段 + 偏移” 的形式给定 “逻辑地址”, 每个段都有一个 64 位的段描述符块, 里面说明的段的起点, 长度, 访问权限的要求等信息. 而段寄存器的内容则为 “段选择项”, 程序实际用于数据存储的内存区间可以分为三类: 全局数据所占用的空间, 这是在编译/链接的时候就静态的分配好的,并于整个可执行程序共存亡. 其分配和释放都是不可见的. 局部数据所占用的空间, 一般是在调用一个函数或分配局部变量的时候, 自动从栈上动态分配的, vu你在于这个函数的调用框架之中, 其寿命取决于 CPU 运行于这个函数中的时间. 这部分空间的分配和释放也是不可见的. 通过 malloc 一类的函数动态分配的堆缓冲区, 所占用的空间一直会存在到通过 free 一类的函数加以释放, 或者程序退出运行. 其空间的分配和释放是可见的, 运行中的程序完全掌握主动, 也承担责任. 分页处理器对虚拟地址的限制一个 64 位的 CPU 可以寻址 2^64 字节的内存, 这是一个巨大的地址空间, 远超系统所需要的.由于虚拟地址必须被翻译, 因此内存管理单元必须处理每个地址位, 因此其复杂性随地址大小而增加. 因此, 当前的 x64 处理器实际上将可用位数限制为 48 位, 但是有个巧妙的方案. 简单的不允许使用位 48-63 将导致虚拟内存地址限制在 256TB 以下, 这将使操作系统设计复杂化.例如在 32 位 Windows 中, 完整的 32 位虚拟地址可用, 系统代码和数据放置在虚拟地址空间的上半部分, 即高于 2GB, 从而在应用程序和系统代码之间有了清晰的分界. 如果地址限制在 256TB, 远远低于 8EB 一半的大小, 那么在 x64 中是不可能的. 所以高 16 位被用作符号扩展 (任何虚拟地址的48位至63位必须与47位一致)这意味着我们有两个有效的地址范围: 0 - 0x7FFF&#39;FFFFFFFF 47~63 位都是0 0xFFFF8000&#39;00000000 - FFFFFFFF&#39;FFFFFFFF 47~63 位都是 1 x64 代码中使用的所有地址必须是规范形式的, 即从 63 位到实现位都是 0 或 1. 尝试使用非规范地址会导致页面错误异常. 页面翻译概述处理器使用内存中的一组表来确定与虚拟内存对应的物理地址. 在长模式下, 可提供 4KB, 2MB 和 1GB 字节物理页大小.在传统模式下, 可提供 4KB, 2MB 和 4MB 的大小. !!! 在这篇文章我只介绍长模式和传统模式的 4KB 页面分页模式. 页面翻译选项有四个控制寄存器位来控制页面翻译选项: CR0.PG CR0[bit31], 页面翻译启用 CR4.PAE CR4[bit5], 物理地址扩展, 置1可将虚拟地址转换为长达52位的物理地址. 激活长时间模式前必须启用PAE CR4.PSE CR4[bit4], 页面大小扩展, 置1可以是操作系统在页面翻译过程中使用 4MB 物理页面. 页面大小的选择是在PDE的基础上进行的.物理页面的大小的选择取决于CR4.PSE和CR4.PAE的值,具体如图. (处于长模式时, CR4.PSE 的值将被忽略, 因为 PAE 必须被启用) EFER.LMA 长模式激活 PDE.PS PDE[bit7], 置1时, 使用大的物理页面(大小由 PAE 和 PSE 决定), 并且 PDE 成为翻译层次结构的最低级别. PDPE.PS PDPE[bit7], 置1时, 使用 1GB 的物理页面, 并且 PDPE 成为翻译层次结构的最低级别. 不是所有模式都可以使用这些选项, 表总结了每种模式下可用的分页支持选项 访问无效地址引用无效地址都会产生页面错误异常, 中断帧被推送到堆栈上, 保存的rip指向尝试内存引用的指令. 这个特殊的异常还会使用附加信息推送错误代码, 例如: 读取, 写入或指令提取. 此外, CR2 寄存器设置为代码尝试访问的地址. 长模式页面翻译长模式页面翻译需要使用页面地址扩展 (CR4.PAE). 在启用 PAE 之前激活长模式会导致通用保护异常 (#GP) 发生. 64位寻址模式 (长模式), 是物理地址扩展 (PAE) 的超集; 因此不同于 x86 体系结构, 每级页表寻址长度变成 9 位, 由于在 x64 体系结构中, 普通页大小仍为 4KB, 然而数据却表示 64 位长, 因此一个 4KB 页在 x64 体系结构下只能包含 512 项内容, 所以为了保证页对齐和以页为单位的页表内容换入换出, 在 x64 下每级页表寻址部分的长度定为 9 位. 为了正确翻译 x64 的线性地址, 其页表也从 x86 的 2 级变成了 4 级, 翻译过程如图所示, 在 x64 体系结构中, 每级页表包含 512 项 (2^9) 下级目录的指针, 该指针称为页表项, 描述了存储下级. CR3 寄存器在长模式下, CR3寄存器用于指向PML4基地址. CR3在长模式下扩展为64位, 允许PML4表位于52位物理地址空间的任何位置. Table Base Address Field: 位 51~12, 这个字段指向 PML4 基地址, PML4 表在 4KB 的边界上对齐, 低 12 位地址位假定为0, 总共为 52 位的基地址大小. 在支持小于 52 位物理地址空间的CPU上, 必须将未实现的高地址位清零. PWT (Page-Level Writethrough): 页面转换表是否具有回写或Writethrough缓存策略. 为 0 时具有回写缓存策略, 为 1 时具有 Writethrough 缓存策略 PCD (Page-Level Cache Disable): 最高级别页面转换表是否可缓存. 为 0 时可缓存, 为 1 时不可缓存. 4KB 页面翻译 Present (P) Bit: 指示页面翻译表或物理页是否加载在物理内存中, 如果为 0 时访问表或页面将引发页面异常 (#PF). 此位为 0 时, 其他控制位无效. 且不会被缓存到 TLB 中. Read/Write (R/W) Bit: 控制读写访问, 为 0 时只读, 为 1 时读写. User/Supervisor (U/S) Bit: 用户权限控制, 为 0 时限制访问特权级别为内核态(CPL 0, 1, 2). 为 1 时, 可被用户态和内核态访问 (CPL 0, 1, 2, 3). Page-Level Writethrough (PWT) Bit: 同 CR3.PWT 解释 Page-Level Cache Disable (PCD) Bit: 同 CR3.PCD 解释 Accessed (A) Bit: 指示是否访问了页面转换表或物理页, 此位在第一次读取或写入时置1, CPU 不会清除此位 Dirty (D) Bit: 该位仅存在于页面翻译层次结构的最低级别中. 它指示此地址的物理页面是否写入. 此位在第一次写入物理页面时置1, CPU 不会清除此位 Page Size (PS) Bit: 此位存在于 PDE 和 长模式的 PDPE 中. 当 此位设置在 PDPE/PDE 中, 那么这个 Entry 是页面翻译层次结构的最低级别.当 PS 位在 PTE 以上的所有级别清除为0时, 页面转换层次结构的最低级别是 PTE, 物理页面大小为 4KB. Global Page (G) Bit: 此位仅存在于页面翻译层次结构的最低级别. 指示物理页面是一个全局页面.当 CR3 由 MOV VRn 指令显式加载或在任务切换期间隐含加载时, 全局页面 (G=1) 的 TLB 不会失效.使用G位需要将 CR4.PGE=1 Available to Software (AVL) Bit: CPU 不解释不适用, 供系统使用 Page-Attribute Table (PAT) Bit: 页属性表支持位. 该位仅在页面翻译层次结构的最低级别中. 如果最低级别是 PTE (PDE.PS=0), 则 PAT 在 bit7 如果最低级别是 PDE (PDE.PS=1) 或 PDPE (PDPE.PS=1), 则 PAT 在 bit12此位涉及更复杂的分页系统, 和页高速缓存有关, 可以不予理会, 在普通的4KB分页机制中, 处理器建议将其置0. No Execute (NX) Bit: 指示此物理页面的内容不可执行. 此位仅存在于 PAE 定义的转换表项中, 传统模式 PDPE 不包含此位.只有在通过将 EFER.NXE 设置为1, 启用了无执行页面保护功能时, 才能设置NX位. 否则 NX 被视为保留位, 必须为0. 根据图我们可以得到页面翻译过程为: PML4E(PDP) = CR3(PML4) + PML4_Index * 8 PDPE(PD) = PDP + PDP_Index * 8 PDE(PT) = PD + PD_Index * 8 PTE(PhysicalAddressBase) = PT + PT_Index * 8 PhysicalAddress = PhysicalAddressBase + PhysicalOffset. 传统模式页面翻译传统模式支持两种形式 Normal Paging (Non-PAE) - 当物理地址扩展被禁用时使用 (CR4.PAE = 0) . 页面转换表中的 Entry 是32位, 用于将32位虚拟地址转换为大到40位的物理地址. PAE Paging - 当物理地址扩展被启用时使用 (CR4.PAE = 1). 页面转换表中的 Entry 是64位, 用于将32位虚拟地址转换为高达52位的物理地址. 根据所使用的分页形式和物理页大小, 传统分页最多使用三层页面转换表. 使用虚拟地址位字段选择每个表内的 Entry.传统模式页面翻译表: PT (Page Table, 页表) - 每个页表项 (PTE) 指向物理页. 如果使用 4KB 页面, 页表是页面翻译层次结构的最低级别. 翻译 2MB 或 4MB 的页面时, 不会使用PTE. PD (Page Directory, 页面目录) - 如果使用 4KB 页面, 则每个 PDE 指向页表. 如果使用 2MB 或 4MB 的页面, 则 PDE 是页面翻译层次结构的最低级别, 并指向物理页面.在 Non-PAE 形式中, 页面目录是翻译层次结构的最高级别. PDP (Page Directory Pointer, 页面目录指针) - 每个 PDPE 指向页面目录. 页目录指针仅用于 PAE 分页 (CR4.PAE = 1), 是传统页面翻译层次结构中的最高级别. CR3 寄存器CR3寄存器用于指向最高级页面转换表的基址, 基址是页面目录指针表或者页面目录表. CR3 各控制位解释参考长模式. Non-PAE 4KB 页面翻译 PxE 各控制位解释参考长模式. PAE 4KB 页面翻译PAE 自动使用页大小位, 所以 PAE形式忽略 CR4.PSE 的值. TLB 和 Paging-Structure Cache 简单概述为了将虚拟地址转换为物理地址, 处理器必须执行 4 个存储器访问, 一个用于层次结构中的每个PS. 由于内存延迟比指令执行时间长得多, 因此这显着减慢了处理器的浪费.为了避免这种情况, 使用两种类型的缓存：TLB 和 Paging-Structure Cache. TLB (Translation Lookaside Buffers) 就是 Cache 的一类. TLB 缓存从虚拟地址到物理地址的完整翻译, 以及所有控制信息, 即页面是读/写还是只读, 是否可以在 Ring3 访问等. 如果虚拟的翻译地址在 TLB 中找到, 不需要访问内存中的分页结构. Paging-Structure Cache, 它缓存页表的各级 Table-Entry. 它是与 TLB 互补的. 举个例子, 动动手~好, 我们已经了解了上面的基础知识, 那么我们来动手实践一下来将虚拟地址转换成物理地址 12char vStr[] = &#123; "Hello Memory Manager!\n" &#125;;printf("0x%p\n", vStr); 动手翻译长模式虚拟地址 操作系统: Windows 8.1 x64 我们用这两行代码来输出这个字符串的虚拟地址为 0x0076FA1C, 然后我们去找到对应的物理地址. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162; 我们根据地址 0x0076FA1C 来拆分出各种页表页目录的 index 和 offset; 000000000 000000000 000000011 101101111 101000011100 (0x0076FA1C); 0 0 3 16f a1c; PML4_Index = 0; PDP_Index = 0; PD_Index = 3; PT_Index = 0x16f; PhysicalOffset = 0xa1c1: kd&gt; r cr3cr3=00000000768e10001: kd&gt; !dq 00000000768e1000 &amp; 000fffff`fffff000#768e1000 1f200000`7ad46867 00000000`00000000#768e1010 00000000`00000000 00000000`00000000#768e1020 00000000`00000000 00000000`00000000#768e1030 00000000`00000000 00000000`00000000#768e1040 00000000`00000000 00000000`00000000#768e1050 00000000`00000000 00000000`00000000#768e1060 00000000`00000000 00000000`00000000#768e1070 00000000`00000000 00000000`000000001: kd&gt; !dq 1f200000`7ad46867 &amp; 000fffff`fffff000#7ad46000 00d00000`37cc7867 01100000`7880a867#7ad46010 00000000`00000000 00000000`00000000#7ad46020 00000000`00000000 00000000`00000000#7ad46030 00000000`00000000 00000000`00000000#7ad46040 00000000`00000000 00000000`00000000#7ad46050 00000000`00000000 00000000`00000000#7ad46060 00000000`00000000 00000000`00000000#7ad46070 00000000`00000000 00000000`000000001: kd&gt; !dq (00d00000`37cc7867 &amp; 000fffff`fffff000) + 3 * 8#37cc7018 01d00000`62d95867 06400000`6c0ad867#37cc7028 1c800000`2b4ca867 00000000`00000000#37cc7038 00000000`00000000 00000000`00000000#37cc7048 00000000`00000000 00000000`00000000#37cc7058 00000000`00000000 00000000`00000000#37cc7068 00000000`00000000 00000000`00000000#37cc7078 00000000`00000000 00000000`00000000#37cc7088 00000000`00000000 00000000`000000001: kd&gt; !dq (01d00000`62d95867 &amp; 000fffff`fffff000) + 16f * 8#62d95b78 93b00000`751c5847 8aa00000`78bb8005#62d95b88 8ab00000`1a3f9005 8ac00000`1e7fa005#62d95b98 8e800000`7adfb005 00000000`00000000#62d95ba8 00000000`00000000 00000000`00000000#62d95bb8 00000000`00000000 00000000`00000000#62d95bc8 00000000`00000000 00000000`00000000#62d95bd8 00000000`00000000 00000000`00000000#62d95be8 00000000`00000000 00000000`00000000; 最后我们看到, 这个物理地址的内容就是我们输出的字符串~1: kd&gt; !db (93b00000`751c5847 &amp; 000fffff`fffff000) + a1c#751c5a1c 48 65 6c 6c 6f 20 4d 65-6d 6f 72 79 20 4d 61 6e Hello Memory Man#751c5a2c 61 67 65 72 21 0a 00 cc-cc cc cc cc cc cc cc cc ager!...........#751c5a3c 2a 30 00 00 00 00 00 00-00 00 00 00 00 00 00 00 *0..............#751c5a4c cc cc cc cc 37 d0 ae cb-68 fa 76 00 0e fd 2c 00 ....7...h.v...,.#751c5a5c 01 00 00 00 88 e5 ad 00-e8 e5 ad 00 c0 fa 76 00 ..............v.#751c5a6c 70 fb 2c 00 a3 d0 ae cb-00 00 00 00 00 00 00 00 p.,.............#751c5a7c 00 70 58 7f e8 49 80 10-80 f5 ff ff 00 00 00 00 .pX..I..........#751c5a8c 00 00 00 00 09 a0 39 77-00 00 00 00 30 22 25 01 ......9w....0"%. 动手翻译传统模式虚拟地址 操作系统: Windows 8.1 x86 字符串的虚拟地址为 0x00C2FA60 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859; 根据 CR4.PAE(Bit5)=1 确定为 PAE 形式的分页kd&gt; .formats @cr4Evaluate expression: Hex: 001406e9 Decimal: 1312489 Octal: 00005003351 Binary: 00000000 00010100 00000110 11101001 Chars: .... Time: Fri Jan 16 12:34:49 1970 Float: low 1.83919e-039 high 0 Double: 6.48456e-318; 我们根据地址 0x00C2FA60 来拆分出各种页表页目录的 index 和 offset; 00 000000110 000101111 101001100000; 0 6 2f a60; PDP_Index = 0; PD_Index = 6; PT_Index = 0x2f; PhysicalOffset = 0xa60kd&gt; r cr3cr3=032f1440kd&gt; !dq 032f1440 &amp; 000fffff`fffffFE0# 32f1440 00000000`00bc2801 00000000`150c3801# 32f1450 00000000`14384801 00000000`17f07801# 32f1460 00000000`2f262801 00000000`2f6a3801# 32f1470 00000000`308e4801 00000000`301a7801# 32f1480 00000000`2e68c801 00000000`2f20d801# 32f1490 00000000`2c30e801 00000000`2f2d1801# 32f14a0 00000000`3a84a801 00000000`3a849801# 32f14b0 00000000`3a848801 00000000`3a845801kd&gt; !dq (00000000`00bc2801 &amp; 000fffff`fffff000) + 6 * 8# bc2030 00000000`17aee867 00000000`17883867# bc2040 00000000`00000000 00000000`00000000# bc2050 00000000`00000000 00000000`00000000# bc2060 00000000`00000000 00000000`00000000# bc2070 00000000`00000000 00000000`00000000kd&gt; !dq (00000000`17aee867 &amp; 000fffff`fffff000) + 2f * 8#17aee178 80000000`1763b867 80000000`10613025#17aee188 00000000`17d1d867 00000000`17c32867#17aee198 00000000`178f3867 00000000`17db4867#17aee1a8 00000000`182b5867 00000000`179b6867#17aee1b8 00000000`167f7867 00000000`16df8867#17aee1c8 00000000`17e79867 00000000`150ba867#17aee1d8 00000000`17b3b867 00000000`16a7c867#17aee1e8 00000000`1663d867 00000000`17dfe867kd&gt; !db (80000000`1763b867 &amp; 000fffff`fffff000) + a60#1763ba60 48 65 6c 6c 6f 20 4d 65-6d 6f 72 79 20 4d 61 6e Hello Memory Man#1763ba70 61 67 65 72 21 0a 00 cc-cc cc cc cc cc cc cc cc ager!...........#1763ba80 2a 30 00 00 00 00 00 00-00 00 00 00 00 00 00 00 *0..............#1763ba90 cc cc cc cc fe 81 6e a0-ac fa c2 00 0e fd c7 00 ......n.........#1763baa0 01 00 00 00 58 d4 e9 00-b8 d4 e9 00 04 fb c2 00 ....X...........#1763bab0 70 fb c7 00 62 80 6e a0-e5 96 c7 00 e5 96 c7 00 p...b.n.........#1763bac0 00 40 bb 7f 00 00 00 00-00 00 00 00 00 00 00 00 .@..............#1763bad0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 嘿~是不是很神奇? 在 Windows 系统中与内存管理相关的基础概念页的几个术语 Virtual Page Offset, VPO (虚拟页偏移) 也就是前面说的分页模式中虚拟地址在物理 Page Frame 内的 Offset 值. Virtual Page Number, VPN (虚拟页号) 与 VPO 相对应, 用来查找最终的物理地址 Page Frame 地址. 在其中忽略的各种 Table Entry 的 Index 的值. Page Frame, PF (页帧) 是在物理地址空间里, 一个页的起始地址 (基地址), 分为 4 种: 4K Page Frame, 2M Page Frame, 4M Page Frame, 1G Page Frame. Page Frame Number, PFN (页帧号) 是以 PF, 即以页为单位对内存进行编号, 该编号可作为页数组的索引. 计算方法为 PF / PageSize 他们的关系如图: Windows 虚拟地址空间 IRQL在 &lt;&lt; Windows kernel learning: 1. Basis &gt;&gt; 中我们了解到有几种 IRQL. 其中定义了两个软件中断: APC 和 DPC.他们具有相关的 IRQL 级别: APC 中断为 1, DPC 为 2. 当检查软件中断的代码发现有一个正在等待处理时, 且当前 IRQL 小于中断 IRQL 则调用处理程序, 从而模拟处理器对硬件中断的处理. 当处理器的 IRQL 大于等于 2 时, 该处理器被阻止执行上下文切换的线程调度代码.处理器在 IRQL 为 1 时可以切换线程上下文, 并且当线程恢复时, IRQL 将恢复为线程被抢占时的值. 用户模式代码始终在 IRQL=PASSIVE 执行, 并且没有可用的 API 来更改当前的 IRQL. 所以, 用户模式代码总是可以中断, 并且线程上下文切换总是可能的. 处理程序代码绝不能降低 IRQL, 除非它在最后阶段即将要从中断返回. 当这种情况发生时, 处理程序必须恢复在中断发生前生效的 IRQL. 特别是, 它不能将 IRQL 设置为低于中断前的值. 一个代码块可以将IRQL显式提升到当前级别以上, 以禁止较高的IRQL中断. 这可以在处理程序和不是处理程序的任何一部分的代码中完成. 所有硬件中断都具有大于 DPC 的IRQL, 因此软件中断总是在硬件中断处理程序中被屏蔽 (但是只有在执行处理程序的处理器上才会被屏蔽, 其他处理器可能处于任何IRQL). 内核检查软件中断的一个阶段是在退出处理程序之前还原IRQL. 例如, 可能会发生以下事件序列: PASSIVE执行的代码被硬件中断中断. 处理程序代码请求软件 DPC 中断. 当前的 IRQL 大于 DPC, 因为它已经在处理程序逻辑开始处被提升为硬件中断的 IRQL, 所以 DPC 中断保持不变. 处理程序代码返回, 将 IRQL 还原为 PASSIVE. 降低 IRQL 的代码检查待处理的软件中断, 并找到DPC. 由于 IRQL 被设置为 PASSIVE, 所以可以对其中断. IRQL 设置为DPC, 并调用 DPC 中断的处理程序. 当处理程序返回时, IRQL 将再次恢复为 PASSIVE. 这一次没有进一步的中断等待, 并且被中断的代码被恢复. APC 中断APC (异步过程调用) 提供了一种在特定用户线程环境中执行用户程序和系统代码的途径. APC 例程可以访问资源(对象), 等待对象句柄, 引发页面错误, 以及调用系统服务. DPC 队列是系统范围的, 而 APC 队列是存在于每个线程中的. 有两种 APC 类型: 内核模式和用户模式.内核模式的 APC 并不要求目标线程获得许可(Alertable State), 而用户模式的线程必须获得许可才可以执行. 内核模式的 APC 也有两种类型: 普通的和特殊的.特殊的 APC 在 APC 级别上执行, 并且允许 APC 例程修改某些 APC 参数; 普通的 APC 在 PASSIVE 级别上执行, 并且执行被特殊APC 修改过的参数. APC 插入和交付的图表 APC 类型 插入行为 交付行为 特殊的 (内核模式) 插入在内核模式 APC 列表的尾部 只要 IRQL 降下来并且线程未在守护区域内, 就在 APC 级别上被交付. 相应的指针指向在插入 APC 时指定的参数 普通的 (内核模式) 插入在最后一个特殊 APC 的正后面 (也就是所有其他普通 APC 的头部) 在关联的特殊 APC 被执行后, 在 PASSIVE 级别上被交付, 此特殊 APC 返回的参数也被传递过来 普通的 (用户模式) 插入在用户模式 APC 列表的尾部 只要 IRQL 降下来, 并且线程未在临界区或守护区域内, 而且该线程处于 Alertable 的状态, 就在 PASSIVE 级别上被交付. 所关联的特殊 APC 返回的参数也被传递过来 普通的 (用户模式) 线程退出 (PsExitSpecialApc) 插入在用户模式 APC 列表的头部 如果线程正在执行可被 Alertable 的用户模式等待, 则当返回用户模式时, 在 PASSIVE 级别上被交付, 线程终止特殊 APC 所返回的参数也被传递过来 内核使用 APC 来询问线程环境, 以及终止目标线程. 设备驱动程序在拥有一把锁后, 常常会阻塞 APC, 或者进入一个临界区或守护区域, 以防止这种操作发生; 不然,该锁有可能永远不会被释放, 从而导致系统停住. DPC 中断DPC (延迟过程调用) 中断也用于请求异步执行回调, 但与 APC 中断不同, 因为: 它是一个 “真正的” 中断, 一旦 IRQL 允许, 它可以在任意的线程上下文中执行. 它具有更高的 IRQL, 因此它在 APC 中断之前处理. 内核利用 DPC 来处理定时器到期 (并解除那些正在等待定时器的线程), 以及在一个线程的时限到期以后重新调度处理器.设备驱动程序利用 DPC 来处理中断, 为了给硬件中断提供及时服务, Windows 在设备驱动程序的配合下, 试图将 IRQL 曝出在设备 IRQL 级别之下. 达到这个目的的方法是, 让设备驱动程序 ISR (中断服务例程) 执行最少最必要的工作来响应它们的设备, 将易变的中断状态保存起来, 并将数据传输或者其他并非时间紧迫的中断处理活动延迟到一个位于 DPC 级别的 DPC 中执行. 正在等待执行的 DPC 例程被存储在由内核管理的队列中, 每个处理器都有一个这样的队列 (DPC 队列). DPC 中断产生规则图表 DPC 优先级 DPC 被定为在 ISR 的处理器上 DPC 被定为在另一个处理器上 低级 DPC 队列长度超过了最大 DPC 队列长度值, 或者 DPC 请求率小于最小 DPC 请求率 DPC 队列长度超过了最大 DPC 队列长度值, 或者系统空闲 中级 总是激发 DPC 队列长度超过了最大 DPC 队列长度值, 或者系统空闲 中-高级 总是激发 目标处理器空闲 高级 总是激发 目标处理器空闲 DPC 例程可以调用内核函数, 但是不能调用系统服务, 产生页面错误, 或者创建或等待分发器对象. 编写 DPC 例程规则: 不能访问换页的内存, 不能执行分发等待操作, 也不能对它们将来运行在哪个 IRQL 上做假设.而且, 绝对不能使用 KeAcquire/ReleaseSpinLockAtDpcLevel API, 因为这些 API 函数假设运行在 DPC 级别上. VMM (Virtual Memory Manager) 数据结构VAD (Virtual Address Descriptor)VAD 用于在用户模式范围内跟踪保留和提交的地址 (内核空间并不受 VAD 的管理).VAD 会存储保留或提交的每个地址范围, 以及保护状态和访问权限. VAD 以 AVL 自平衡树的结构组织, 其中每个节点是 VAD 实例, 最多可以有两个子节点.左边的 Children 如果存在, 是一个地址范围小于 parent 节点地址范围的 VAD; 右边的 Children 大于 parent 节点地址范围. VAD 是此树的根, 每一个 nt!_RTL_BALANCED_NODE 中便是一段虚拟内存描述信息. 比如说 0x1000 这一段内存是保留的, 0x2000这一段内存是提交的, 那我们怎么知道它是保留还是提交就体现在这个 nt!_RTL_BALANCED_NODE 上, 也就是每一块虚拟内存 (我说的是一块, 不是一页) 都会一一对应着一个节点 (这个问题很关键, 很关键) 通过调试的数据结构可以看到, nt!_MMVAD 的首字段是 nt!_MMVAD_SHORT, 而 nt!_MMVAD_SHORT 首字段是 nt!_RTL_BALANCED_NODE. 所以, 每个节点实际上就是 nt!_MMVAD 结构 让我们看下相关的数据结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681: kd&gt; dt nt!_RTL_BALANCED_NODE +0x000 Children : [2] Ptr64 _RTL_BALANCED_NODE +0x000 Left : Ptr64 _RTL_BALANCED_NODE +0x008 Right : Ptr64 _RTL_BALANCED_NODE +0x010 Red : Pos 0, 1 Bit +0x010 Balance : Pos 0, 2 Bits +0x010 ParentValue : Uint8B1: kd&gt; dt nt!_MMVAD_SHORT -r +0x000 VadNode : _RTL_BALANCED_NODE +0x000 Children : [2] Ptr64 _RTL_BALANCED_NODE +0x000 Children : [2] Ptr64 _RTL_BALANCED_NODE +0x000 Left : Ptr64 _RTL_BALANCED_NODE +0x008 Right : Ptr64 _RTL_BALANCED_NODE +0x010 Red : Pos 0, 1 Bit +0x010 Balance : Pos 0, 2 Bits +0x010 ParentValue : Uint8B +0x000 Left : Ptr64 _RTL_BALANCED_NODE +0x008 Right : Ptr64 _RTL_BALANCED_NODE +0x010 Red : Pos 0, 1 Bit +0x010 Balance : Pos 0, 2 Bits +0x010 ParentValue : Uint8B +0x000 NextVad : Ptr64 _MMVAD_SHORT +0x018 StartingVpn : Uint4B +0x01c EndingVpn : Uint4B +0x020 StartingVpnHigh : UChar +0x021 EndingVpnHigh : UChar +0x022 CommitChargeHigh : UChar +0x023 LargeImageBias : UChar +0x024 ReferenceCount : Int4B +0x028 PushLock : _EX_PUSH_LOCK +0x000 Locked : Pos 0, 1 Bit +0x000 Waiting : Pos 1, 1 Bit +0x000 Waking : Pos 2, 1 Bit +0x000 MultipleShared : Pos 3, 1 Bit +0x000 Shared : Pos 4, 60 Bits +0x000 Value : Uint8B +0x000 Ptr : Ptr64 Void +0x030 u : &lt;unnamed-tag&gt; +0x000 LongFlags : Uint4B +0x000 VadFlags : _MMVAD_FLAGS +0x000 VadType : Pos 0, 3 Bits +0x000 Protection : Pos 3, 5 Bits +0x000 PreferredNode : Pos 8, 6 Bits +0x000 NoChange : Pos 14, 1 Bit +0x000 PrivateMemory : Pos 15, 1 Bit +0x000 Teb : Pos 16, 1 Bit +0x000 PrivateFixup : Pos 17, 1 Bit +0x000 Spare : Pos 18, 13 Bits +0x000 DeleteInProgress : Pos 31, 1 Bit +0x034 u1 : &lt;unnamed-tag&gt; +0x000 LongFlags1 : Uint4B +0x000 VadFlags1 : _MMVAD_FLAGS1 +0x000 CommitCharge : Pos 0, 31 Bits +0x000 MemCommit : Pos 31, 1 Bit +0x038 EventList : Ptr64 _MI_VAD_EVENT_BLOCK +0x000 Next : Ptr64 _MI_VAD_EVENT_BLOCK +0x008 WaitReason : Uint4B +0x010 Gate : _KGATE +0x000 Header : _DISPATCHER_HEADER +0x010 SecureInfo : _MMADDRESS_LIST +0x000 u1 : &lt;unnamed-tag&gt; +0x008 EndVa : Ptr64 Void +0x010 BitMap : _RTL_BITMAP_EX +0x000 SizeOfBitMap : Uint8B +0x008 Buffer : Ptr64 Uint8B +0x010 InPageSupport : Ptr64 _MMINPAGE_SUPPORT +0x000 ListEntry : _LIST_ENTRY +0x010 ListHead : _LIST_ENTRY +0x020 Event : _KEVENT +0x038 CollidedEvent : _KEVENT +0x050 IoStatus : _IO_STATUS_BLOCK +0x060 ReadOffset : _LARGE_INTEGER +0x068 PteContents : _MMPTE +0x070 Thread : Ptr64 _ETHREAD +0x078 LockedProtoPfn : Ptr64 _MMPFN +0x080 WaitCount : Int4B +0x084 ByteCount : Uint4B +0x088 u3 : &lt;unnamed-tag&gt; +0x08c u1 : &lt;unnamed-tag&gt; +0x090 FilePointer : Ptr64 _FILE_OBJECT +0x098 ControlArea : Ptr64 _CONTROL_AREA +0x0a0 Autoboost : Ptr64 Void +0x0a8 FaultingAddress : Ptr64 Void +0x0b0 PointerPte : Ptr64 _MMPTE +0x0b8 BasePte : Ptr64 _MMPTE +0x0c0 Pfn : Ptr64 _MMPFN +0x0c8 PrefetchMdl : Ptr64 _MDL +0x0d0 Mdl : _MDL +0x100 Page : [16] Uint8B +0x010 PhysicalMemory : _MI_PHYSMEM_BLOCK +0x000 IoTracker : Ptr64 _MMIO_TRACKER +0x010 LargePage : Ptr64 _MI_LARGEPAGE_MEMORY_INFO +0x000 ListHead : _LIST_ENTRY +0x010 ColoredPageInfoBase : Ptr64 _COLORED_PAGE_INFO +0x018 PagesNeedZeroing : Uint4B1: kd&gt; dt nt!_MMVAD -r +0x000 Core : _MMVAD_SHORT +0x040 u2 : &lt;unnamed-tag&gt; +0x000 LongFlags2 : Uint4B +0x000 VadFlags2 : _MMVAD_FLAGS2 +0x000 FileOffset : Pos 0, 24 Bits +0x000 Large : Pos 24, 1 Bit +0x000 TrimBehind : Pos 25, 1 Bit +0x000 Inherit : Pos 26, 1 Bit +0x000 CopyOnWrite : Pos 27, 1 Bit +0x000 NoValidationNeeded : Pos 28, 1 Bit +0x000 Spare : Pos 29, 3 Bits +0x048 Subsection : Ptr64 _SUBSECTION +0x000 ControlArea : Ptr64 _CONTROL_AREA +0x000 Segment : Ptr64 _SEGMENT +0x008 ListHead : _LIST_ENTRY +0x018 NumberOfSectionReferences : Uint8B +0x020 NumberOfPfnReferences : Uint8B +0x028 NumberOfMappedViews : Uint8B +0x030 NumberOfUserReferences : Uint8B +0x038 u : &lt;unnamed-tag&gt; +0x040 FilePointer : _EX_FAST_REF +0x048 ControlAreaLock : Int4B +0x04c ModifiedWriteCount : Uint4B +0x050 WaitList : Ptr64 _MI_CONTROL_AREA_WAIT_BLOCK +0x058 u2 : &lt;unnamed-tag&gt; +0x068 LockedPages : Uint8B +0x070 FileObjectLock : _EX_PUSH_LOCK +0x008 SubsectionBase : Ptr64 _MMPTE +0x000 u : &lt;unnamed-tag&gt; +0x010 NextSubsection : Ptr64 _SUBSECTION +0x000 ControlArea : Ptr64 _CONTROL_AREA +0x008 SubsectionBase : Ptr64 _MMPTE +0x010 NextSubsection : Ptr64 _SUBSECTION +0x018 PtesInSubsection : Uint4B +0x020 UnusedPtes : Uint4B +0x020 GlobalPerSessionHead : _RTL_AVL_TREE +0x028 u : &lt;unnamed-tag&gt; +0x02c StartingSector : Uint4B +0x030 NumberOfFullSectors : Uint4B +0x018 PtesInSubsection : Uint4B +0x020 UnusedPtes : Uint4B +0x020 GlobalPerSessionHead : _RTL_AVL_TREE +0x000 Root : Ptr64 _RTL_BALANCED_NODE +0x028 u : &lt;unnamed-tag&gt; +0x000 LongFlags : Uint4B +0x000 SubsectionFlags : _MMSUBSECTION_FLAGS +0x02c StartingSector : Uint4B +0x030 NumberOfFullSectors : Uint4B +0x050 FirstPrototypePte : Ptr64 _MMPTE +0x000 u : &lt;unnamed-tag&gt; +0x000 Long : Uint8B +0x000 VolatileLong : Uint8B +0x000 Hard : _MMPTE_HARDWARE +0x000 Flush : _HARDWARE_PTE +0x000 Proto : _MMPTE_PROTOTYPE +0x000 Soft : _MMPTE_SOFTWARE +0x000 TimeStamp : _MMPTE_TIMESTAMP +0x000 Trans : _MMPTE_TRANSITION +0x000 Subsect : _MMPTE_SUBSECTION +0x000 List : _MMPTE_LIST +0x058 LastContiguousPte : Ptr64 _MMPTE +0x060 ViewLinks : _LIST_ENTRY +0x070 VadsProcess : Ptr64 _EPROCESS +0x078 u4 : &lt;unnamed-tag&gt; +0x000 SequentialVa : _MI_VAD_SEQUENTIAL_INFO +0x000 Length : Pos 0, 12 Bits +0x000 Vpn : Pos 12, 52 Bits +0x000 ExtendedInfo : Ptr64 _MMEXTEND_INFO +0x000 CommittedSize : Uint8B +0x008 ReferenceCount : Uint4B 可以在 Windbg 使用 !vad 命令来显示 VAD 所有内容: 1234567891011121314151617181920212223242526272829303132333435363738391: kd&gt; !process 0 1 explorer.exePROCESS ffffe000080b5900 SessionId: 1 Cid: 05c0 Peb: 7ff6baea6000 ParentCid: 05b0 DirBase: 2693f000 ObjectTable: ffffc00001b4b240 HandleCount: &lt;Data Not Accessible&gt; Image: explorer.exe-&gt; VadRoot ffffe0000a4fa3d0 Vads 487 Clone 0 Private 21876. Modified 2328. Locked 4293. DeviceMap ffffc00001809d90 Token ffffc00001b5e060 ElapsedTime 00:03:05.489 UserTime 00:00:00.562 KernelTime 00:00:01.171 QuotaPoolUsage[PagedPool] 1164104 QuotaPoolUsage[NonPagedPool] 65696 Working Set Sizes (now,min,max) (45742, 50, 345) (182968KB, 200KB, 1380KB) PeakWorkingSetSize 47348 VirtualSize 502 Mb PeakVirtualSize 532 Mb PageFaultCount 61975 MemoryPriority FOREGROUND BasePriority 8 CommitCharge 257531: kd&gt; !vad 0xffffe0000a4fa3d0 VAD Level Start End Commitffffe00008100830 7 de0 def 0 Mapped READWRITE Pagefile section, shared commit 0x10ffffe000080f5bd0 8 df0 dfc 2 Private READWRITE ffffe00008093c50 6 e00 e0e 0 Mapped READONLY Pagefile section, shared commit 0xfffffe0000810a500 8 e10 e8f 13 Private READWRITE ffffe000080b4e40 7 e90 e93 0 Mapped READONLY Pagefile section, shared commit 0x4ffffe00008093a70 8 ea0 ea2 0 Mapped READONLY Pagefile section, shared commit 0x3ffffe000080e62f0 5 eb0 eb1 2 Private READWRITE ffffe000080f2d10 7 ec0 f3d 0 Mapped READONLY \Windows\System32\locale.nls...ffffe000078a8d60 9 7ffc64010 7ffc64079 2 Mapped Exe EXECUTE_WRITECOPY \Windows\System32\ws2_32.dllffffe000080f0200 8 7ffc64080 7ffc64234 10 Mapped Exe EXECUTE_WRITECOPY \Windows\System32\ntdll.dllTotal VADs: 487, average level: 8, maximum depth: 10Total private commit: 0x635e pages (101752 KB)Total shared commit: 0x12e9 pages (19364 KB) 实际上, VadRoot 的地址存在于 _EPROCESS-&gt;VadRoot-&gt;Root 中的 !vad 输出各项含义: VAD, _MMVAD 数据结构的地址 Level, 树的深度 Start/End, 表示为虚拟页号(VPN, Virtual Page Number), 即地址除以页面大小 (4KB) 的值.例如第一行定义从 0xde0000 开始, 以 0xdeffff 结束, 注意结束地址是最后一页的 VPN, 所以最后一个字节的地址是 0x1F000 + 0xFFF Commit, 范围内已提交的页面数, 我们可以选择保留一个范围, 然后只提交其中一部分. 分配类型. 页面上允许的访问类型. 当 PML4E 当前位清零时, 对应的 VA 范围不存在 PDPT, PD 或 PT. 没有存储该范围的 PDPT 的物理页面, 没有存储 PD 的页面等.同样, PML4E 可以指向现有的 PDPT, 但是 PDPTE 可以使当前位清零, 因此对于该特定范围不存在 PD 或 PT. 对于 _MMVAD_SHORT.u.VadFlags.MemCommit = 1, VMM必须在PTE内部记录其已被分解的信息, 因为VAD标志将范围标记为完全提交. 对于这样的范围, 将VAD标志设置为1, 并且按照说明设置分解的PTE. 对于 _MMVAD_SHORT.u.VadFlags.MemCommit = 0 的范围, VMM可以设想将PTE设置为0: 范围不会在VAD中标记为已提交, 因此PTE设置为0表示未提交的页面. 然而, 实际发生的情况是, PTE设置为 0x00000000&#39;00000200. 下面还未完成… (内容太多…)]]></content>
      <categories>
        <category>Windows kernel learning</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install ArchLinux to WSL]]></title>
    <url>%2FStaticBlog%2F2017%2FInstall-ArchLinux-to-WSL%2F</url>
    <content type="text"><![CDATA[系统: Windows 10 1703 工具准备首先下载 alwsl, alwsl 是一个已经做好 arch-rootfs 的开源项目, 通过作者提供的 alwsl.bat 可以很容易的安装 ArchLinux 到 WSL. 在 Update Apr 2017 的版本, 有一个小问题: archlinux.ico 的下载连接失效. 所以我们要小小修改一下 alwsl.bat. 你可以选一个自己喜欢的 ico 放到 alwsl.bat 的目录. 我是在 archlinux.ico 下载的. 打开 alwsl.bat, 替换一条命令 12345bitsadmin /RAWRETURN /transfer alwsl /download /priority FOREGROUND "https://antiquant.com/alwsl/archlinux.ico" "%localappdata%\lxss\archlinux.ico":: 替换为copy /V "archlinux.ico" "%localappdata%\lxss\archlinux.ico" 安装首先你要打开开发者模式并且在 “启用或关闭 Windows 功能” 中勾选 Linux 子系统 然后执行下面命令 12&gt; cd XXXX/alwsl/&gt; alwsl.bat install 然后进入 WSL, 要修正一下证书问题, 以及根据自己需要调整自己的源 (换国内源速度会快很多) 1234pacman -Syuwrm /etc/ssl/certs/ca-certificates.crtupdate-ca-trustpacman -Su 创建快照alwsl 有一个我非常喜欢的功能, 就是可以创建 WSL 的快照. 这样我就再也不用担心被我搞脏 WSL 了. 个人建议在 WSL 配置前拍摄一个快照, 在 WSL 配置完成后拍摄一个快照, 最后可以根据需要选择是否删除第一次拍着的快照. 1&gt; alwsl.bat snapshot create 恢复和删除快照等参数, 自己运行下 alwsl 看一下最好. 配置过程中遇到的问题安装完之后, 你就可以像刚刚安装完 ArchLinux 那样开始各种配置 (比如添加用户, 配置 Shell), 我在这里说一下我在配置 ArchLinux 过程中遇到的一些问题. pacman问题 12root@MeeSong-PC:~# pacman -Syupacman: error while loading shared libraries: libcrypto.so.1.0.0: cannot open shared object file: No such file or directory 解决方案 1ln -s /usr/lib/libcrypto.so /usr/lib/libcrypto.so.1.0.0 locale-gen问题 123456789root@MeeSong-PC:~# cat /etc/locale.genen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8root@MeeSong-PC:~# locale-genGenerating locales... en_US.UTF-8...localedef: ../sysdeps/unix/sysv/linux/spawni.c:360: __spawnix: Assertion `ec &gt;= 0' failed./usr/sbin/locale-gen: line 41: 2361 Aborted (core dumped) localedef -i $input -c -f $charset -A /usr/share/locale/locale.alias $locale 解决方案 123root@MeeSong-PC:~# cd /usr/share/i18n/charmaps/root@MeeSong-PC:/usr/share/i18n/charmaps# gzip -dk UTF-8.gzroot@MeeSong-PC:/usr/share/i18n/charmaps# locale-gen ca-certificates.crt问题 12345curl: (77) error setting certificate verify locations: CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs/# git 有同样的问题 解决方案 12# 重新安装一次...pacman -S ca-certificates-utils shell我个人喜欢用zsh作为shell, 但是在 WSL 中更改默认shell用 chsh 是无效的..所以, 我们要改一下 .bashrc 让它来调用 zsh 123456# 在 ~/.bashrc 开头添加下面命令# Launch Zshif [ -t 1 ]; thenexec zshfi]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCDEdit 命令行选项帮助]]></title>
    <url>%2FStaticBlog%2F2017%2FDebug%2FBCDEdit-option%2F</url>
    <content type="text"><![CDATA[/? ID查看所有已知标识符 bcdedit /? ID /? types &lt;apptype&gt;查看所有数据类型附加信息 apptype 可以是以下其中一项: apptype description bootapp 启动应用程序.这些类型也应用于启动管理器, 内存诊断应用程序, Windows OS 加载器和回复应用程序 bootmgr 启动管理器 bootsector 启动扇区应用程序 customtypes 自定义类型 devobject 设备对象附加选项 fwbootmgr 固件启动管理器 memdiag 内存诊断应用程序 ntldr Vista 之前版本附带的 OS 加载器 osloader Vista OS 加载器 resume 恢复应用程序 /enum列出存储中的项 bcdedit [/store &lt;filename&gt;] /enum [&lt;type&gt; | &lt;id&gt;] [/v] type 指定要列出的项的类型. 可以是以下类型之一: Active : 启动管理器显示顺序中的所有项, 这是默认值. Firmware: 所有固件应用程序. Bootapp : 所有启动环境应用程序. Bootmgr : 启动管理器. Osloader: 所有操作系统项. Resume : 所有从休眠状态恢复项. Inherit : 所有继承项. All : 所有项. /v 完整显示标识符,而不是使用已知标识符名称 /store用于指定当前系统默认值以外的 BCD 存储. bcdedit /store &lt;filename&gt; 此命令行选项可与大多数 Bcdedit 命令一起使用以指定要使用的存储.如果未指定此选项, 则使用系统存储. 此选项不能与 /createstore, /import 和 /export 命令一起使用. /createstore新建空的启动配置数据存储, 创建的存储不是系统存储. bcdedit /createstore &lt;filename&gt; /export此命令将系统存储的内容导出到文件.以后可以使用此文件还原系统存储的状态. 此命令仅对系统存储有效. bcdedit /export &lt;filename&gt; /import此命令使用以前使用 /export 命令生成的备份数据文件. bcdedit /import &lt;filename&gt; [/clean] 还原系统存储的状态.在进行导入前, 将删除系统存储中的所有现有项. 此命令仅对系统存储有效 /clean 仅影响 EFI 系统. /sysstore此命令用于设置系统存储设备.对于 EFI 系统, 仅在系统存储设备不确定的情况下, 此命令才有效. 此设置在重新启动后不再有效. bcdedit /sysstore &lt;devicename&gt; devicename 为系统分区盘符 /copy创建指定启动项的副本. bcdedit [/store &lt;filename&gt;] /copy {&lt;id&gt;} /d &lt;description&gt; /create在启动配置数据存储中创建新项.如果指定了已知的标识符, 则不能指定 /application, /inherit 和 /device 选项.如果未指定 id, 或者 id 未知, 则必须指定 /application, /inherit 或 /device 选项. bcdedit /create [{&lt;id&gt;}] [/d &lt;description&gt;] [/application &lt;apptype&gt; | /inherit [&lt;apptype&gt;] | /inherit DEVICE | /device] /delete删除启动配置数据存储中的项. bcdedit [/store &lt;filename&gt;] /delete &lt;id&gt; [/f] [/cleanup | /nocleanup] /f 删除指定的项. 如果没有此项,则将无法删除任何具有已知标识符的项. /cleanup 删除指定的项, 并从显示顺序中删除该项. 并将从存储中删除任何其他涉及到所删除的项目. /nocleanup 删除指定的项,但不从显示顺序中删除该项. /mirror创建指定启动项的镜像. bcdedit [/store &lt;filename&gt;] /mirror {&lt;id&gt;} /bootsequence设置启动管理器使用的一次性启动序列. bcdedit /bootsequence &lt;id&gt; [...] [ /addfirst | /addlast | /remove ] /addfirst 将指定的项标识符添加到启动序列的顶部.如果已指定此参数, 则只能指定一个项标识符.如果列表中已存在该标识符, 则将其移动到列表顶部. /addlast 将指定的项标识符添加到启动序列的尾部.如果已指定此参数, 则只能指定一个项标识符.如果列表中已存在该标识符, 则将其移动到列表尾部. /remove 从启动序列中删除指定的项标识符.如果已指定此参数, 则只能指定一个项标识. 如果该标识符不在列表中, 则该操作不起作用.如果删除最后一项, 则启动序列值将会从启动管理器项中删除. /default设置启动管理器将使用的默认项 bcdedit /default &lt;id&gt; /displayorder设置启动管理器显示, 多重启动菜单的顺序 bcdedit /displayorder &lt;id&gt; [...] [ /addfirst | /addlast | /remove ] 参数含义同 /bootsequence /timeout设置启动管理器的超时值, 单位 秒 bcdedit /timeout &lt;timeout&gt; /toolsdisplayorder设置启动管理器显示工具菜单的顺序 bcdedit /toolsdisplayorder &lt;id&gt; [...] [ /addfirst | /addlast | /remove ] 参数含义同 /bootsequence /bootdebug开启当前或指定的系统引导调试 bcdedit /bootdebug [{GUID}] { on | off } 注: 使用 /dbgsettings 选项配置要使用的调试连接类型和连接参数.如果没有指定, 则使用默认全局调试设置. /dbgsettings指定或显示系统的全局调试程序设置. 此命令不启用或禁用内核调试程序；使用 /debug 选项完成此目的. 若要设置单个全局调试程序设置, 请使用 bcdedit /setdbgsettings type value 命令. 1234bcdedit /dbgsettings SERIAL [DEBUGPORT:port] [BAUDRATE:baud] [/start startpolicy] [/noumex] bcdedit /dbgsettings 1394 [CHANNEL:channel] [/start startpolicy] [/noumex] bcdedit /dbgsettings USB [TARGETNAME:targetname] [/start startpolicy] [/noumex] bcdedit /dbgsettings NET HOSTIP:ip PORT:port [KEY:key] [nodhcp] [newkey] [/start startpolicy] [/noumex] /start startpolicy 此选项指定了调试器启动策略, 下面显示了策略选项:Option | Description:———–|:———–ACTIVE | 指定内核调试器处于活动状态AUTOENABLE | 指定当异常或者其他严重事件发生时, 内核调试器将自动启用. 在此之前, 内核调试器处于活动状态, 但已被禁用DISABLE | 指定当您键入kdbgctrl以清除启用块时启用内核调试器. 在此之前, 调试器处于活动状态, 但已被禁用 /noumex 指定内核调试器忽略用户模式异常,默认情况下, 某些用户模式异常会中断内核调试器, 例如 STATUS_BREAKPOINT 和 STATUS_SINGLE_STEP. 只有当没有用户模式调试器附加到进程时, 该参数才有效 SerialSetting Up Kernel-Mode Debugging over a Serial Cable Manually.aspx) 1394 Setting Up Kernel-Mode Debugging over a 1394 Cable Manually.aspx) USBSetting Up Kernel-Mode Debugging over a USB 2.0 Cable Manually.aspx) Setting Up Kernel-Mode Debugging over a USB 3.0 Cable Manually.aspx) NetSetting Up Kernel-Mode Debugging over a Network Cable Manually.aspx) Supported Ethernet NICs for Network Kernel Debugging in Windows 8.1.aspx) Supported Ethernet NICs for Network Kernel Debugging in Windows 8.aspx) LocalSetting Up Local Kernel Debugging of a Single Computer Manually.aspx) 默认全局调试设置 dbgsetting parameter Default value Debugtype Serial Debugport 1 Baudrate 115200 /debug启用或禁用指定启动项的内核调试程序。 bcdedit /debug [{ID}] { on | off } 注: 使用 /dbgsettings 选项配置要使用的调试连接类型和连接参数.如果没有指定, 则使用默认全局调试设置. /hypervisorsettings设置虚拟机监控程序的参数 若要为特定的操作系统加载器项启用或禁用虚拟机监控程序调试程序, 请使用 bcdedit /set &lt;id&gt; hypervisordebug on bcdedit /hypervisorsettings [ &lt;debugtype&gt; [DEBUGPORT:&lt;port&gt;] [BAUDRATE:&lt;baud&gt;] [CHANNEL:&lt;channel&gt;] [HOSTIP:&lt;ip&gt;] [PORT:&lt;port&gt;] ] debugtype 指定调试程序的类型. 可以是 Serial, 1394, Net 之一 port 对于 Serial 调试, 指定要用作调试端口的串口 baud 对于 Serial 调试, 指定用于调试的波特率 channel 对于 1394 调试, 指定用于调试的 1394 通道 ip 对于 Net 调试, 指定主机调试程序的 IPV4 地址 port 对于 Net 调试, 指定在主机调试程序上通信的端口,应该是 49152 或更高 /event启用或禁用操作系统项的远程事件日志记录 bcdedit /event [&lt;id&gt;] { ON | OFF } 标识符只能指定 Windows 启动加载程序项.如果未指定,则使用 {current} /deletevalue删除启动项中指定的元素。 bcdedit /deletevalue [{ID}] datatype /bootems启用或禁用引导项的紧急管理服务 bcdedit /bootems [&lt;id&gt;] { ON | OFF } /ems启用或禁用指定的操作系统启动项的紧急管理服务 (EMS). bcdedit /ems [{ID}] { on | off } /emsstings设置计算机的全局 EMS 设置. /emssettings 不启用或禁用任何特定启动项的 EMS. bcdedit /emssettings [ BIOS ] | [ EMSPORT: port | [EMSBAUDRATE: baudrate] ] /set设置一个项选项值. bcdedit /set [{ID}] datatype value datatype 有以下几种类型: bootlog [yes | no] bootmenupolicy [ Legacy | Standard ] bootstatuspolicy policy bootux [ disabled | basic | standard ] disabledynamictick [ yes | no ] disableelamdrivers [ yes | no ] forcelegacyplatform [ yes | no ] groupsize maxsize groupaware [ on | off ] hal file hypervisorbusparams Bus.Device.Function hypervisordebug [ On | Off ] hypervisordebugport port hypervisordebugtype [ Serial | 1394 | Net ] hypervisorbaudrate [ 9600 | 19200 | 38400 | 57600 | 115200 ] hypervisorchannel [ channel ] hypervisorhostip IP hypervisorhostport [ port ] hypervisordhcp [ yes | no ] hypervisoriommupolicy [ default | enable | disable] hypervisorlaunchtype [ Off | Auto ] hypervisorloadoptions NOFORCESNOOP [ Yes | No ] hypervisornumproc number hypervisorrootproc number hypervisorrootprocpernode number hypervisorusekey [ key ] hypervisoruselargevtlb [ yes | no ] increaseuserva Megabytes kernel file loadoptions busparams=Bus.Device.Function maxgroup [ on | off ] nointegritychecks [ on | off ] nolowmem [ on | off ] novesa [ on | off ] novga [ on | off ] nx [Optin |OptOut | AlwaysOn |AlwaysOff] onecpu [ on | off ] onetimeadvancedoptions [ on | off ] pae [ Default | ForceEnable | ForceDisable ] pciexpress [ default | forcedisable] quietboot [ on | off ] removememory Megabytes sos [ on | off ] testsigning [ on | off ] tpmbootentropy [ default | ForceEnable | ForceDisable] truncatememory address tscsyncpolicy [ Default | Legacy | Enhanced ] usefirmwarepcisettings [ yes | no ] useplatformclock [ yes | no ] uselegacyapicmode [ yes | no ] useplatformtick [ yes | no ] vga [ on | off ] xsavedisable [ 0 | 1 ] x2apicpolicy [ enable | disable ] Boot.in 选项和 BCDEdit 选项的映射关系 Boot.ini BCDEdit option BCD element type /3GB increaseuserva BcdOSLoaderInteger_IncreaseUserVa /BASEVIDEO vga BcdOSLoaderBoolean_UseVgaDriver /BOOTLOG bootlog BcdOSLoaderBoolean_BootLogInitialization /BREAK halbreakpoint BcdOSLoaderBoolean_DebuggerHalBreakpoint /CRASHDEBUG /dbgsettings /start /DEBUG, BOOTDEBUG /debug /bootdebug BcdLibraryBoolean_DebuggerEnabled /DEBUG /debug BcdOSLoaderBoolean_KernelDebuggerEnabled /DEBUG, /DEBUGPORT= /dbgsettings BcdLibraryInteger_DebuggerType /DEBUGPORT= /dbgsettings BcdLibraryInteger_SerialDebuggerPort BcdLibraryInteger_SerialDebuggerBaudRate BcdLibraryInteger_1394DebuggerChannel BcdLibraryString_UsbDebuggerTargetName BcdLibraryInteger_DebuggerNetHostIP BcdLibraryInteger_DebuggerNetPort BcdLibraryBoolean_DebuggerNetDhcp BcdLibraryString_DebuggerNetKey /EXECUTE nx BcdOSLoaderInteger_NxPolicy /FASTDETECT /HAL= hal BcdOSLoaderString_HalPath /KERNEL= kernel BcdOSLoaderString_KernelPath /MAXMEM= truncatememory BcdLibraryInteger_TruncatePhysicalMemory /NODEBUG /debug /NOEXECUTE nx { BcdOSLoaderInteger_NxPolicy /NOGUIBOOT quietboot BcdOSLoaderBoolean_DisableBootDisplay /NOLOWMEM nolowmem BcdOSLoaderBoolean_NoLowMemory /NOPAE pae BcdOSLoaderInteger_PAEPolicy /ONECPU onecpu BcdOSLoaderBoolean_UseBootProcessorOnly /PAE pae BcdOSLoaderInteger_PAEPolicy /PCILOCK usefirmwarepcisettings BcdOSLoaderInteger_UseFirmwarePciSettings /REDIRECT /ems /emssettings [ BIOS ] or [ EMSPORT:{port} [EMSBAUDRATE: {baudrate}] ] BcdOSLoaderBoolean_EmsEnabled /SOS sos]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA + VMWare 调试 Windows 内核]]></title>
    <url>%2FStaticBlog%2F2017%2FDebug%2FIDA-VMWare-debug-Windows-kernel%2F</url>
    <content type="text"><![CDATA[打开虚拟机 vmx 文件, 增加下面内容 12345debugStub.listen.guest32.remote = "TRUE" // 默认端口 8832debugStub.listen.guest64.remote = "TRUE" // 默认端口 8864monitor.debugOnStartGuest32 = "TRUE" // 在第一条指令 (在BIOS! 中警告) 中断进入调试存根, 这将在第一条指令在0xFFFF0处停止VM, 您可以设置下一个断点来破坏* 0x7c00引导加载程序由BIOS加载debugStub.hideBreakpoints = "TRUE" // 启用使用硬件断点而不是软件（INT3）断点bios.bootDelay = "3000" // 延迟启动BIOS代码 IDA -&gt; Debugger -&gt; Attach -&gt; Remote GDB debugger hostname 填 localhost, port 填上面给出的默认端口 Alt + S, 设置内存布局 (0 ~ 0xFFFFFFF0 or x64: 0xFFFFFFFFFFFFFFF0) 如果是要调试 BIOS 代码, 那么应创建一个从 0xF0000 到 0x10000 的 16 位段]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 调试环境搭建]]></title>
    <url>%2FStaticBlog%2F2017%2FDebug%2FWindows-debug-env%2F</url>
    <content type="text"><![CDATA[在 Vista 之前, NTLDR 是 Windows 操作系统的加载程序, 它负责将 CPU 从实模式切换为保护模式, 加载内核文件和启动类型的驱动程序, 然后把执行权交给内核文件的入口函数, 即 KiSystemStartup. 从要完成的任务角度来看, NTLDR 内部又分为两个部分, 一部分负责接受执行权, 做模式切换, 硬件检查, 即启动的准备工作, 这部分通常称为 boot; 另一部分负责加载内核文件, 并为内核的运行做必要的准备, 通常称为 OsLoader. Vista 将以上两个部分分成两个独立的程序文件, 即 BootMgr 和 WinLoad.exe 与调试 NTLDR 需要替换 Checked 版本的 NTLDR 不同, 在 BootMgr 和 WinLoad 内部都已经内建了调试引擎, 这与内核的做法是一致的. 在 Vista 之后的版本可调试部分有 4 个：bootmgr 模块、winload 模块、WinResume 模块以及 windows 内核模块 ntoskerl 模块. 可以同时启用这几个调试引擎, 也可以根据需要启用其中的某一个. 前三个调试引擎是根据位于内核中的内核调试引擎 (KD) 克隆出来的，它们使用与 KD 兼容的协议, 对调试器 (WinDBG) 来说, 它并不区分对方是真正的 KD 还是 KD 的克隆. 因此在 BootMgr 中断调试会话时, WinDBG提示的信息和内核退出时的信息一样的. 下面是通过 bcdedit 开启各项调试引擎的方法, 以串口为栗子 1234567891011121314151617# 1. 开启 bootmgr 调试bcdedit /set &#123;bootmgr&#125; bootdebug onbcdedit /set &#123;bootmgr&#125; debugtype serialbcdedit /set &#123;bootmgr&#125; debugport 1bcdedit /set &#123;bootmgr&#125; baudrate 115200# 2. 开启 WinLoad 调试# 具体的 GUID 可以通过 bcdedit /enum osloader 来查看bcdedit /set &#123;GUID&#125; bootdebug on# 3. 开启 ntoskrnl 调试# 具体的 GUID 与 WinLoad 相同bcdedit /set &#123;GUID&#125; debug on# 4. 开启 WinResume 调试# 具体的 GUID 可以通过 bcdedit /enum resume 来查看bcdedit /set &#123;GUID&#125; bootdebug on 另外, 在注册表中设置 DbgPrint 的默认日志过滤等级, 才能打印被过滤掉的日志 1234Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug PrintFilter] "DEFAULT"=dword:0000000f]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows kernel learning: 2. System Call]]></title>
    <url>%2FStaticBlog%2F2017%2FWindows-kernel-learning%2FWindows-kernel-learning-2-System-Call%2F</url>
    <content type="text"><![CDATA[CPU 既可以运行于非特权的”用户空间”, 也可以运行于特权的”系统空间”. CPU 要从系统空间转入用户空间是容易的, 因为运行于系统空间的CPU可以通过一些特权指令改变其运行状态. 但是从用户空间转入系统空间就不容易了, 因为运行于用户空间的 CPU 是不能执行特权指令的. 一般而言,只有下面几种手段可以从用户空间转入系统空间: 中断 (Interrupt): 在开启了中断的情况下,只要有中断请求到来, CPU 就会自动转入系统空间, 并指定对应的中断例程, 从而为中断请求提供服务. 中断发生在两条指令之间, 所以不会使正在执行的指令半途而废, 中断是无法预知且异步的. 异常 (Exception): 异常和中断极其相似, 只是一行发生在执行一条指令的过程中, 而不是两条指令之间. 实践中, 可以通过故意引起异常而进入内核. 自陷 (Trap): 为了让 CPU 能主动地进入系统空间, 绝大多数 CPU 都设有专门的 “自陷” 指令, 系统调用通常都是通过自陷指令实现的. 自陷指令在形式上也与中断相似,就像是 CPU 主动发出的中断请求. 快速系统调用 (fast call): 可以说是对自陷机制的改进. 这篇笔记主要就是写自陷和快速系统调用机制. 系统调用机制概述自陷指令 int 2eh在 Pentium Ⅱ 之前的 x86 处理器上, Windows 使用 int 2eh 自陷指令进入内核实现系统调用. Windows 填充 IDT 的46 号表项, 使其指向系统服务分发器. 使用 EAX 寄存器传递系统服务号, EDX 寄存器指向调用者传递给系统服务的参数列表. sysenter/sysexit在之后, Windows 使用专门的 sysenter 指令, 这是 Intel 特别为快速系统分发而定义的指令, 与此配套, CPU 中增加了三个 MSR (Machine Specific Register) 寄存器: SYSENTER_CS_MSR, SYSENTER_EIP_MSR, SYSENTER_ESP_MSR. 这些寄存器可以通过 wrmsr 指令来设置, 执行 wrmsr 指令时, 通过寄存器 edx, eax 指定设置的值, edx 指定值的高 32 位, eax 指定值的低 32 位, 在设置上述寄存器时, edx 都是 0, 通过寄存器 ecx 指定填充的 MSR 寄存器, SYSENTER_CS_MSR, SYSENTER_ESP_MSR, SYSENTER_EIP_MSR 寄存器分别对应 0x174, 0x175, 0x176, 需要注意的是, wrmsr/rdmsr 指令只能在 Ring 0 执行. 与自陷指令一样, sysenter 使用 EAX 寄存器传递系统服务号, EDX 寄存器指向调用者传递给系统服务的参数列表. syscall/sysret在之后的 x64 体系架构上, Windows 使用 syscall 指令进行系统调用,将系统调用号通过EAX寄存器来传递, 前四个参数放在寄存器中传递, 剩下的参数都被放入栈中. 为了支持 syscall/sysret, AMD 新增了4个 MSR 寄存器: STAR LSTAR CSTAR SFMASK 通过上图我们已经明白了 STAR 寄存器的用途： 在 legacy x86 下提供 eip 值（仅在 egacy x86 模式下）为 syscall 指令提供目标代码的 CS 和 SS selector为 sysret 指令提供返回代码的 CS 和 SS selector 因此, STAR 寄存器分为三部分： [31:00] - SYSCALL_EIP - legacy 模式的 EIP [47:32] - SYSCALL_CS [63:48] - SYSRET_CS SYSRET_CS：32-bit code segment descriptor selector (包括 legacy x86 的 16-bit 代码) SYSRET_CS+8：stack segment descriptor selector SYSRET_CS+16：64-bit code segment descriptor selector SFMASK 寄存器中的值为1的位,就会在 EFLAGS 寄存器中置零. 在 Intel 下 STSR 被称作 IA32_STAR, LSTAR 被称作 IA32_LSTAR, SFMASK 被称作 IA32_SFMASK, 虽然是冠以 IA32 体系, 但是请相信它们是 64 位的. 除前面所说的只能在 64 位环境执行, 其它方面完全是兼容 AMD 的. 在 Windows 中, LSTAR 实际指向 KiSystemCall64, CSTAR 指向 KiSystemCall32. 对于 sysenter 和 syscall 的关系: 在 AMD 与 Intel 的 processor 上还是有区别的: 在 AMD 的 processor 上: syscall/sysret 指令在 long mode 和 protected mode ( 指的是 Legacy x86 和 compatibility mode ) 上都是有效的 ( valid ). 在 Intel processor 上: syscall/sysret 指令只能在 64-bit 模式上使用, compatibility 模式和 Legacy x86 模式上都是无效的. 可是 sysret 指令虽然不能在 compatibility 模式下执行, 但 sysret 却可以返回到 compaitibility 模式. 这一点只能是认为了兼容 AMD 的 sysret 指令. 怎么办, 这会不会出现兼容上的问题? 这里有一个折衷的处理办法: 在 64 位环境里统一使用 syscall/sysret 指令, 在 32 位环境里统一使用 sysenter/sysexit 指令 然而依旧会产生一些令人不愉快的顾虑, 没错, 在 compatibility 模式下谁都不兼容谁: Intel 的 syscall/sysret 指令不能在 compatibility 模式下执行; AMD 的 sysenter/sysexit 指令也不能在 compatibility 模式下执行. 因此: 在 compatibility 模式下必须切换到 64 位模式, 然后使用 syscall/sysret 指令 详见: mik-使用 syscall/sysret 指令 系统调用机制的切换过程int 2eh 指令CPU 的运行状态从用户态切换成内核态. 从任务状态段 TSS 中装入本线程的内核栈寄存器 SS 和 ESP, 再保存现场, 依次 PUSH SS, ESP, EFLAGS, CS, EIP, 然后执行 IDT[0x2e] 中的系统服务分发器开始执行内核中的程序. 最后系统调用返回则通过中断返回指令 iret 实现上述的逆过程. sysenter/sysexit 指令在 Ring3 的代码调用了 sysenter 指令之后, CPU 会做出如下的操作： 将 SYSENTER_CS_MSR 的值装载到 cs 寄存器 将 SYSENTER_EIP_MSR 的值装载到 eip 寄存器 将 SYSENTER_CS_MSR 的值加 8（Ring0 的堆栈段描述符）装载到 ss 寄存器. 将 SYSENTER_ESP_MSR 的值装载到 esp 寄存器 将特权级切换到 Ring0 如果 EFLAGS 寄存器的 VM 标志被置位, 则清除该标志 开始执行指定的 Ring0 代码 在 Ring0 代码执行完毕, 调用 SYSEXIT 指令退回 Ring3 时, CPU 会做出如下操作： 将 SYSENTER_CS_MSR 的值加 16（Ring3 的代码段描述符）装载到 cs 寄存器 将寄存器 edx 的值装载到 eip 寄存器 将 SYSENTER_CS_MSR 的值加 24（Ring3 的堆栈段描述符）装载到 ss 寄存器 将寄存器 ecx 的值装载到 esp 寄存器 将特权级切换到 Ring3 继续执行 Ring3 的代码 syscall/sysret 指令用伪代码来表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293MSR_EFER EFER;MSR_STAR STAR;MSR_LSTAR LSTAR;MSR_CSTAR CSTAR;MSR_SFMASK SFMASK;void syscall()&#123; if (EFER.SCE == 0) /* system call extensions is disable */ do_exception_UD(); /* #UD exception */ if (EFER.LMA == 1) &#123; /* long mode is active */ rcx = rip; /* save rip for syscall return */ r11 = rflags; /* save rflags to r11 */ /* * CS.L == 1 for 64-bit mode, rip from MSR_LSTAR * CS.L == 0 for compatibility, rip from MSR_CSTAR */ rip = CS.attribute.L ? LSTAR : CSTAR; /* * processor set CS register */ CS.selector = STAR.SYSCALL_CS; /* load selector from MSR_STAR.SYSCALL_CS */ CS.selector.RPL = 0; /* RPL = 0 */ CS.attribute.S = 1; /* user segment descriptor */ CS.attribute.C_D = 1; /* code segment */ CS.attribute.L = 1; /* 64-bit */ CS.attribute.D = 0; /* 64-bit */ CS.attribute.DPL = 0; /* CPL = 0 */ CS.attribute.P = 1; /* present = 1 */ CS.base = 0; CS.limit = 0xFFFFFFFF; /* * processor set SS register */ SS.selector = STAR.SYSCALL_CS + 8; SS.attribute.S = 1; SS.attribute.C_D = 0; SS.attribute.P = 1; SS.attribute.DPL = 0; SS.base = 0; SS.limit = 0xFFFFFFFF; /* set rflags */ rflags = rflags &amp; ~ SFMASK; rflags.RF = 0; /* goto rip ... */ &#125; else &#123; /* legacy mode */ rcx = (unsigned long long)eip; /* eip extend to 64 load into rcx */ rip = (unsigned long long)STAR.EIP; /* get eip from MSR_STAR.EIP */ CS.selector = STAR.SYSCALL_CS; CS.selector.RPL = 0; CS.attribute.S = 1; /* user descriptor */ CS.attribute.C_D = 1; /* code segment */ CS.attribute.D = 1; /* 32-bit */ CS.attribute.C = 0; /* non-conforming */ CS.attribute.R = 1; /* read/execute */ CS.attribute.DPL = 0; /* CPL = 0 */ CS.attribute.P = 1; /* present = 1 */ CS.attribute.G = 1; /* G = 1 */ CS.base = 0; CS.limit = 0xFFFFFFFF; SS.selector = STAR.SYSCALL_CS + 8; SS.attribute.S = 1; /* user descriptor */ SS.attribute.C_D = 0; /* data segment */ SS.attribute.D = 1; /* 32-bit esp */ SS.attribute.E = 0; /* expand-up */ SS.attribute.W = 1; /* read/write */ SS.attribute.P = 1; /* present */ SS.attribute.DPL = 0; /* DPL = 0 */ SS.attribute.G = 1; /* G = 1 */ SS.base = 0; SS.limit = 0xFFFFFFFF; rflags.VM = 0; rflags.IF = 0; rflags.RF = 0; /* goto rip */ &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void sysret()&#123; if (EFER.SCE == 0) /* System Call Extension is disable */ do_exception_UD(); if (CR0.PE == 0 || CS.attribute.DPL != 0) /* protected mode is disable or CPL != 0 */ do_exception_GP(); if (CS.attribute.L == 1) /* 64-bit mode */ &#123; if (REX.W == 1) /* 64-bit operand size */ &#123; /* * return to 64-bit code ! */ CS.selector = STAR.SYSRET_CS + 16; /* 64-bit code segment selector */ CS.selector.RPL = 3; /* CPL = 3 */ CS.attribute.L = 1; CS.attribute.D = 0; CS.attribute.P = 1; CS.attribute.DPL = 3; CS.base = 0; CS.limit = 0xFFFFFFFF; rip = rcx; /* restore rip for return */ &#125; else &#123; /* * return to compatibility ! */ CS.selector = STAR.SYSRET_CS; /* 32-bit code segment selector */ CS.selector.RPL = 3; CS.attribute.L = 0; /* compatibility mode */ CS.attribute.D = 1; /* 32-bit code */ CS.attribute.P = 1; CS.attribute.C = 0; CS.attribute.R = 1; CS.attribute.DPL = 3; CS.base = 0; CS.limit = 0xFFFFFFFF; rip = (unsigned long long)ecx; &#125; SS.selector = START.SYSRET_CS + 8; /* SS selector for return */ rflags = r11; /* restore rflags */ /* goto rip */ &#125; else &#123; /* compatibility or legacy mode */ CS.selector = STAR.SYSRET_CS; /* 32-bit code segment selector */ CS.selector.RPL = 3 CS.attribute.L = 0; /* compatibility mode */ CS.attribute.D = 1; /* 32-bit code */ CS.attribute.P = 1; CS.attribute.C = 0; CS.attribute.R = 1; CS.attribute.DPL = 3; CS.base = 0; CS.limit = 0xFFFFFFFF; SS.selector = STAR.SYSRET_CS + 8; rflags.IF = 1; rip = (unsigned long long)ecx; &#125;&#125; System Service Descriptor Table (SSDT) &amp; Shadow SSDT现在我们知道, Ring3 通过 syscall 进行系统调用到 Ring0, 那么 syscall 是怎么找到对应的内核服务函数的呢? 就是通过 SSDT 和 Shadow SSDT 这两张表来找到的. SSDT 的全称是 System Services Descriptor Table, 系统服务描述符表. 这个表就是一个把 Ring3 的 Win32 API 和 Ring0 的内核 API 联系起来. SSDT 并不仅仅只包含一个庞大的地址索引表, 它还包含着一些其它有用的信息, 诸如地址索引的基地址, 服务函数个数等. 通过修改此表的函数地址可以对常用Windows 函数及 API 进行 Hook, 从而实现对一些关心的系统动作进行过滤, 监控的目的. 一些 HIPS, 防毒软件, 系统监控, 注册表监控软件往往会采用此接口来实现自己的监控模块. 例如, Windows API OpenProcess是从Kernel32导出的, 所以调用首先转到了Kernel32的OpenProcess函数. 在OpenProcess中又调用了ntdll!NtOpenProcess函数. 然后通过快速系统调用进入内核, 根据传进来的索引在SSDT中得到函数的地址, 然后调用函数. 在 NT 4.0 以上的 Windows 操作系统中, 默认就存在两个系统服务描述表, 这两个调度表对应了两类不同的系统服务, 这两个调度表为：KeServiceDescriptorTable 和 KeServiceDescriptorTableShadow, 其中 KeServiceDescriptorTable 主要是处理来自 Ring3 层得 Kernel32.dll中的系统调用, 而 KeServiceDescriptorTableShadow 则主要处理来自 User32.dll 和 GDI32.dll 以及 Win32u.dll 中的系统调用, 并且 KeServiceDescriptorTable 在ntoskrnl.exe(Windows 操作系统内核文件, 包括内核和执行体层)是导出的, 而 KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出, 而关于 SSDT 的全部内容则都是通过 KeServiceDescriptorTable 来完成的 ~ ntoskrnl.exe中的一个导出项 KeServiceDescriptorTable 即是SSDT的真身, 亦即它在内核中的数据实体. SSDT的数 据结构定义如下: 123456789101112131415typedef struct _KSYSTEM_SERVICE_TABLE&#123; PULONG ServiceTableBase; // SSDT (System Service Dispatch Table)的基地址 PULONG ServiceCounterTableBase; // 用于 checked builds, 包含 SSDT 中每个服务被调用的次数 ULONG NumberOfService; // 服务函数的个数, NumberOfService * 4 就是整个地址表的大小 ULONG ParamTableBase; // SSPT(System Service Parameter Table)的基地址, 该表格包含了每个服务所需的参数字节数&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123; KSYSTEM_SERVICE_TABLE ntoskrnl; // ntoskrnl.exe 的服务函数 KSYSTEM_SERVICE_TABLE win32k; // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持) KSYSTEM_SERVICE_TABLE notUsed1; KSYSTEM_SERVICE_TABLE notUsed2;&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR; 然而, x86 与 x64 有些许差别, x86 中 ServiceTableBase 存储的就是系统服务函数地址.而 x64 中 ServiceTableBase 存储的是相对于ServiceTableBase的系统服务函数的偏移, 同样使用4字节表示一项.由于函数的起始地址最低四位都是0, 所以微软将 SSDT 中的低四位用来记录这个函数有多少个参数需要在栈中传递, 即 ArgumentCount - 4 (RCX, RDX, R8, R9). 那么根据 KiSystemServiceStart 函数可得到算法: 123x86: Address = ServiceTableBase + (SystemCallNumber * 4)x64: Address = ServiceTableBase + (((int*)(ServiceTableBase + (SystemCallNumber &amp; 0x0FFF) * 4))[0] &gt;&gt; 4) 拿个栗子说事儿Windows 8.1 x64, syscall/sysret首先我们来看下 syscall/sysret 相关的几个寄存器 123456789101112131415161718192021221: kd&gt; rdmsr c0000081msr[c0000081] = 00230010`000000001: kd&gt; rdmsr c0000082msr[c0000082] = fffff800`2a4922001: kd&gt; ln fffff800`2a492200Browse moduleSet bu breakpoint(fffff800`2a492200) nt!KiSystemCall64 | (fffff800`2a492348) nt!KiSystemServiceStartExact matches: nt!KiSystemCall64 (&lt;no parameter info&gt;)1: kd&gt; rdmsr c0000083msr[c0000083] = fffff800`2a491f401: kd&gt; ln fffff800`2a491f40Browse moduleSet bu breakpoint(fffff800`2a491f40) nt!KiSystemCall32 | (fffff800`2a492080) nt!KiSystemServiceHandlerExact matches: nt!KiSystemCall32 (&lt;no parameter info&gt;)1: kd&gt; rdmsr c0000084msr[c0000084] = 00000000`00004700 首先看一下 STAR 寄存器. 通过 rdmsr c0000081 得到 0023001000000000, 根据 STAR 的结构得知: sysret CS : 0023 sysret SS : 002B ; CS + 8 sysret CS 64bit : 0033 ; CS + 16 syscall CS : 0010 syscall SS : 0018 ; CS + 8 syscall 32bit EIP : 00000000 我们通过分别对 ntdll!NtCreateFile 和 nt!NtCreateFile 下断点来验证一下: 1234567891011121314151617181920212223242526272829Breakpoint 1 hitntdll!NtCreateFile:0033:00007ff8`8d282670 48894c2408 mov qword ptr [rsp+8],rcx1: kd&gt; rrax=0000000000000000 rbx=000000000eb94a60 rcx=000000001128eb80rdx=0000000000100001 rsi=00000000133ea660 rdi=00007ff875680088rip=00007ff88d282670 rsp=000000001128eb08 rbp=000000001128eba9 r8=000000001128eba8 r9=000000001128ebe0 r10=00000000133e6050r11=00000000133ea668 r12=0000000000000001 r13=00007ff875680088r14=0000000000000000 r15=000000000eb58e90iopl=0 nv up ei pl zr na po nccs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtCreateFile:0033:00007ff8`8d282670 48894c2408 mov qword ptr [rsp+8],rcx ss:002b:00000000`1128eb10=000000000eb94a601: kd&gt; gBreakpoint 2 hitnt!NtCreateFile:fffff802`2b5f8784 488bc4 mov rax,rsp1: kd&gt; rrax=0000000000000000 rbx=ffffe0000883e080 rcx=000000001128eb80rdx=0000000000100001 rsi=000000001128eb28 rdi=ffffd00026fb2aa8rip=fffff8022b5f8784 rsp=ffffd00026fb2a88 rbp=ffffd00026fb2b80 r8=000000001128eba8 r9=000000001128ebe0 r10=fffff8022b5f8784r11=fffff8022af1a478 r12=0000000000000001 r13=00007ff875680088r14=0000000000000000 r15=000000000eb58e90iopl=0 nv up ei pl zr na po nccs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b efl=00000246nt!NtCreateFile:fffff802`2b5f8784 488bc4 mov rax,rsp 可以看到ntdll!NtCreateFile 的 CS, SS 寄存器的值分别对应 sysret 的 CS 64it, SS.nt!NtCreateFile 的 CS, SS 寄存器的值分别对应 syscall 的 CS, SS. 接下来, 我们来看看 syscall 是如何从 Ring3 切换到 Ring0 的.我们来看下 LSTAR 指向的函数, 即 nt!KiSystemCall64 : 不知道什么原因, 我只要对这个函数下断点就会导致 VMWare 虚拟机显示CPU异常而退出…所以我们直接用 IDA 看代码 KiSystemCall64123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395.text:000000000028F200 KiSystemCall64 proc near ; DATA XREF: .pdata:000000000088430C.text:000000000028F200 ; KiInitializeBootStructures+348.text:000000000028F200.text:000000000028F200 var_1C0 = qword ptr -1C0h.text:000000000028F200 var_1B8 = qword ptr -1B8h.text:000000000028F200 var_1B0 = qword ptr -1B0h.text:000000000028F200 var_1A8 = qword ptr -1A8h.text:000000000028F200 var_1A0 = qword ptr -1A0h.text:000000000028F200 var_178 = byte ptr -178h.text:000000000028F200 TF_Xmm1Offset = byte ptr -110h.text:000000000028F200 arg_F8 = qword ptr 100h.text:000000000028F200.text:000000000028F200 000 swapgs ; GS.Base 与 MSR[C0000102] (KernelGSBase) 交换, 此时指向内核 GS.text:000000000028F203 000 mov gs:10h, rsp ; 保存用户态栈到 _KPCR.UserRsp.text:000000000028F20C 000 mov rsp, gs:1A8h ; 从 _KPCR.Prcb.RspBase 加载内核态栈.text:000000000028F215 000 push 2Bh ; 开始构建 TrapFrame, TrapFrame.SegSs = 0x2B.text:000000000028F217 008 push qword ptr gs:10h ; TrapFrame.Rsp = _KPCR.UserRsp (用户态栈).text:000000000028F21F 010 push r11 ; TrapFrame.EFlags = r11 (用户态 rflags).text:000000000028F221 018 push 33h ; TrapFrame.SegCs = 0x33.text:000000000028F223 020 push rcx ; TrapFrame.Rip = rcx (这个是用户态 syscall 下一条指令的地址).text:000000000028F224 028 mov rcx, r10 ; 把 FirstArgument 赋值给 rcx.text:000000000028F227 028 sub rsp, 8 ; 调整栈, 跳过 TrapFrame.ErrorCode.text:000000000028F22B 030 push rbp ; TrapFrame.Rbp = rbp.text:000000000028F22C 038 sub rsp, 158h ; 调整 TrapFrame 起始地址, 0x158 + 0x38 = 0x190 即这个结构体从尾部开始填充数据, 然后其他未处理的部分直接调整栈来分配足够的空间..text:000000000028F233 190 lea rbp, [rsp+190h+TF_Xmm1Offset] ; 不理解为啥要从这个 TrapFrame.Xmm1 字段开始.text:000000000028F23B 190 mov [rbp+0C0h], rbx ; TrapFrame.Rbx = rbx.text:000000000028F242 190 mov [rbp+0C8h], rdi ; TrapFrame.Rdi = rdi.text:000000000028F249 190 mov [rbp+0D0h], rsi ; TrapFrame.Rsi = rsi.text:000000000028F250 190 mov byte ptr [rbp-55h], 2 ; TrapFrame.ExceptionActive = 2.text:000000000028F254 190 mov rbx, gs:188h ; rbx = _KPCR.Prcb.CurrentThread (_KTHREAD).text:000000000028F25D 190 prefetchw byte ptr [rbx+90h] ; 提示 CPU 预加载 _KPCR.Prcb.CurrentThread.TrapFrame.text:000000000028F264 190 stmxcsr dword ptr [rbp-54h] ; TrapFrame.MxCsr = mxcsr.text:000000000028F268 190 ldmxcsr dword ptr gs:180h ; mxcsr = _KPCR.Prcb.MxCsr.text:000000000028F271 190 cmp byte ptr [rbx+3], 0 ; _KPCR.Prcb.CurrentThread.DispatchHeader.DebugActive.text:000000000028F275 190 mov word ptr [rbp+80h], 0 ; TrapFrame.ErrorCode = 0.text:000000000028F27E 190 jz NoDebugActive ; 一般从这里跳, 未调试.text:000000000028F284 190 mov [rbp-50h], rax ; TrapFrame.Rax = rax.text:000000000028F288 190 mov [rbp-48h], rcx ; TrapFrame.Rcx = rcx.text:000000000028F28C 190 mov [rbp-40h], rdx ; TrapFrame.Rdx = rdx.text:000000000028F290 190 test byte ptr [rbx+3], 3 ; _KPCR.Prcb.CurrentThread.DispatchHeader.DebugActive(0x3).(ActiveDR7 &amp; Instrumented).text:000000000028F294 190 mov [rbp-38h], r8 ; TrapFrame.R8 = r8.text:000000000028F298 190 mov [rbp-30h], r9 ; TrapFrame.R9 = r9.text:000000000028F29C 190 jz short NoSaveDebugRegisterState.text:000000000028F29E 190 call KiSaveDebugRegisterState.text:000000000028F2A3.text:000000000028F2A3 NoSaveDebugRegisterState: ; CODE XREF: KiSystemCall64+9C.text:000000000028F2A3 190 test byte ptr [rbx+3], 4 ; _KPCR.Prcb.CurrentThread.DispatchHeader.DebugActive(0x4).Minimal.text:000000000028F2A7 190 jz short NoDebugActiveMinimal.text:000000000028F2A9 190 sti.text:000000000028F2AA 190 mov ecx, [rbp-50h] ; _QWORD.text:000000000028F2AD 190 mov rdx, rsp ; _QWORD.text:000000000028F2B0 190 call cs:__imp_PicoSystemCallDispatch.text:000000000028F2B6 190 jmp KiSystemServiceExit.text:000000000028F2BB ; ---------------------------------------------------------------------------.text:000000000028F2BB.text:000000000028F2BB NoDebugActiveMinimal: ; CODE XREF: KiSystemCall64+A7.text:000000000028F2BB 190 test byte ptr [rbx+3], 80h ; _KPCR.Prcb.CurrentThread.DispatchHeader.DebugActive(0x80).UmsPrimary.text:000000000028F2BF 190 jz short NoDebugActiveUmsPrimary.text:000000000028F2C1 190 mov ecx, 0C0000102h ; KernelGSBase.text:000000000028F2C6 190 rdmsr ; 由于开头调用了 swapgs, 所以返回的是 用户态 GS.text:000000000028F2C8 190 shl rdx, 20h.text:000000000028F2CC 190 or rax, rdx.text:000000000028F2CF 190 cmp [rbx+0F0h], rax.text:000000000028F2D6 190 jz short NoDebugActiveUmsPrimary.text:000000000028F2D8 190 cmp [rbx+200h], rax.text:000000000028F2DF 190 jz short NoDebugActiveUmsPrimary.text:000000000028F2E1 190 mov rdx, [rbx+1F0h].text:000000000028F2E8 190 bts dword ptr [rbx+74h], 9.text:000000000028F2ED 190 dec word ptr [rbx+1E6h].text:000000000028F2F4 190 mov [rdx+80h], rax.text:000000000028F2FB 190 sti.text:000000000028F2FC 190 call KiUmsCallEntry.text:000000000028F301 190 jmp short loc_28F30E.text:000000000028F303 ; ---------------------------------------------------------------------------.text:000000000028F303.text:000000000028F303 NoDebugActiveUmsPrimary: ; CODE XREF: KiSystemCall64+BF.text:000000000028F303 ; KiSystemCall64+D6 ....text:000000000028F303 190 test byte ptr [rbx+3], 40h.text:000000000028F307 190 jz short loc_28F30E.text:000000000028F309 190 bts dword ptr [rbx+74h], 11h.text:000000000028F30E.text:000000000028F30E loc_28F30E: ; CODE XREF: KiSystemCall64+101.text:000000000028F30E ; KiSystemCall64+107.text:000000000028F30E 190 mov rax, [rbp-50h].text:000000000028F312 190 mov rcx, [rbp-48h].text:000000000028F316 190 mov rdx, [rbp-40h].text:000000000028F31A 190 mov r8, [rbp-38h].text:000000000028F31E 190 mov r9, [rbp-30h].text:000000000028F322 db 66h, 66h, 66h, 66h, 66h, 66h.text:000000000028F322 190 nop word ptr [rax+rax+00000000h].text:000000000028F330.text:000000000028F330 NoDebugActive: ; CODE XREF: KiSystemCall64+7E.text:000000000028F330 190 sti.text:000000000028F331 190 mov [rbx+88h], rcx ; _KPCR.Prcb.CurrentThread.FirstArgument.text:000000000028F338 190 mov [rbx+80h], eax ; _KPCR.Prcb.CurrentThread.SystemCallNumber.text:000000000028F33E 190 cmp byte ptr [rbx+232h], 1 ; 检查 PreviousMode 应该为 UserMode.text:000000000028F345 190 jz short KiSystemServiceStart.text:000000000028F347 190 int 3 ; Trap to Debugger.text:000000000028F348.text:000000000028F348 KiSystemServiceStart: ; CODE XREF: KiSystemCall64+145.text:000000000028F348 ; DATA XREF: KiServiceInternal+5A ....text:000000000028F348 190 mov [rbx+90h], rsp ; _KPCR.Prcb.CurrentThread.TrapFrame = TrapFrame.text:000000000028F34F 190 mov edi, eax ; _KPCR.Prcb.CurrentThread.SystemCallNumber.text:000000000028F351 190 shr edi, 7 ; 这三行是用来在后面检查是否为 GUI API 调用的, 如果是 GUI API, 则计算出 Shadow SSDT 的偏移号..text:000000000028F354 190 and edi, 20h ; GUI API 调用号都是从 0x1000 开始的. 0x1000 &gt;&gt; 7 刚好是 0x20.text:000000000028F357 190 and eax, 0FFFh ; 修正调用号 (消除 GUI 调用号的 0x1000 基本号).text:000000000028F35C.text:000000000028F35C KiSystemServiceRepeat: ; CODE XREF: KiSystemCall64+4B1.text:000000000028F35C ; 这一段就是根据调用号计算出系统服务例程地址的算法部分了.text:000000000028F35C 190 lea r10, KeServiceDescriptorTable.text:000000000028F363 190 lea r11, KeServiceDescriptorTableShadow.text:000000000028F36A 190 test dword ptr [rbx+78h], 40h ; test _KPCR.Prcb.CurrentThread.ThreadFlags.GuiThread, 1.text:000000000028F371 190 cmovnz r10, r11 ; if GuiThread Then r10 = KeServiceDescriptorTableShadow;.text:000000000028F375 190 cmp eax, [rdi+r10+10h] ; SystemCallNumber &gt; _KSERVICE_TABLE_DESCRIPTOR.NumberOfServices ?.text:000000000028F375 190 ; 这里加 rdi 表示,如果是 GDI 调用,则直接索引到 Shadow SSDT 的字段.text:000000000028F37A 190 jnb loc_28F678.text:000000000028F380 190 mov r10, [rdi+r10] ; r10 = _KSERVICE_TABLE_DESCRIPTOR.ServiceTableBase.text:000000000028F384 190 movsxd r11, dword ptr [r10+rax*4] ; r11 = [ServiceTableBase + SystemCallNumber * 4].text:000000000028F388 190 mov rax, r11.text:000000000028F38B 190 sar r11, 4 ; r11 &gt;&gt; 4.text:000000000028F38F 190 add r10, r11 ; 系统服务例程地址 r10 = ServiceTableBase + r11.text:000000000028F392 190 cmp edi, 20h.text:000000000028F395 190 jnz short NonGDITebAccess ; 检查是否为 GUI API.text:000000000028F397 190 mov r11, [rbx+0F0h] ; r11 = _KPCR.Prcb.CurrentThread.Teb.text:000000000028F39E.text:000000000028F39E KiSystemServiceGdiTebAccess: ; DATA XREF: KiSystemServiceHandler+D.text:000000000028F39E 190 cmp dword ptr [r11+1740h], 0 ; Teb.GdiBatchCount.text:000000000028F3A6 190 jz short NonGDITebAccess.text:000000000028F3A8 190 mov [rbp-50h], rax.text:000000000028F3AC 190 mov [rbp-48h], rcx.text:000000000028F3B0 190 mov [rbp-40h], rdx.text:000000000028F3B4 190 mov rbx, r8.text:000000000028F3B7 190 mov rdi, r9.text:000000000028F3BA 190 mov rsi, r10.text:000000000028F3BD 190 mov rcx, 7.text:000000000028F3C4 190 xor edx, edx.text:000000000028F3C6 190 xor r8, r8.text:000000000028F3C9 190 xor r9, r9.text:000000000028F3CC 190 call PsInvokeWin32Callout.text:000000000028F3D1 190 mov rax, [rbp-50h].text:000000000028F3D5 190 mov rcx, [rbp-48h].text:000000000028F3D9 190 mov rdx, [rbp-40h].text:000000000028F3DD 190 mov r8, rbx.text:000000000028F3E0 190 mov r9, rdi.text:000000000028F3E3 190 mov r10, rsi.text:000000000028F3E6 db 66h, 66h.text:000000000028F3E6 190 nop word ptr [rax+rax+00000000h].text:000000000028F3F0.text:000000000028F3F0 NonGDITebAccess: ; CODE XREF: KiSystemCall64+195.text:000000000028F3F0 ; KiSystemCall64+1A6.text:000000000028F3F0 190 and eax, 0Fh ; 检查需要通过栈传递的参数有几个, ArgumentCount - 4 (RCX, RDX, R8, R9).text:000000000028F3F3 190 jz KiSystemServiceCopyEnd.text:000000000028F3F9 190 shl eax, 3 ; 计算栈参数总字节数 Count * 8.text:000000000028F3FC 190 lea rsp, [rsp-70h] ; .text:000000000028F401 190 lea rdi, [rsp+190h+var_178] ; .text:000000000028F406 190 mov rsi, [rbp+100h] ; rsi = Ring3 Rsp.text:000000000028F40D 190 lea rsi, [rsi+20h] ; .text:000000000028F411 190 test byte ptr [rbp+0F0h], 1.text:000000000028F418 190 jz short loc_28F430.text:000000000028F41A 190 cmp rsi, cs:MmUserProbeAddress.text:000000000028F421 190 cmovnb rsi, cs:MmUserProbeAddress.text:000000000028F429 190 nop dword ptr [rax+00000000h].text:000000000028F430.text:000000000028F430 loc_28F430: ; CODE XREF: KiSystemCall64+218.text:000000000028F430 190 lea r11, KiSystemServiceCopyEnd.text:000000000028F437 190 sub r11, rax.text:000000000028F43A 190 jmp r11 ; r11指向的 KiSystemServiceCopyStart 会拷贝系统调用的参数到内核栈.text:000000000028F43D ; ---------------------------------------------------------------------------.text:000000000028F43D 190 nop dword ptr [rax].text:000000000028F440.text:000000000028F440 KiSystemServiceCopyStart: ; DATA XREF: KiSystemServiceHandler+1A.text:000000000028F440 190 mov rax, [rsi+70h].text:000000000028F444 190 mov [rdi+70h], rax.text:000000000028F448 190 mov rax, [rsi+68h].text:000000000028F44C 190 mov [rdi+68h], rax.text:000000000028F450 190 mov rax, [rsi+60h].text:000000000028F454 190 mov [rdi+60h], rax.text:000000000028F458 190 mov rax, [rsi+58h].text:000000000028F45C 190 mov [rdi+58h], rax.text:000000000028F460 190 mov rax, [rsi+50h].text:000000000028F464 190 mov [rdi+50h], rax.text:000000000028F468 190 mov rax, [rsi+48h].text:000000000028F46C 190 mov [rdi+48h], rax.text:000000000028F470 190 mov rax, [rsi+40h].text:000000000028F474 190 mov [rdi+40h], rax.text:000000000028F478 190 mov rax, [rsi+38h].text:000000000028F47C 190 mov [rdi+38h], rax.text:000000000028F480 190 mov rax, [rsi+30h].text:000000000028F484 190 mov [rdi+30h], rax.text:000000000028F488 190 mov rax, [rsi+28h].text:000000000028F48C 190 mov [rdi+28h], rax.text:000000000028F490 190 mov rax, [rsi+20h].text:000000000028F494 190 mov [rdi+20h], rax.text:000000000028F498 190 mov rax, [rsi+18h].text:000000000028F49C 190 mov [rdi+18h], rax.text:000000000028F4A0 190 mov rax, [rsi+10h].text:000000000028F4A4 190 mov [rdi+10h], rax.text:000000000028F4A8 190 mov rax, [rsi+8].text:000000000028F4AC 190 mov [rdi+8], rax.text:000000000028F4B0.text:000000000028F4B0 KiSystemServiceCopyEnd: ; CODE XREF: KiSystemCall64+1F3.text:000000000028F4B0 ; DATA XREF: KiSystemServiceHandler+27 ....text:000000000028F4B0 190 test cs:[PerfGlobalGroupMask + 8], 40h ; Check PERF_SYSCALL ???.text:000000000028F4BA 190 jnz loc_28F716.text:000000000028F4C0 190 call r10 ; 调用计算出来的系统服务例程.text:000000000028F4C3.text:000000000028F4C3 loc_28F4C3: ; CODE XREF: KiSystemCall64+56B.text:000000000028F4C3 190 inc dword ptr gs:2E38h ; ++_KPCR.Pcrb.KeSystemCalls.text:000000000028F4CB.text:000000000028F4CB KiSystemServiceExit: ; CODE XREF: KiSystemCall64+B6.text:000000000028F4CB ; KiSystemCall64+4D2 ....text:000000000028F4CB ; 开始恢复寄存器.text:000000000028F4CB 190 mov rbx, [rbp+0C0h] ; rbx = TrapFrame.Rbx.text:000000000028F4D2 190 mov rdi, [rbp+0C8h] ; rdi = TrapFrame.Rdi.text:000000000028F4D9 190 mov rsi, [rbp+0D0h] ; rsi = TrapFrame.Rsi.text:000000000028F4E0 190 mov r11, gs:188h ; r11 = _KPCR.Prcb.CurrentThread (_KTHREAD).text:000000000028F4E9 190 test byte ptr [rbp+0F0h], 1 ; TrapFrame.SegCs.CPL == Ring0 ?.text:000000000028F4F0 190 jz ServiceExitRing0 ; CPL 为 Ring0 则跳转.text:000000000028F4F6 190 mov rcx, cr8 ; Task Priority Register.text:000000000028F4FA 190 or cl, [r11+242h] ; CurrentThread.ApcStateIndex.text:000000000028F501 190 or ecx, [r11+1E4h] ; CurrentThread.KernelApcDisable.text:000000000028F508 190 jnz loc_28F6E2.text:000000000028F50E 190 cli.text:000000000028F50F 190 mov rcx, gs:188h.text:000000000028F518 190 cmp byte ptr [rcx+0C2h], 0.text:000000000028F51F 190 jz short loc_28F578.text:000000000028F521 190 mov [rbp-50h], rax.text:000000000028F525 190 xor eax, eax.text:000000000028F527 190 mov [rbp-48h], rax.text:000000000028F52B 190 mov [rbp-40h], rax.text:000000000028F52F 190 mov [rbp-38h], rax.text:000000000028F533 190 mov [rbp-30h], rax.text:000000000028F537 190 mov [rbp-28h], rax.text:000000000028F53B 190 mov [rbp-20h], rax.text:000000000028F53F 190 pxor xmm0, xmm0.text:000000000028F543 190 movaps xmmword ptr [rbp-10h], xmm0.text:000000000028F547 190 movaps xmmword ptr [rbp+0], xmm0.text:000000000028F54B 190 movaps xmmword ptr [rbp+10h], xmm0.text:000000000028F54F 190 movaps xmmword ptr [rbp+20h], xmm0.text:000000000028F553 190 movaps xmmword ptr [rbp+30h], xmm0.text:000000000028F557 190 movaps xmmword ptr [rbp+40h], xmm0.text:000000000028F55B 190 mov ecx, 1.text:000000000028F560 190 mov cr8, rcx.text:000000000028F564 190 sti.text:000000000028F565 190 call KiInitiateUserApc.text:000000000028F56A 190 cli.text:000000000028F56B 190 mov ecx, 0.text:000000000028F570 190 mov cr8, rcx.text:000000000028F574 190 mov rax, [rbp-50h].text:000000000028F578.text:000000000028F578 loc_28F578: ; CODE XREF: KiSystemCall64+31F.text:000000000028F578 190 mov rcx, gs:188h.text:000000000028F581 190 test dword ptr [rcx], 40010000h.text:000000000028F587 190 jz short loc_28F5B7.text:000000000028F589 190 mov [rbp-50h], rax.text:000000000028F58D 190 test byte ptr [rcx+2], 1.text:000000000028F591 190 jz short loc_28F5A1.text:000000000028F593 190 call KiCopyCounters.text:000000000028F598 190 mov rcx, gs:188h.text:000000000028F5A1.text:000000000028F5A1 loc_28F5A1: ; CODE XREF: KiSystemCall64+391.text:000000000028F5A1 190 test byte ptr [rcx+3], 40h.text:000000000028F5A5 190 jz short loc_28F5B3.text:000000000028F5A7 190 lea rsp, [rbp-80h].text:000000000028F5AB 190 xor rcx, rcx.text:000000000028F5AE 190 call KiUmsExit.text:000000000028F5B3.text:000000000028F5B3 loc_28F5B3: ; CODE XREF: KiSystemCall64+3A5.text:000000000028F5B3 190 mov rax, [rbp-50h].text:000000000028F5B7.text:000000000028F5B7 loc_28F5B7: ; CODE XREF: KiSystemCall64+387.text:000000000028F5B7 190 ldmxcsr dword ptr [rbp-54h].text:000000000028F5BB 190 xor r10, r10.text:000000000028F5BE 190 cmp word ptr [rbp+80h], 0 ; TrapFrame.ErrorCode == 0 ?.text:000000000028F5C6 190 jz short ServiceExitRing3.text:000000000028F5C8 190 mov [rbp-50h], rax.text:000000000028F5CC 190 call KiRestoreDebugRegisterState.text:000000000028F5D1 190 mov rax, gs:188h.text:000000000028F5DA 190 mov rax, [rax+0B8h].text:000000000028F5E1 190 mov rax, [rax+2C0h].text:000000000028F5E8 190 or rax, rax.text:000000000028F5EB 190 jz short loc_28F605.text:000000000028F5ED 190 cmp word ptr [rbp+0F0h], 33h ; TrapFrame.SegCs == User CS ?.text:000000000028F5F5 190 jnz short loc_28F605.text:000000000028F5F7 190 mov r10, [rbp+0E8h] ; CurrentThread.Queue.text:000000000028F5FE 190 mov [rbp+0E8h], rax.text:000000000028F605.text:000000000028F605 loc_28F605: ; CODE XREF: KiSystemCall64+3EB.text:000000000028F605 ; KiSystemCall64+3F5.text:000000000028F605 190 mov rax, [rbp-50h].text:000000000028F609.text:000000000028F609 ServiceExitRing3: ; CODE XREF: KiSystemCall64+3C6.text:000000000028F609 190 mov r8, [rbp+100h] ; r8 = TrapFram.Rsp.text:000000000028F610 190 mov r9, [rbp+0D8h] ; r9 = TrapFram.Rbp.text:000000000028F617 190 xor edx, edx ; 0.text:000000000028F619 190 pxor xmm0, xmm0 ; 下面 pxor 的全是重置为 0.text:000000000028F61D 190 pxor xmm1, xmm1.text:000000000028F621 190 pxor xmm2, xmm2.text:000000000028F625 190 pxor xmm3, xmm3.text:000000000028F629 190 pxor xmm4, xmm4.text:000000000028F62D 190 pxor xmm5, xmm5.text:000000000028F631 190 mov rcx, [rbp+0E8h] ; rcx = TrapFrame.Rip.text:000000000028F638 190 mov r11, [rbp+0F8h] ; r11 = TrapFrame.EFlags.text:000000000028F63F 190 mov rbp, r9 ; 恢复 Ring3 栈 .text:000000000028F642 190 mov rsp, r8 ;.text:000000000028F645 000 swapgs ; 从 MSR[KernelGSBase] 交换回 User GS.text:000000000028F648 000 sysret ; 返回 Ring3.text:000000000028F64B.text:000000000028F64B ServiceExitRing0: ; CODE XREF: KiSystemCall64+2F0.text:000000000028F64B 190 mov rdx, [rbp+0B8h] ; rdx = TrapFrame.TrapFrame.text:000000000028F652 190 mov [r11+90h], rdx ; CurrentThread.TrapFrame = rdx.text:000000000028F659 190 mov dl, [rbp-58h] ; dl = TrapFrame.PreviousMode.text:000000000028F65C 190 mov [r11+232h], dl ; CurrentThread.PreviousMode = dl.text:000000000028F663 190 cli.text:000000000028F664 190 mov rsp, rbp.text:000000000028F667 000 mov rbp, [rbp+0D8h].text:000000000028F66E 000 mov rsp, [rsp+arg_F8].text:000000000028F676 000 sti.text:000000000028F677 000 retn.text:000000000028F678 ; ---------------------------------------------------------------------------.text:000000000028F678.text:000000000028F678 loc_28F678: ; CODE XREF: KiSystemCall64+17A.text:000000000028F678 190 cmp edi, 20h.text:000000000028F67B 190 jnz short loc_28F6D8.text:000000000028F67D 190 mov [rbp-80h], eax.text:000000000028F680 190 mov [rbp-78h], rcx.text:000000000028F684 190 mov [rbp-70h], rdx.text:000000000028F688 190 mov [rbp-68h], r8.text:000000000028F68C 190 mov [rbp-60h], r9.text:000000000028F690 190 call KiConvertToGuiThread.text:000000000028F695 190 or eax, eax.text:000000000028F697 190 mov eax, [rbp-80h].text:000000000028F69A 190 mov rcx, [rbp-78h].text:000000000028F69E 190 mov rdx, [rbp-70h].text:000000000028F6A2 190 mov r8, [rbp-68h].text:000000000028F6A6 190 mov r9, [rbp-60h].text:000000000028F6AA 190 mov [rbx+90h], rsp.text:000000000028F6B1 190 jz KiSystemServiceRepeat.text:000000000028F6B7 190 lea rdi, qword_8AABA0.text:000000000028F6BE 190 mov esi, [rdi+10h].text:000000000028F6C1 190 mov rdi, [rdi].text:000000000028F6C4 190 cmp eax, esi.text:000000000028F6C6 190 jnb short loc_28F6D8.text:000000000028F6C8 190 lea rdi, [rdi+rsi*4].text:000000000028F6CC 190 movsx eax, byte ptr [rax+rdi].text:000000000028F6D0 190 or eax, eax.text:000000000028F6D2 190 jle KiSystemServiceExit.text:000000000028F6D8.text:000000000028F6D8 loc_28F6D8: ; CODE XREF: KiSystemCall64+47B.text:000000000028F6D8 ; KiSystemCall64+4C6.text:000000000028F6D8 190 mov eax, 0C000001Ch ;STATUS_INVALID_SYSTEM_SERVICE.text:000000000028F6DD 190 jmp KiSystemServiceExit.text:000000000028F6E2 ; ---------------------------------------------------------------------------.text:000000000028F6E2.text:000000000028F6E2 loc_28F6E2: ; CODE XREF: KiSystemCall64+308.text:000000000028F6E2 190 mov ecx, 4Ah.text:000000000028F6E7 190 xor r9d, r9d.text:000000000028F6EA 190 mov r8, cr8.text:000000000028F6EE 190 or r8d, r8d.text:000000000028F6F1 190 jnz short loc_28F707.text:000000000028F6F3 190 mov ecx, 1.text:000000000028F6F8 190 movzx r8d, byte ptr [r11+242h].text:000000000028F700 190 mov r9d, [r11+1E4h].text:000000000028F707.text:000000000028F707 loc_28F707: ; CODE XREF: KiSystemCall64+4F1.text:000000000028F707 190 mov rdx, [rbp+0E8h].text:000000000028F70E 190 mov r10, rbp.text:000000000028F711 190 call KiBugCheckDispatch.text:000000000028F716 ; ---------------------------------------------------------------------------.text:000000000028F716.text:000000000028F716 loc_28F716: ; CODE XREF: KiSystemCall64+2BA.text:000000000028F716 190 sub rsp, 50h.text:000000000028F71A 1E0 mov [rsp+1E0h+var_1C0], rcx.text:000000000028F71F 1E0 mov [rsp+1E0h+var_1B8], rdx.text:000000000028F724 1E0 mov [rsp+1E0h+var_1B0], r8.text:000000000028F729 1E0 mov [rsp+1E0h+var_1A8], r9.text:000000000028F72E 1E0 mov [rsp+1E0h+var_1A0], r10.text:000000000028F733 1E0 mov rcx, r10.text:000000000028F736 1E0 call PerfInfoLogSysCallEntry.text:000000000028F73B 1E0 mov rcx, [rsp+1E0h+var_1C0].text:000000000028F740 1E0 mov rdx, [rsp+1E0h+var_1B8].text:000000000028F745 1E0 mov r8, [rsp+1E0h+var_1B0].text:000000000028F74A 1E0 mov r9, [rsp+1E0h+var_1A8].text:000000000028F74F 1E0 mov r10, [rsp+1E0h+var_1A0].text:000000000028F754 1E0 add rsp, 50h.text:000000000028F758 190 call r10.text:000000000028F75B 190 mov [rbp-50h], rax.text:000000000028F75F 190 mov rcx, rax.text:000000000028F762 190 call PerfInfoLogSysCallExit.text:000000000028F767 190 mov rax, [rbp-50h].text:000000000028F76B 190 jmp loc_28F4C3.text:000000000028F76B KiSystemCall64 endp.text:000000000028F76B.text:000000000028F770 ; ---------------------------------------------------------------------------.text:000000000028F770 retn KiSystemCall32123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.text:000000014028EF40 KiSystemCall32 proc near ; DATA XREF: .pdata:00000001408842E8o.text:000000014028EF40 ; KiInitializeBootStructures+333o.text:000000014028EF40.text:000000014028EF40 TF_Xmm1Offset = byte ptr 80h.text:000000014028EF40.text:000000014028EF40 000 swapgs ; GS.Base 与 MSR[C0000102] (KernelGSBase) 交换, 此时指向内核 GS.text:000000014028EF43 000 mov gs:10h, rsp ; 保存用户态栈到 _KPCR.UserRsp.text:000000014028EF4C 000 mov rsp, gs:1A8h ; 从 _KPCR.Prcb.RspBase 加载内核态栈.text:000000014028EF55 -190 push 2Bh ; 开始构建 TrapFrame, TrapFrame.SegSs = 0x2B.text:000000014028EF57 -188 push qword ptr gs:10h ; TrapFrame.Rsp = _KPCR.UserRsp (用户态栈).text:000000014028EF5F -180 push r11 ; TrapFrame.EFlags = r11 (用户态 rflags).text:000000014028EF61 -178 push 23h ; TrapFrame.SegCs = 0x23.text:000000014028EF63 -170 push rcx ; TrapFrame.Rip = rcx (这个是用户态 syscall 下一条指令的地址).text:000000014028EF64 -168 swapgs ; GS.Base 与 MSR[C0000102] (KernelGSBase) 交换, 此时指向用户 GS.text:000000014028EF67 -168 sub rsp, 8 ; 调整栈, 跳过 TrapFrame.ErrorCode.text:000000014028EF6B -160 push rbp ; TrapFrame.Rbp = rbp.text:000000014028EF6C -158 sub rsp, 158h ; 调整 TrapFrame 起始地址, 0x158 + 0x38 = 0x190 即这个结构体从尾部开始填充数据, 然后其他未处理的部分直接调整栈来分配足够的空间..text:000000014028EF73 000 lea rbp, [rsp+TF_Xmm1Offset].text:000000014028EF7B 000 mov byte ptr [rbp-55h], 1 ; TrapFrame.ExceptionActive = 1.text:000000014028EF7F 000 mov [rbp-50h], rax ; TrapFrame.Rax = rax.text:000000014028EF83 000 mov [rbp-48h], rcx ; TrapFrame.Rcx = rcx.text:000000014028EF87 000 mov [rbp-40h], rdx ; TrapFrame.Rdx = rdx.text:000000014028EF8B 000 mov [rbp-38h], r8 ; TrapFrame.R8 = r8.text:000000014028EF8F 000 mov [rbp-30h], r9 ; TrapFrame.R9 = r9.text:000000014028EF93 000 mov [rbp-28h], r10 ; TrapFrame.R10 = r10.text:000000014028EF97 000 mov [rbp-20h], r11 ; TrapFrame.R11 = r11.text:000000014028EF9B 000 test byte ptr [rbp+0F0h], 1 ; TrapFrame.SegCs.CPL == Ring0 ?.text:000000014028EFA2 000 jz short loc_14028F008 ; .text:000000014028EFA4 000 swapgs ; GS.Base 与 MSR[C0000102] (KernelGSBase) 交换, 此时指向内核 GS.text:000000014028EFA7 000 mov r10, gs:188h ; r10 = _KPCR.Prcb.CurrentThread.text:000000014028EFB0 000 test byte ptr [r10+3], 80h ; CurrentThread.DispatchHeader.DebugActive(0x80).UmsPrimary.text:000000014028EFB5 000 jz short loc_14028EFF3.text:000000014028EFB7 000 mov ecx, 0C0000102h ; 读取用户 GS.text:000000014028EFBC 000 rdmsr.text:000000014028EFBE 000 shl rdx, 20h.text:000000014028EFC2 000 or rax, rdx ; rax = User GS, 即 TEB.text:000000014028EFC5 000 cmp [r10+0F0h], rax ; CurrentThread.Teb == User GS ?.text:000000014028EFCC 000 jz short loc_14028EFF3.text:000000014028EFCE 000 cmp [r10+200h], rax ; CurrentThread.TebMappedLowVa == User GS ?.text:000000014028EFD5 000 jz short loc_14028EFF3.text:000000014028EFD7 000 mov rdx, [r10+1F0h] ; rdx = CurrentThread.Ucb (_UMS_CONTROL_BLOCK).text:000000014028EFDE 000 bts dword ptr [r10+74h], 9 ; CurrentThread.MiscFlags.UmsDirectedSwitchEnable = 1.text:000000014028EFE4 000 dec word ptr [r10+1E6h] ; --CurrentThread.SpecialApcDisable.text:000000014028EFEC 000 mov [rdx+80h], rax.text:000000014028EFF3.text:000000014028EFF3 loc_14028EFF3: ; CODE XREF: KiSystemCall32+75j.text:000000014028EFF3 ; KiSystemCall32+8Cj ....text:000000014028EFF3 000 test byte ptr [r10+3], 3 ; CurrentThread.DispatchHeader.DebugActive(0x3).(ActiveDR7 &amp; Instrumented).text:000000014028EFF8 000 mov word ptr [rbp+80h], 0.text:000000014028F001 000 jz short loc_14028F008.text:000000014028F003 000 call KiSaveDebugRegisterState.text:000000014028F008.text:000000014028F008 loc_14028F008: ; CODE XREF: KiSystemCall32+62j.text:000000014028F008 ; KiSystemCall32+C1j.text:000000014028F008 000 cld.text:000000014028F009 000 stmxcsr dword ptr [rbp-54h].text:000000014028F00D 000 ldmxcsr dword ptr gs:180h.text:000000014028F016 000 movaps xmmword ptr [rbp-10h], xmm0.text:000000014028F01A 000 movaps xmmword ptr [rbp+0], xmm1.text:000000014028F01E 000 movaps xmmword ptr [rbp+10h], xmm2.text:000000014028F022 000 movaps xmmword ptr [rbp+20h], xmm3.text:000000014028F026 000 movaps xmmword ptr [rbp+30h], xmm4.text:000000014028F02A 000 movaps xmmword ptr [rbp+40h], xmm5.text:000000014028F02E 000 test qword ptr [rbp+0F8h], 200h ; TrapFrame.EFlags &amp; 0x200 ?.text:000000014028F039 000 jz short loc_14028F03C.text:000000014028F03B 000 sti.text:000000014028F03C.text:000000014028F03C loc_14028F03C: ; CODE XREF: KiSystemCall32+F9j.text:000000014028F03C 000 mov ecx, 0C000001Dh ; STATUS_ILLEGAL_INSTRUCTION.text:000000014028F041 000 xor edx, edx.text:000000014028F043 000 mov r8, [rbp+0E8h].text:000000014028F04A 000 call KiExceptionDispatch.text:000000014028F04F 000 nop.text:000000014028F050 000 retn.text:000000014028F050 KiSystemCall32 endp KiInitializeBootStructures那么, STAR, LSTAR, CSTAR, SFMASK 这几个寄存器是在哪里初始化的呢? 是在 nt!KiInitializeBootStructures 这个函数里面, 我们看下部分代码: 123456789101112131415161718192021222324252627PAGELK:00000001408C5A00 loc_1408C5A00: ; CODE XREF: KiInitializeBootStructures+131jPAGELK:00000001408C5A00 ; KiInitializeBootStructures+2C6j ...PAGELK:00000001408C5A00 058 mov rax, [r14+8]PAGELK:00000001408C5A04 058 mov ecx, 68hPAGELK:00000001408C5A09 058 mov edx, 230010hPAGELK:00000001408C5A0E 058 mov [rax+66h], cxPAGELK:00000001408C5A12 058 xor eax, eaxPAGELK:00000001408C5A14 058 mov ecx, 0C0000081h ; STARPAGELK:00000001408C5A19 058 wrmsrPAGELK:00000001408C5A1B 058 lea rdx, KiSystemCall32PAGELK:00000001408C5A22 058 mov ecx, 0C0000083h ; CSTARPAGELK:00000001408C5A27 058 mov rax, rdxPAGELK:00000001408C5A2A 058 shr rdx, 20hPAGELK:00000001408C5A2E 058 wrmsrPAGELK:00000001408C5A30 058 lea rdx, KiSystemCall64PAGELK:00000001408C5A37 058 mov ecx, 0C0000082h ; LSTARPAGELK:00000001408C5A3C 058 mov rax, rdxPAGELK:00000001408C5A3F 058 shr rdx, 20hPAGELK:00000001408C5A43 058 wrmsrPAGELK:00000001408C5A45 058 mov eax, 4700hPAGELK:00000001408C5A4A 058 xor edx, edxPAGELK:00000001408C5A4C 058 mov ecx, 0C0000084h ;SFMASKPAGELK:00000001408C5A51 058 wrmsrPAGELK:00000001408C5A53 058 mov eax, gs:1A4hPAGELK:00000001408C5A5B 058 test eax, eaxPAGELK:00000001408C5A5D 058 jnz short loc_1408C5A64PAGELK:00000001408C5A5F 058 call KiInitializeNxSupportDiscard 总结最后, 拿 &lt;&lt; Windows Internal 6th &gt;&gt; 中的一张图来简单总结以下调用过程: 引用参考 &lt;&lt; Windows内核情景分析 &gt;&gt;&lt;&lt; Windows Internal &gt;&gt;&lt;&lt; AMD64 Architecture Programmer’s Manual Volume 2: System Programming &gt;&gt;&lt;&lt; 64-ia-32-architectures-software-developer-vol-3-system-programming &gt;&gt;&lt;&lt; mik - 使用 syscall/sysret 指令 &gt;&gt;]]></content>
      <categories>
        <category>Windows kernel learning</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows kernel learning: 1. Basis]]></title>
    <url>%2FStaticBlog%2F2017%2FWindows-kernel-learning%2FWindows-kernel-learning-1-Basis%2F</url>
    <content type="text"><![CDATA[Windows 系统结构图 图中水平粗线表示用户空间和系统空间的分界. 在 32 位 Windows 系统中, 整个 4GB 的虚拟内存地址被对分成两块, 从地址 0x80000000 开始向上是系统空间, 就是内核所在的地方, 下面则是用户空间, 是应用程序所在的地方. (64 位系统会在后面的内存管理说到, 这里只是简单了解下概念) CPU 进入内核只有三种途径: 系统调用 中断 异常 Windows 内核函数的名称前缀表中列出了内核函数的大多数名称前缀, 其中每个也都会使用前缀变化形式来标记内部函数.例如前缀的第一个字母后面跟一个 i (代表内部的 internal), 或者整个前缀后面跟一个 p (代表私有的, private), 或者前缀后面跟一个 f (代表快速的, fast). Ki 代表内核内部函数, Psp 代表内部的进程支持函数, Obf 代表对象管理器的快速调用函数. 前缀 内核组件 Alpc 高级本地进程间通信 (Advanced Local Inter-Process Communication) Cc 公共缓存 (Common Cache) Cm 系统配置管理器 (Configuration manager) Dbgk 用户模式调试框架 Em 错误修正管理器 Etw Windows 事件跟踪 Ex 管理层 (Executive) FsRtl 文件系统驱动程序运行库 Hvl 超级管理器库 Hal 硬件抽象层 (Hardware abstraction layer) Io I/O管理器 (I/O manager) Kd 内核调试器 (Kernel debug) Ke 核心层 (Kernel core) Lsa 本地安全权威 Mm 内存管理器 (Memory manager) Ob 对象管理器 (Object manager) Pf 预取器 Po 电源管理器 (Power manager) Pp Pnp 管理器 (Pnp magager) Ps 进程支持 (Process support) Rtl 运行库 (Runtime library) Se 安全性 Sm 存储管理器 (Store manager) Tm 事务管理器 (Transaction manager) Vf 检验器 (Verifier) Wdi Windows 诊断设施 (Windows Diagnostic Infrastructure) Whea Windows 硬件错误体系架构 (WIndows Hardware Error Architecture) Wmi Windows 管理设施 Nt NT系统服务 (Native system services) Zw 与 R3 中 Zw 为 Nt 的别名不同, 在内核中 Zw 是以 Nt 开头的系统服务入口点的镜像, 它把原来的访问模式设置为内核模式, 从而消除了参数的有效性检查过程, 因为 Nt 系统服务只有当原来的访问模式为用户模式时才进行参数有效性检查. 中断请求等级 IRQL在 x86 系统上, 内核在内部使用 0~31 的数值来表示 IRQL;而在 x64 和 IA64 系统上, 内核采用 0~15 的数值表示 IRQL.这里数值越大, 代表的中断请求等级越高. 内核为软件中断定义了一组标准的 IRQL, 而 HAL 则将硬件中断号映射为 IRQL. x86 中断请求级别: 数值 描述 31 高端 30 电源失败 29 处理器间的中断 28 时钟 27 性能剖析/同步 26 设备n … … 5 可纠正的机器检查 (CMCI) 4 … 3 设备1 2 DPC/dispatch 1 APC 0 User-APC/被动/低端 x64 中断请求级别 数值 描述 15 高端/性能剖析 14 处理期间的中断/电源 13 时钟 12 同步 11 设备n … … 4 … 3 设备1 2 DPC/dispatch 1 APC 0 User-APC/被动/低端 高端级别: 内核仅当它在 KeBugCheckEx 中停止了系统并屏蔽了所有中断时, 才会使用高端级别的 IRQL. 电源失败级别: 文档指定了系统电源失败代码的行为, 但是这个 IRQL 从未被使用过… 处理器间的中断级别: 被用于向另一个处理器请求执行某个动作,比如更新该处理器的 TLB 缓存, 系统停机或者系统崩溃. 时钟级别: 主要用于系统的时钟,内核利用该中断级别来跟踪日期和时间,以及为线程测量或分配 CPU 时间. 性能剖析级别: 当内核的性能剖析功能被打开时, 系统的实时时钟(或另一个中断源,比如本地APIC定时器)就会用到性能剖析级别. 当内核的性能剖析功能激活时, 内核的性能剖析陷阱处理器就会记录下中断发生时被执行代码的地址. 随着时间推移, 一张采样表就会生成. 同步级别: 内核内部使用的, 分发器和调度器利用该级别来保护对全局线程调度代码和等待/同步代码的访问.通常定义在设备IRQL最高级别之后 设备级别: 用于对设备中断进行优先级区分. CMCI级别: 当CPU或固件通过MCE机器检查错误接口报告一个虽然严重但是可以纠正的硬件条件或错误时使用. DPC/dispatch 级别 和 APC 级别: 是有内核和设备驱动程序产生的软件中断 低端/被动级别: 实际上不是中断级别; 它是普通线程运行时的设置, 此时所有的中断都允许发生. 中断是按照优先级处理的, 高优先级的中断会抢占低优先级中断的执行权.当一个高优先级的中断发生时, 处理器把中断的线程状态保存起来, 并调用与该中断关联的陷阱分发器.该陷阱分发器提升 IRQL, 并调用该中断的服务例程. 完成后再降低处理器的 IRQL, 然后装入保存的机器状态, 从中断的地方恢复执行. 处理器在x86-64处理器架构中, 当处于长模式 (Long-mode) 时, 64位应用程序 (或者是操作系统) 可以使用64位指令和寄存器, 而32位和16位程序将以一种兼容子模式 (Legacy-mode, 传统模式) 运行.不在长模式下运行时, 处理器支持真实模式和保护模式两个子模式, 在这两个模式下的x86-64处理器与x86-32处理器运行方式完全相同. 寄存器段寄存器接下来看一下各种段寄存器(CS, DS, SS, ES, FS, GS)在 Windows 中的作用. CS (Code Segment)代码段寄存器, 指向包含程序指令的段 DS (Data Segment)数据段寄存器, 指向包含静态数据或全局数据的段 SS (Stack Segment)栈段寄存器, 指向当前程序栈的段 ES (Extra Segment)附加段寄存器, 暂时不知道干嘛的 FS (Flag Segment)标志段寄存器在 x86 系统, Ring3 中, FS:[0] 指向 nt!_TEB; Ring0 中, FS:[0] 指向 nt!_KPCR在 x64 系统, 只有在 WOW64 进程中, FS 寄存器才会同 x86 寄存器一样, 其他情况未使用 GS (Global Segment)全局段寄存器在 x86 系统, 未使用在 x64 系统, 代替了 FS 寄存器, x86系统下的功能.]]></content>
      <categories>
        <category>Windows kernel learning</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows kernel learning: 0. Preface]]></title>
    <url>%2FStaticBlog%2F2017%2FWindows-kernel-learning%2FWindows-kernel-learning-0-Preface%2F</url>
    <content type="text"><![CDATA[&lt;&lt; Windows kernel learning &gt;&gt; 系列的文章是我学习 Windows 内核的笔记. 以 &lt;&lt; Windows 内核情景分析 &gt;&gt; 为学习主线, 扩展其他学习资料以及通过调试来适应现代版本的 Windows 系统. 操作系统的版本主要以 Windows 8.1 x64 为主, 有些重要的点可能会对 x86 系统同时进行记录. 由于资料来源各种地方, 以及我对有些知识的理解可能有错误, 希望同学们能帮助我改正呀~ 相关资料这里记录一些涉及到的主要资料 书籍: &lt;&lt; Windows 内核情景分析 &gt;&gt; &lt;&lt; Windows Internal 6th part 1 &gt;&gt; &lt;&lt; What Makes It Page &gt;&gt; &lt;&lt; Intel: 64 and IA-32 Architectures Software Developer Vol 3 System Programming &gt;&gt; &lt;&lt; AMD64: Architecture Programmer’s Manual Vol 2 System Programming&gt;&gt; 文章: &lt;&lt; x86-64 维基百科&gt;&gt; &lt;&lt; mouseos 技术小站 &gt;&gt; &lt;&lt; Windows7内核分析之x86&amp;x64第二章系统调用 &gt;&gt;]]></content>
      <categories>
        <category>Windows kernel learning</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 学习笔记]]></title>
    <url>%2FStaticBlog%2F2016%2FLanguage%2FOC-Notes%2F</url>
    <content type="text"><![CDATA[之前学习 Objective-C 时整理的笔记，文章内错误之处还望指点… Hello World123456789#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char *argv[])&#123; @autoreleasepool &#123; // insert code here... NSLog(@"Hello, World"); &#125; return 0;&#125; #import 就相当于 C++ 里面的 #include 123@autoreleasepool &#123; ...&#125; {...} 之间的语句会在被称之为 “自动释放池” 的语境中执行。 自动释放池的机制是：它使得应用在创建新对象时，系统能够有效的管理应用所使用的内容。 @&quot;Hello, World&quot; 此处的 @ 符号在位于一对双引号的字符串前面，这称为常量 NSString 对象。如果前面没有 @ 字符，就是在编写常量 C 类型的字符串。有了这个符号就是在编写 NSString 字符串对象。 同 C 语言一样，Objective-C 的所有程序语句必须使用分号（;）结束。 这篇文章主要是讲 Objective-C 与 C++ 的区别… 类、对象和方法消息传递Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格/在源码风格方面，这是它与C Family语言（包括C/C++、Java、世界上最好的语言PHP）差别最大的地方。 在Java、C++世界，我们调用一个对象的某个方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同。 在Java、C++里，对象和方法关系非常严格，一个方法必须属于一个类对象，否则编译要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态确定，给类型发送一个它无法处理的消息，也只会抛出一个异常而不会挂掉。 Language Call Method Objective-C [obj undefineMethod]; C++ obj.undefineMethod(); 在代码里调用没定义的方法（这是Java、C++世界习惯的说法，专业叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但能编译成功，运行的时候会出错。它会输出这样一个错误： 函数调用前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例： 不带参数 1StartedBlock(); 带参数 12NSLog(@"decrypted string: %@", str);CGRectMake(0, 0, 0, 0); 传递消息给类 / 实例方法 不带参数 Language Method Objective-C [obj method]; C++ obj.method(); 带一个参数 Language Method Objective-C [counter increase:1]; C++ counter.increase(1); 带多个参数对于C Family 程序员来说，这是最难接收，最反人类的 Language Method Objective-C -(void) setColorToRed: (float)red Green: (float)green Blue: (float)blue {…} // 定义方法 [myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; // 传递消息 C++ public void setColorToRedGreenBlue(float red, float green, float blue) {…} myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2); 消息嵌套 Language Method Objective-C UINavigationBar *bar = [ [ [UINavigationBar alloc] init] autorelease]; C++ UINavigationBar bar = UINavigationBar.alloc().inti().autorelease(); 类的定义与实现Objective-C中强烈要求将类的定义（interface）与实现（implementation）分为两个部分。类的定义文件遵循C语言之习惯，头文件以.h为后缀，实现文件以.m为后缀（也有.mm的扩展名，表示Objective-C与C++混合编程） 举个栗子： Interface定义部分，清楚定义了类的名称、数据成员和方法。以关键字@interface作为开始，@end作为结束。 1234567891011@interface MyObject : NSObject &#123; int memberVar1; //实体变量 id memberVar2;&#125;+(return_type) class_method; // 类方法-(return_type) instance_method1; // 实例方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+/-号代表函数的类型：加号（+）代表类方法（class method），不需要实例就可以调用，与C++的静态函数（static member function）相似。减号（-）即是一般的实例方法（instance method）。 下面是意义相近的 C++ 语法对照： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void *memberVar2; public: static return_type class_method(); // 类方法 return_type instance_method1(); // 实例方法 return_type instance_method2(int p1); return_type instance_method3(int p1, int p2);&#125; Objective-C 定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C 方法使得参数可以夹于名称中间，不必全部依附于方法名称的尾端，可以提高程序可读性。设定颜色RGB值得方法为例子：123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; // 宣告方法[myColor setColorToRed:1.0 Green:0.8 Blue:0.2]; // 呼叫方法 这个方法的签名是setColorToRed:Green:Blue:。每个冒号后面都带着一个float类别的参数，分别代表红，绿，蓝三色。 Implementation实现区块则包含了公开方法的实现，以及定义私有变量及方法。以关键字@implementation作为区块起头，@end结尾。 1234567891011121314151617181920@Implementation MyObject &#123; int memberVar3; // 私有实体变量&#125;+(return_type) class_method &#123; ... // method Implementation&#125;-(return_type) instance_method1 &#123; ...&#125;-(return_type) instance_method2: (int) p1 &#123; ...&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ...&#125;@end 值得一提的是不只Interface区块可定义实体变量，Implementation区块也可以定义实体变量，两者的差别在于访问权限的不同。Interface区块内的实体变量默认权限为protected，宣告于implementation区块的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为如此类别之私有信息就不需曝露于公开interface（.h文件）中。 创建对象Objective-C创建对象需通过alloc以及init两个消息。alloc的作用是分配内存，init则是初始化对象。 init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例：1MyObject *my = [[MyObject alloc] init]; 在Objective-C 2.0里，若创建对象不需要参数，则可直接使用new1MyObject *my = [MyObject new]; 仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写init方法，来添加额外的工作。（用途类似C++ 的构造函数constructor）123456- (id) init &#123; if (self = [super init]) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125; 数据类型和表达式OC 有4个基本数据类型：int, float, double, char。概念同C++一样5个限定词：long, long long, short, unsigned, signed。概念同 C++ 一样 下面来说几个特殊的类型： BOOL 类型概念同 C++ 一样，但是预定义的真假值与 C++ 不同： Language 真 假 Objective-C YES NO C++ true false id 类型id类型是 OC 里一个比较特殊的类型。概念上与 void 类型很像，但是他们两个有很大区别。在内部处理上，这种类型被定义为 指向对象的指针，实际上是一个 *指向这种对象的实例变量的指针 下面是 id 在 Objc.h 中的定义： 1234567/// Represents an instance of a class.struct objc_object &#123; class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 从上面看出，id是指向struct objc_object的一个指针。也就是说，id是指向任何一个继承了Object（或者NSObject）类的对象。需要注意的是，id是一个指针，所以在使用的时候不需要加星号（*）。 SEL 类型在 Objective-C 中，SEL 是选择器的一个类型。我们可以将 SEL 理解为函数指针，但他们之间并非完全一样。 nil 类型与 C++ 中 null 概念一样，是是对 nill 操作不会有任何作用，C++ 中对 null 操作会异常。 基础数据类型表： 类型 实例 NSLog 字符 char ‘a’、’\n’ %c short int - %hi、%hx、%ho unsigned short int - %hu、%hx、%ho int 12、-97、0xFFE0、0177 %i、%x、%o unsigned int 12u、100U、0XFFu %u、%x、%o long int 12L、-200l、0xffffL %li、%lx、%lo unsigned long int 12UL、100ul、0xffeeUL %lu、%lx、%lo long long int 0xe5e5e5e5LL、0xffeeUL %lli、%llx、%llo unsigned long long int 12ull、0xffeeULL %llu、%llx、%llo float 12.34f、3.1e-5f、0x1.5p10、0x1P-1 %f、%e、%g、%a double 12.34、3.1e-5、0x.1p3 %f、%e、%g、%a long double 12.34L、3.1e-5l %Lf、%Le、%Lg id nil %p 基本算术运算符概念同 C++ 一样 循环结构和选择结构同C++11一样，for循环有两种：普通for循环，快速for循环 123456789101112// 第一种遍历：普通 for 循环long int count = [array count];for (int i = 0; i &lt; count; ++i) &#123; NSLog(@"1 遍历 array：%zi -&gt; %@", i, [array objectAtIndex:i]);&#125;// 第二种遍历：快速 for 循环int i = 0;for (id obj in array) &#123; NSLog(@"2 遍历 array：%zi -&gt; %@", i, obj); ++i;&#125; 其他的 while，do…while，break，continue 都同 C++ 一致选择结构，if，if…else…，switch同 C++ 一致 类合成存取方法12345678910111213141516171819202122232425262728293031323334353637@interface Fraction : NSObject@property int numerator, denominator;- (void) print;- (double) convertToNum;@ end@Implementation Fraction@synthesize numerator, denominator;- (void) print &#123; NSLog(@"%i / %i", numerator, denominator);&#125;- (double) convertToNum &#123; if (denominator != 0) &#123; return (double) numerator / denominator; &#125; else &#123; return NAN; &#125;&#125;@ endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *objFraction = [Fraction new]; [objFraction setNumerator:1]; [objFraction setDenominator:2]; [objFraction print]; &#125; return 0;&#125; 从OC 2.0开始，可自动生成设值方法和取值方法。第一步是在接口部分中使用@property指令标识属性。第二步是在实现部分中使用@synthesize 如果使用了@property指令，就不需要再实现部分声明相应的实例变量。 当然，你并不需要使用@synthesize指令，使用@property指令编译器也会自动为你生成setter和getter。但是要注意，如果你不使用@sythesize，那么编译器生成的实例变量会以下画线（_）字符作为其名称的第一个字符。 访问属性访问属性有两种格式：Instance.property = value; 等价为 [Instance setProperty: value]; 继承123456789101112131415161718192021222324@interface ClassA : NSObject &#123; int x;&#125;- (void) initVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;@end@interface ClassB : ClassA- (void) printVar;@end@implementation ClassB- (void) printVar &#123; NSLog(@"x = %i", x);&#125;@end 在这段代码里面，ClassA继承于NSObject，ClassB继承于ClassA。语法同C++差不多。但是有一点要注意：OC只能是单继承，而C++可以多继承。 继承的概念作用于整个继承链。 @class 指令例如 @class XYPoint;在头文件声明中，告诉编译器XYPoint是一个类的名字。而不需要 #import 导入整个 XYPoint.h在C++中相当于 class XYPoint; 处理动态类型的方法： 方法 问题或行为 -(BOOL) isKindOfClass: class-object 对象是不是 class-object 或其子类的成员 -(BOOL) isMemberOfClass: class-object 对象是不是 class-object 的成员 -(BOOL) respondsToSelector: Selector 对象是否能够相应 selector 所指定的方法 -(BOOL) instancesRespondToSelector: Selector 指定的类实例是否能够响应 selector -(BOOL) isSubclassOfClass: class-object 对象是否是指定类的子类 -(id) performSelector: selector 应用 selector 指定的方法 -(id) performSelector: selector withObject: object 应用 selector 指定的方法，传递参数 object -(id) performSelector: selector withObject: object1 withObject: object2 应用 selector 指定的方法，传递参数 object1 和 object2 多态在OC里面的多态与C++有些不一样。在OC里面，不同类的相同方法名即为多态。而在C++里面就不一样咯。C++里面的多态是通过继承来实现的。 举个最简单的例子： Objective-C 12345678910111213141516171819202122232425262728293031323334353637383940@interface ClassA : NSObject &#123; int x;&#125;- (void) intVar;- (void) printVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;- (void) printVar &#123; NSLog(@"x = %i", x)&#125;@end@interface ClassB : ClassA- (void) initVar;@end@implementation ClassB- (void) initVar &#123; x = 200;&#125;@endint main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; ClassA *myClassA = [ClassB new]; [myClassA initVar]; [myClassA printVar]; &#125; return 0;&#125; C++ 1234567891011121314151617181920212223242526272829303132333435class ClassA&#123;protected: int x;public: void initVar() &#123; x = 100; &#125; void printVar() &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;&#125;;class ClassB : public ClassA&#123;public: void initVar() &#123; x = 200; &#125;&#125;int main(int argc, const char *argv[])&#123; ClassA *myClassA = new ClassB(); myClassA-&gt;initVar(); myClassA-&gt;printVar(); getchar(); return 0;&#125; C++ 输出的结果是100而OC输出的结果是200，OC是真的覆盖… 另外，OC不支持运算符重载… 异常处理@try、@catch、@throw、@finally这些概念同C一样。 分类和协议分类在Objective-C的设计中，一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示，改进代码的一种主要方法即为将其分解为更小的片段。Objective-C借用并扩展了Smalltalk实现中的“分类”概念，用以帮助达到分解代码的目的。 分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。 举个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Integer.h#import &lt;objc/Object.h&gt;@interface Integer : Object &#123;@private int integer;&#125;@property (assign, nonatomic) integer;@end// Integer.m#import "Integer.h"@implementation Integer@synthesize integer;@end// Arithmetic.h#import "Integer.h"@interface Integer(Arithmetic)- (id) add: (Integer *) addend;- (id) sub: (Integer *) subtrahend;@end// Arithmetic.m#import "Arithmetic.h"@implementation Integer(Arithmetic)- (id) add: (Integer *) addend &#123; self.integer = self.integer + addend.integer; return self;&#125;- (id) sub: (Integer *) subtrahend &#123; self.integer = self.integer - subtrahend.integer; return self;&#125;@end// Display.h#import "Integer.h"@interface Integer(Display)- (id) showstars;- (id) showint;@end// Display.m#import "Display.h"@implementation Integer(Display)- (id) showstars &#123; int i, x = self.integer; for (i = 0; i &lt; x; ++i) printf("*"); printf("\n"); return self;&#125;- (id) showint &#123; printf("%d\n", self.integer); return self;&#125;@end// main.m#import "Integer.h"#import "Arithmetic.h"#import "Display.h"int main (void) &#123; Integer *num1 = [Integer new], *num2 = [Integer new]; int x; printf("Enter an integer: "); scanf("%d", &amp;x); num1.integer = x; [num1 showstars]; printf("Enter an integer: "); scanf("%d", &amp;x); num2.integer = x; [num2 showstars]; [num1 add:num2]; [num1 showint]; return 0;&#125; 类的扩展有一种特殊的情况是创建一个未命名的分类，且在括号“（）”之间不指定名字。这种特殊的语法定义称为类的扩展。定义一个像这样命名的分类时，可以通过定义额外的实例变量和属性来扩展类，这在有命名的分类中是不允许的。未命名分类中声明的方法需要在主实现区域实现，而不是在分离的实现区域中实现。未命名的分类是非常有用的，因为他们的方法都是私有的。如果需要写一个类，而且数据和方法仅供这个类本身使用，未命名分类比较合适。 通过使用分类添加新方法来扩展类不仅会影响这个类，同时也会影响他的所有子类。 协议协议是一组没有实现的方法列表，任何的类均可采纳协议并具体实现这组方法。协议列出了一组方法，有些可以是选择实现，有些是必须实现。定义一个协议很简单：只要使用@protocol指令，后面跟上你给出的协议名称。然后和处理接口部分一样，声明一些方法。@end指令之前的所有方法声明都是协议的一部分。在@optional指令之后列出的所有方法都是可选的。 个人感觉类似于C++的虚基类… 举个栗子：1234@protocol Printable@optional - (void) print:(NSString)str;@end 加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。 12@interface class MyClass : NSObject &lt;Printable, Drawable&gt;@end 一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。 可以使用conformsToProtocol:方法检查一个对象是否遵循某项协议。 12345id currentObject;...if ([currentObject conformsToProtocol: @protocol (Drawable)] == YES) &#123; ...&#125; 这里使用的专用@protocol指令用于获取一个协议名称，并产生一个protocol对象，conformsToProtocol: 方法期望这个对象作为它的参数。 为了测试一个对象是否实现了可选的print方法，可以编写下列代码： 123if ([currentObject respondsToSelector: @selector (print)] == YES) &#123; [currentObject print];&#125; 通过在类型名称之后的尖括号中添加协议名称，借助编译器来检查变量的一致性：id &lt;Drawable&gt; currentObject; 块概念上，匿名函数，lambda，closure（或OC中的blocks）是一个东西。详见：浅析匿名函数、lambda表达式、闭包（closure）区别与作用 块是以插入字符 ^ 开头为标识的。后面跟的一个括号表示块所需要的参数列表。同样，也可以将这个块赋给一个变量。举个栗子： 123456789...__block int foo = 10;void (^printFoo)(void) = ^(void) &#123; foo = 20; NSLog(@"foo = %i", foo); &#125;;printFoo(); 如果要试图在块内部改变变量的值，需要在定义本地变量之前插入 __block 修改器。 数字、字符串和集合在Foundation框架包括大量的类、方法和函数。可以通过这条代码来导入：#import &lt;Foundation/Foundation.h&gt; 里面的东西就相当于C++的标准库似的。使用的时候看看文档就好了。 数字对象NSNumber类包含多个方法，可以使用初始值创建NSNumber对象。 NSNumber 的创建方法和检索方法： 创建和初始化方法 初始化实例方法 检索实例方法 numberWithChar; initWithChar; charValue numberWithUnsignedChar; initWithUnsignedChar; unsignedCharValue numberWithShort; initWithShort; shortValue numberWithUnsignedShort; initWithUnsignedShort; unsignedShortValue numberWithInteger; initWithInteger; integerValue numberWithUnsignedInteger; initWithUnsignedInteger; unsignedIntegerValue numberWithInt; initWithInt; intValue numberWithUnsignedInt; initWithUnsignedInt; unsignedIntValue numberWithLong; initWithLong; longValue numberWithUnsignedLong; initWithUnsignedLong; unsignedLongValue numberWithLongLong; initWithLongLong; longLongValue numberWithUnsignedLongLong; initWithUnsignedLongLong; unsignedLongLongValue numberWithFloat; initWithFloat; floatValue numberWithDouble; initWithDouble; doubleValue numberWithBool; initWithBool; boolValue OC是允许通过@表达式创建数字对象的。 举栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Foundation/Foundation.h&gt;int main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSNumber *myNumber, *floatNumber, *intNumber; NSInteger myInt; // integer 整值 intNumber = [NSNumber numberWithInteger: 100]; myInt = [intNumber integerValue]; NSLog(@"%li", (long)myInt); // long 整值 myNumber = [NSNumber numberWithLong: 0xabcdef]; NSLog(@"%lx", [myNumber longValue]); // char 整值 myNumber = [NSNumber numberWithChar: 'X']; NSLog(@"%c", [myNumber charValue]); // float 整值 floatNumber = [NSNumber numberWithFloat: 100.00]; NSLog(@"%g", [floatNumber floatValue]); // double myNumber = [NSNumber numberWithDouble: 12345e+15]; NSLog(@"%lg", [myNumber doubleValue]); // 发生错误 NSLog(@"%li", (long)[myNumber integerValue]); // 验证两个 Number 是否相等 if ([intNumber isEqualToNumber: floatNumber] == YES) NSLog(@"Numbers are equal"); &#125;&#125; 字符串对象@”Hello World!” 就是一个字符串对象。即NSString类的对象。特殊情况下，它属于NSConstantString类的常量字符串对象。NSConstantString类是字符串对象NSString类的子类 description 方法可以使用格式化字符%@显示数组、字典和集合的全部内容。事实上，通过覆盖集成的description方法，还可以使用这些格式字符显示你自己的类对象。如果不覆盖方法，NSLog仅仅显示类名和该对象在内存中的地址，这是从NSObject类继承的description方法的默认实现。 举个栗子： 1234567891011121314151617181920212223242526@interface Fraction : NSObject@ property int numberator, denominator;- (void) setNumerator: (int)numerator andDenominator: (int) denominator;- (NSString *) description;@end@implementation Fraction- (void) setNumerator: (int)numerator andDenominator: (int)denominator &#123; self.numerator = numerator; self.denominator = denominator;&#125;- (NSString *) description &#123; return [NSString stringWithFormat:@"%i/%i", self.numerator, self.denominator];&#125;@endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f = [Fraction new]; [f setNumerator:1 andDenominator:2]; NSLog(@"%@", f); &#125; return 0;&#125; 结果：2016-06-28 16:26:08.873 Learn[18105:485920] 1/2 可变对象与不可变对象@”Hello World!”创建字符串对象时，会创建一个内容不可更改的对象，称为不可变对象，可以使用NSString类处理不可变字符串。若要需要经常处理字符串并更改字符串中的字符，可以使用NSMutableString类处理 数组对象可变数组：NSArray不可变数组：NSMutableArray 挺简单的…使用的时候看看文档就行了.. 这里就说一下排序：利用NSArray数组排序的方法很容易实现。这里以NSMutableArray为例子：在NSMutableArray类中sortUsingSelegtor: 的方法很容易实现。举个栗子: 1234567- (NSComparisonResult) compareNames: (id) element &#123; return [name compare: [element name]];&#125;- (void) sort &#123; [book sortUsingSelector: @selector (compareNames)];&#125; sortUsingSelector: 方法会使用selector比较两个元素。由于数组可以包含任何类型的对象，所以要实现一般的排序方法，唯一途径就是由你来判断数组中的元素是否有序，为此，你必须添加一个方法比较数组中的两个元素。 这个方法返回的结果是NSComparisonResult类型的值。如果希望排序方法将第一个元素放在第二个元素之前，那么方法的返回值应是NSOrderedAscending。如果认为这两个元素相等，那么返回NSOrderedSame。如果排序后的数组中，第一个元素应该在第二个元素之后，那么返回NSOrderedDescending。 也阔以使用块排序：SortUsingComparator: (NSComparator) block;NSComparator 作为typedef定义在系统头文件中：Typedef NSComparisonResult (^NSComparator) (id obje1, id obj2);NSComparator 是一个区块，使用两个对象作为参数，并返回NSComparisonResult类型的值。 123456- (void) sort &#123; [book SortUsingComparator: ^(id obj1, id obj2) &#123; return [[obj1 name] compare: [obj2 name]]; &#125;];&#125; NSValue 类像数组这样的Foundation集合只能存储对象，而有些类型是源于C语言的一种数据类型，比如结构，它不是对象。我们可以利用 NSValue 把结构包装（wrapping）成对象。逆向的处理是从对象中解出基本类型，简称展开（unwrapping）。 NSValue 包装和展开方法 Typedef 数据类型 描述 包装方法 展开方法 CGPoint x 和 y 值组成的点 valueWithPoint; pointValue CGSize 宽和高组成的尺寸 valueWithSize; sizeValue CGRect 矩形包含原点和尺寸 valueWithRect; rectValue NSRange 描述位置和大小的范围 valueWithRange; rangeValue 词典对象词典是由键-对象对儿组成的数据集合。概念和C++里面的std::map一样。词典中的键必须是单值的，通常他们是字符串，但也可以是其他对象类型，和键关联的值可以使任何对象类型，但不能是nil。 不可变字典：NSDictionary可变字典：NSMutableDictionary [NSMutableDictionary dictionary]; 创建一个空字典 其他也挺简单的，使用上也和map差不多。看看文档就好了~ 集合对象set是一组单值对象集合，它可以是可变的，也可以是不可变的。操作包括：搜索、添加、删除集合中的成员（仅可变集合），比较两个集合，计算两个集合的交集和并集等。 也是和C++里面的std::set差不多 Foundation框架同样提供了一个名为NSCountedSet的类，这种集合同一对象可以出现多次，然而并非在集合众存在多次这个对象，而是维护一个计数值。 使用文件管理文件和目录：NSFileManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSDictionary *attr; NSError *err; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@"File doesn't exist!"); return 1; &#125; // 创建一个副本 // 这里要注意下比较坑，如果同名文件存在，是会copy失败的 // 而且返回的失败信息是 testfile 文件不存在.... if ([fm copyItemAtPath: fName toPath: @"newfile" error: &amp;err] == NO) &#123; NSLog(@"File Copy failed!, %@", err); return 2; &#125; // 测试两个文件是否一致 if ([fm contentsEqualAtPath: fName andPath: @"newfile"] == NO) &#123; NSLog(@"Files are not equal!") return 3; &#125; // 重命名副本 if ([fm moveItemAtPath:@"newfile" toPath:@"newfile2" error:&amp;err] == NO) &#123; NSLog(@"File rename failed"); return 4; &#125; // 获取 newfile2 的大小 if ((attr = [fm attributesOfItemAtPath:@"newfile2" error:&amp;err]) == nil) &#123; NSLog(@"Couldn't get file attributes!"); return 5; &#125; NSLog(@"File size is %llu bytes", [[attr objectForKey:NSFileSize] unsignedLongLongValue]); // 最后删除原始文件 if ([fm removeItemAtPath:fName error:&amp;err] == NO) &#123; NSLog(@"file removal failed"); return 6; &#125; NSLog(@"All operations were successful"); // 显示新创建的文件内容 NSLog(@"%@", [NSString stringWithContentsOfFile:@"newfile2" encoding:NSUTF8StringEncoding error:&amp;err]); &#125; return 0;&#125; 使用 NSData 类使用文件时，需要频繁的将数据读入到一个缓冲区，Foundation的NSData类提供了一种简单的方式，它用来设置缓冲区，将文件的内容读入缓冲区，或将缓冲区的内容写到一个文件。据说，据说哈，32位应用的NSData缓冲区最多可存储2G的数据。64位的最多可存储8EB的数据… 举例子： 1234567891011121314151617181920212223242526272829303132333435int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSData *fileData; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@"File doesn't exist!"); return 1; &#125; // 读取文件 fileData = [fm contentsAtPath:fName]; if (fileData == nil) &#123; NSLog(@"File read failed!"); return 2; &#125; // 将数据写入 newfile3 if ([fm createFileAtPath:@"newfile3" contents:fileData attributes:nil] == NO) &#123; NSLog(@"couldn't create the copy!"); return 3; &#125; NSLog(@"File copy was successful!"); &#125; return 0;&#125; 枚举目录中的内容123456789101112131415161718192021222324252627282930int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSDirectoryEnumerator *dirEnum; NSArray *dirArray; // 把短路径转换成全路径 fName = [fName stringByExpandingTildeInPath]; fm = [NSFileManager defaultManager]; dirEnum = [fm enumeratorAtPath:path]; NSLog(@"contents of %@", path); while ((path = [dirEnum nextObject]) != nil) &#123; NSLog(@"%@", path); &#125; NSLog(@"-----------------------------------"); // 另一种遍历方法 dirArray = [fm contentsOfDirectoryAtPath:[fm currentDirectoryPath] error:NULL]; NSLog(@"contents using contentsOfDirectoryAtPath:error:"); for (path in dirArray) &#123; NSLog(@"%@", path); &#125; &#125; return 0;&#125; 这两种枚举技术的不同在于：enumeratorAtPath: 方法列出了目录中的内容，包含子目录contentsOfDirectoryAtPath:error: 方法不会列出子目录内容 使用路径：NSPathUtilities.h123456789101112131415161718192021222324252627282930313233343536int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"path.m"; NSFileManager *fm= [NSFileManager defaultManager]; NSString *path, *tempdir, *extension, *homedir, *fullpath; NSArray *components; // 获取临时目录 tempdir = NSTemporaryDirectory(); NSLog(@"tempoary directory is %@", tempdir); // 从当前目录中提取基本目录 path = [fm currentDirectoryPath]; NSLog(@"Base dir is %@", [path lastPathComponent]); // 创建 fName 在当前目录的完整路径 fullpath = [path stringByAppendingPathComponent:fName]; NSLog(@"fullpath to %@ is %@", fName, fullpath); // 获取文件扩展名 extension = [fullpath pathExtension]; NSLog(@"extension for %@ is %@", fullpath, extension); // 获取用户主目录 homedir = NSHomeDirectory(); NSLog(@"Your home directory is %@", homedir); // 拆分路径为各个组成部分 components = [homedir pathComponents]; for (path in components) &#123; NSLog(@"%@", path); &#125; &#125; return 0;&#125; Foundation框架的NSSearchPathForDirectoriesInDomains 函数，用于获取系统的特殊目录，如 Application 和 Documents 目录。 12NSArray *dirList = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docDir = dirList[0]; 例子就是获取一个Documents目录。函数的第二个参数可以是多个值，用于指定需要列出的目录，如用户的，系统的或者所有目录。最后一个参数用于指定是否展开路径中的~字符 NSSearchPathForDirectoriesInDomains返回一组路径的数组，如果仅是查找用户的目录，这个数组只包含一个元素，如果第二个参数指定多个值，该数组会包含多个元素。 当为Ios编写程序时，NSSearchPathForDirectoriesInDomains函数第二个参数应是NSUserDoMainMask,并希望得到一个包含单个路径的数组作为返回。 常用的 iOS 目录 目录 用途 Documents (NSDocumentDirectory) 用于写入应用相关数据文件的目录。在 iOS 中写入这里的文件能够与 iTunes 共享并访问，存储在这里的文件会自动备份到 iCloud Library/Caches (NSCachesDirectory) 用于写入应用支持文件的目录，保存应用程序再次启动需要的信息。iTunes 不会对这个目录的内容进行备份 tmp (use NSTemporaryDirectory()) 这个目录用于存放临时文件，在程序终止时需要移除这些文件。当应用程序不再需要这些临时文件时，应该将其从这个目录删除 Library/Preferences 这个目录包含应用程序的偏好设置文件。使用 NSUserDefaults 类进行偏好设置文件的创建、读取和修改 使用 NSProcessInfo 类NSProcessInfo 类方法 方法 描述 +(NSProcessInfo *) processInfo 返回当前进程信息 -(NSArray *) arguments 以 NSString 对象数组的形式返回当前进程参数 -(NSDictionary *) environment 返回变量/值对字典，以描述当前的环境变量，比如 PATH 和 HOME 及其值 -(int) processIdentifier 返回进程标识符，它是操作系统赋予进程的唯一数字，用于标识每个正在运行的进程 -(NSString *) processName 返回当前正在执行的进程名称 -(NSString *) globallyUniqueString 每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名 -(NSString *) hostname 返回主机系统名称 -(NSUInteger) operationsSystem 返回表示操作系统的数字 -(NSString *) operationsSystemName 返回操作系统名称 -(NSString *) operationsSystemVersionString 返回操作系统的当前版本 -(void) setProcessName: (NSString *) name 将当前进程名称设置为 name，应该谨慎的使用这个方法，因为关于进程名称存在一些假设，比如用户默认设置 深拷贝，实现 协议如果我们要实现深拷贝，就要根据协议实现其中一两个方法。实现协议是，类必须实现copyWithZone: 方法来响应copy消息（这条copy消息仅将一条带有nil参数的copyWithZone:消息发送给你的类）。如果要想区分可变不可变副本，还要根据协议实现mutableCopyWithZone: 方法。产生对象的可变副本并不要求被复制的对象本身也是可变的（反之亦然）。 举例子： 1234567891011121314151617181920212223242526272829...- (id) copyWithZone: (NSZone* ) zone &#123; // 如果类产生子类，那么这个方法将被继承 // 这种情况下，应该使用 [self class] // 即从该类分配一个新对象，而不是 copy 的接收者 Fraction *newFract = [[[self class] allocWithZone: zone] init]; [newFract setTo: numerator over: denominator]; return newFract;&#125;...int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f1 = [Fraction new]; Fraction *f2; [f1 setTo:2 over:5]; f2 = [f1 copy]; [f2 setTo:1 over:3]; [f1 print]; [f2 print]; &#125; return 0;&#125; Cocoa 和 Cocoa Touch 简介Cocoa 是一种为Mac OS X应用程序提供了丰富用户体验的框架，实际上由3个框架组成：Foundation框架、便于使用数据库存储和管理数据的Core Data框架，以及Application Kit (AppKit)框架。AppKit 框架提供了与窗口、按钮、列表等相关的类。 框架层 内核以设备驱动程序的形式提供与硬件的底层通信。它负责管理系统资源，包括调度需要执行的程序、管理内存和电源，以及执行基本的I/O操作。 核心服务提供的支持比它上面层次更加底层或更加“核心”。例如提供对集合、网络、调试、文件管理、文件夹、内存管理、线程、时间和电源的管理。 应用层包含打印和图形渲染的支持，包括Quartz、OpenGL、和 Quicktime。 Cocoa层位于应用程序层之下。Cocoa包括Foundation、Core Data 和 AppKit框架。Foundation框架提供处理集合、字符串、内存管理、文件系统、存档等相关的类。AppKit框架提供管理视图、窗口、文档和多用户界面相关的类。 Cocoa TouchCocoa框架应用于Mac OS X桌面与笔记本电脑应用程序的开发，而Cocoa Touch框架应用于iOS设备上应用程序的开发。 Cocoa 和 Cocoa Touch 都有 Foundation 和 Core Data 框架。然而在Cocoa Touch下，UIKit代替了AppKit框架。提供了很多相同类型对象的自持。比如窗口、视图、按钮、文本域等。另外Cocoa Touch 还提供使用陀螺仪和加速器的类和触摸式界面。去掉了不需要的类。 引用参考 《Objective-C程序设计，第六版》《Objective-C维基百科》《iOS开发60分钟入门》]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改 Bash on Ubuntu on Windows 的默认 shell]]></title>
    <url>%2FStaticBlog%2F2016%2FChange-the-WSL-default-shell%2F</url>
    <content type="text"><![CDATA[引用参考 How to Use Zsh (or Another Shell) in Windows 10 这里以 zsh 为例： vim ~/.bashrc 添加如下内容到 #for examples 注释下面，并保存 1234# Launch Zshif [ -t 1 ]; thenexec zshfi 退出bash，到cmd，重新bash进入]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挖坑——开发计划]]></title>
    <url>%2FStaticBlog%2F2016%2Fdev-plan%2F</url>
    <content type="text"><![CDATA[先给自己挖坑，以后慢慢填…不定期更新和补充… KSTL——内核版STL 重载 new / delete 标准类型重定义 Allocator function bind iterators 和 Traits vector list deque、stack、queue heap、pripority queue tuple 红黑树 set、multiset map、multimap hashtable hashset、hashmap string R0 &lt;-&gt; R3 通讯框架 minifilter 框架 object 相关框架 WFP 框架 Intel-VT 框架 AMD-SVM 框架 …]]></content>
      <categories>
        <category>Plan</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016 阅读书单]]></title>
    <url>%2FStaticBlog%2F2016%2F2016-books%2F</url>
    <content type="text"><![CDATA[这里记录的都是我2016年阅读的书籍，但是各种未成书的文档就不在这里记录了… 技术类 《深入理解C++11：C++11新特性解析与应用》 [读完]2016.04 适合有C++基础上，学习C++11的新特性。这本书系统的讲解了C++11新标准中的所有语言新特性、新标准库特性、对原有特性的改进，以及如何应用这些新特性。 《Objective-C程序设计6》 [读完]2016.06 本来公司需要iOS，可是学完就改了需求，不需要了….三天即可看完..了解下与C++之间的区别，超级简单.. 《iOS开发指南：从零基础到AppStore上架3》 [读完]2016.06 也是iOS学习一系列的..4天看完，能够走一遍iOS基本开发流程…另外，学习iOS建议好好看一遍官方文档.. 《图解HTTP》 [读完]2016.07 为了写爬虫学的..半天就看完，非常简单。能够了解HTTP基本概念和规范，适合初学了解。 《Python Cookbook3》 [读完]2016.08 非常实用的一本书，里面讲了各种问题场景的解决方案，实乃编码必备好书。在写Python的时候遇到的很多问题都是在这里找到的方案。 《编写高质量代码：改善Python程序的91个建议》 [读完]2016.08 作为有强迫症的人，一定要看..教你如何写更 Pythonic 的代码，另外还建议阅读 PEP8 《C++并发编程实战》 [在读]2016.09 听说，翻译的不好。所以建议读英文版。或者GitBook有第三方翻译的版本。这本书是基于 C++11 新标准的并发和原子库的内容。可以学习新标准库的使用，以及在使用过程中需要注意的地方。这是一本神书.. 《STL 源码剖析》 [在读]2016.09 虽然书听老的，但是里面的设计思想不会过时，不会影响对 STL 的理解。我看这本书主要就是因为前两天挖的坑..写一套 内核版STL..干巴得~ 非技术类 《三体》 [读完]2016.01 非常好看的一套硬科幻小说，里面涉及到很多物理、历史、数学、哲学的知识，而且许多概念都让我细思极恐..比如黑暗森林。 《上帝在掷骰子吗：量子物理史话》 [读完]2016.05 非常好看的科普类书籍，尤其是对于我这种没上过学而又对物理数学感兴趣的人。这本书能够让你了解物理学的发展历史，里面有很多有趣的物理概念。 《从0到1：开启商业与未来的秘密》 [读完]2016.03 看忘了… 《人类简史：从动物到上帝》 [在读]2016.04 这不是一本简单的历史书，作者从不同的视角来审视人类发展的过程，以及人类所产生的影响，不止如此，里面还有很多很多有趣的东西，非常值得阅读！ 《北京折叠》 [未读]~ 仅仅看了一段话，就让我非常想阅读它.. 未来的穷人连被剥削的价值都没有]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Writing Solid Python Code》 Notes]]></title>
    <url>%2FStaticBlog%2F2016%2FLanguage%2FWriting-Solid-Python-Code-Notes%2F</url>
    <content type="text"><![CDATA[《编写高质量代码：改善 Python 程序的 91 个建议》 学习笔记之前自己学了很多次 Python，由于用不到，所以总是学完就忘掉了。刚好最近工作需要用到 Python，就借此机会好好学习了一番。Pyhton 的各种特性和风格让我甚是喜欢。不过我总是感觉自己写的代码不是那么漂亮，不够 Pythonic。所以我想通过学习一些经典建议来让我有个思路。 建议 1：理解 Pythonic 概念对于 Pythonic 的概念，大家心中的指南就是 Tim Peters 的 《The Zen of Python》（Python 之禅）。下面几点来自其中的内容： 美胜丑，显胜隐，简胜杂，平胜陡，疏胜密。 找到简单问题的一个方法，最好是唯一的方法（正确的解决之道）。 难以解释的实现，源自不好的主意；如有非常棒的主意，它的实现肯定易于解释。 代码风格建议参考 PEP8 和 Python 风格指南比如： 包和模块的命名采用小写、单数形式，而且短小。 包通常仅作为命名空间，如只包含空的 __init__.py 文件 建议 2：编写 Pythonic 代码 要避免劣化代码 避免只用大小写来区分不同的对象 避免使用容易引起混淆的名称比如，重复使用已经存在于上下文中的变量名来表示不同的类型；误用了内建名称来表示其他含义的名称而使之在当前命名空间被屏蔽；没有构建新的数据类型的情况下使用类似于 element、list、dict等作为变量名；使用o、l、等作为变量名。 不要害怕过长的变量名，可读性更重要 深入认识 Python 有助于编写 Pythonic 代码 全面掌握 Python 提供给我们的所有特性，包括语言特性和库特性。 学习每个 Python 新版本提供的新特性，使用 Python 推荐的惯用法来完成任务 深入学习业界公认的比较 Pythonic 的代码，比如 Flask、gevent 和 requests 等。 使用工具来达到检查和约束，比如我个人使用 Pycharm IDE 来写 Python，对代码风格的要求挺严格的… 建议 3：理解 Python 与 C 语言的不同之处我们都知道，Python 底层是用 C 语言实现的，但切忌用 C 语言的思维和风格来编写 Python 代码。尤其重要的是，不要使用之前的编程思想。 “缩进”与“{}”与 C、C++、Java 等语言使用花括号来分隔代码段不同，Python 中使用严格的代码缩进方式分隔代码块。另外，建议 Tab 替换成 4 个空格，不要混用 Tab 键和空格。 ‘ 与 “C 语言中单引号 &#39; 与双引号 &quot; 由严格的区别，单引号代表一个字符，它实际对应于编译器所采用的字符集中的一个整数值。而双引号则表示字符串，默认以 \0 结尾。但是在 Python 中，单引号与双引号没有明显区别。 三元操作符 “?:”三元操作符是 if…else 的简写方法，语法形式为 C ? X: Y，而在 Python 中的等价形式为 X if C else Y switch…casePython 中没有像 C 语言那样的 switch…case 分支语句。不过在 Python 中有很多替代的解决方法： C1234567891011121314switch(n) &#123; case 0: printf("You typed zero.\n"); break; case 1: printf("You are in top.\n"); break; case 2: printf("n is an even number.\n"); break; default: printf("Only single-digit numbers are allowed.\n"); break;&#125; Python12345678if n == 0: print("You typed zero.")elif n == 1: print("You are in top.")elif n == 2: print("n is an even number.")else: print("Only single-digit numbers are allowed.) 或者123456def f(n): return &#123; 0: "You typed zero.", 1: "You are in top.", 2: "n is an even number." &#125;.get(n, "Only single-digit numbers are allowed.") Python 和其他语言的差异远不止这些。但总归一句话：不要被其他语言的思维和习惯困扰，掌握 Python 的这些和思维方式才是硬道理。 建议 4：在代码中适当添加注释Python 中有三种形式的代码注释：块注释、行注释以及文档注释（docstring）。这三种注释的惯用法大概如下几种： 使用块或行注释的时候仅仅注释那些复杂的操作、算法，还有可能别人难以理解的技巧或者不够一目了然地代码。 注释和代码隔开一定的距离，同时在块注释之后最好多留几行空白再写代码。 给外部可访问的函数和方法添加文档注释，无论简单与否。注释要清楚地描述方法的功能，并对参数、返回值以及可能发生的异常进行说明，使得外部调用它的人员仅仅看docstring就能正确使用。较为复杂的内部方法也需要进行注释。 推荐在文件头中包含 copyright 申明、模块描述等，如有比较可以考虑加入作者信息及变更记录。 建议 5：通过适当添加空行使代码布局更为优雅、合理Python 代码布局也有一些基本规则可以遵循（PEP8 中有详细规范..）： 在一组代码表达完一个完整的思路之后，应该用空白行进行间隔。如每个函数之间，导入声明、变量赋值等。 尽量保持上下文语义的易理解性 避免过长的代码行，每行最好不要超过 80 字符。 不要为了保持水平对其而使用多余的空格 （写C/C++就有这习惯…） 空格的使用要能够在需要强调的时候竟是读者，在疏松关系的实体间起到分隔作用。 二元运算符、布尔运算的左右两边应该有空格 逗号和分号前不要使用空格 函数名和左括号之间、序列索引操作时序列名和 [] 之间不需要空格，函数的默认参数两侧不需要空格。 强调前面的操作符的时候使用空格 建议 6：编写函数的 4 个原则 原则 1 函数设计要尽量短小，嵌套层次不宜过深。 原则 2 函数申明应该做到合理、简单、易于使用。 原则 3 函数参数设计应该考虑向下兼容。 原则 4 一个函数只做一件事儿，尽量保证函数语句粒度的一致性。 Python 中函数设计的好习惯还包括：不要再函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。 建议 7：将常量集中到一个文件Python 中使用常量一般有以下两种方式： 通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下划线连接各个单词，如 MAX_OVERFLOW，这只是一种约定俗成的风格。 通过自定义的类实现常量功能。这要求符合“命名全部为大写”和“值一旦绑定便不可再修改”这两个条件。12345678910111213class _const: class ConstError(TypeError): pass class ConstCaseError(ConstError): pass def __setattr__(self, name, value): if self.__dict__.has_key(name): raise self.ConstError, "Can't change const.&#123;&#125;".format(name) if not name.isupper(): raise self.ConstCaseError, 'const name "&#123;&#125;" is not all uppercase'.format(name) self.__dict__[name] = valueimport syssys.modules[__name__] = _const() 如果上面的代码对应的模块名为 const，使用的时候只需要 import const，便可直接定义常量了，如下代码：12import constconst.COMPANY = "IBM" 建议 8：利用 assert 语句来发现问题断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便的检查程序的异常或者发现不恰当的输入等，可防止意想不到的情况出现。 对 Python 中使用断言需要说明如下： debug 的值默认设置为 True，而且是只读的。 断言是有性能影响的。Python 可以在运行脚本时通过 -O 标识来禁用断言。比如 Python -O test.py 断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此食用断言需要注意以下几点： 不要滥用，这是使用断言最基本的原则。 如果 Python 本身的异常能够处理就不要再使用断言。断言没有明确的异常类型。 不要使用断言来检查用户的输入。 在函数调用后，当需要确认返回值是否合理时可以使用断言。 当条件是业务逻辑继续下去的先决条件时可以使用断言。 建议 9：数据交换值得时候不推荐使用中间变量建议 10：充分利用 Lazy evaluation 的特性Lazy evaluation 常被译为“延迟计算”或“惰性计算”，值得是仅仅在真正需要执行的时候才会计算表达式的值。充分利用 Lazy evaluation 的特性带来的好处有两个方面： 避免不必要的计算，带来性能上的提升。 节省空间，使得无限循环的数据结构成为可能。 建议 11：理解枚举替代实现的缺陷在 Python 3.4 之前，并没有提供枚举类型。所以人们充分利用 Python 的dong’tai动态性这个特征，行除了美剧的各种替代实现： 使用类属性 12class Seasons: Spring, Summer, Autumn, Winter = range(4) 借助函数 12def enum(*posarg, **keysarg): return type("Enum", (object,), dict(zip(posarg, xrange(len(posarg))), **keysarg)) 使用 collections.nametuple 1Seasons = namedtuple(&apos;Seasons&apos;, &apos;Spring Summer Autumn Winter&apos;)._make(range(4)) 但是这些替代有其不合理的地方： 允许枚举值重复 支持无意义的操作，比如相加 在3.4之后，加入了枚举 Enum，其实现主要参考 flufl.enum，但两者之间存在一些差别。 建议 12：不推荐使用 type 来进行类型检查基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。任意泪的实例的 type() 返回结果都是 &lt;type &#39;instance&#39;&gt;。我们可以使用 isinstance() 函数来检测类型。 建议 13：尽量转换为浮点类型后再做除法建议 14：警惕 eval() 的安全漏洞Python 中 eval() 函数将字符串 str 当初有效的表达式来求值并返回计算结果。其函数声明如下：eval(expression[, globals[, locals]])其中参数 globals 为字典形式，locals 为任何映射对象，他们分别表示全局和局部命名空间。如果传入 globals 参数的字典中缺少 __builtins__ 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。locals 参数默认与 globals 相同，如果两者都省略的话，表达式将在 eval() 调用的环境中执行。 如果使用对象不是信任源，应该尽量避免使用 eval，在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。 建议 15：使用 enumerate() 获取序列迭代的索引和值建议 16：分清 == 与 is 的适用场景 操作符 意义 is object identity == equal is 表示的是对象标识符 (object identity)，而 == 表示的意思是相等。is 的作用是用来检查对象的标识符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间。== 才是用来检验两个对象的值是否相等的，它实际调用内部 __eq__() 方法。 建议 17：考虑兼容性，尽可能使用 Unicode建议 18：构建合理的包层次来管理 module什么是包？简单说包即是目录，但是与目录不同，它除了包含常规的 Python 文件以外，还包含一个 __init__.py 文件，同时它允许嵌套。包有以下几种导入方法： 直接导入一个包import Package 导入子模块或子包，包嵌套的情况下可以进行嵌套导入12from Package import Module1import Package.Module1 包的使用能够带来以下便利： 合理组织代码，便于维护和使用 能够有效的避免命名空间冲突 建议 19：有节制的使用 from…import 语句在使用 import 的时候注意以下几点： 一般情况下尽量优先使用 import a 形式 有节制地使用 from a import B 形式，可以直接访问 B 尽量避免使用 from a import *，因为这会污染命名空间，并且无法清晰的表示导入了哪些对象 当加载一个模块的时候，解释器实际上要完成以下动作： 在 sys.modules 中进行搜索看看模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。 如果在 sys.modules 中找不到对应的模块名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入 sys.modules 中。 加载钱确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。 对于 from…import 无节制的使用会带来什么问题： 命名空间的冲突 循环嵌套导入的问题 建议 20：优先使用 absolute import 来导入模块建议 21：i+=1 不等于 ++iPython 中是不支持概念中 ++i 操作的。但是如果你这么写，会被 Python 解释成 +(+i)，其中 + 表示正号 建议 22：使用 with 自动关闭资源with 语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有 with 语句的代码块的执行过程如下： 计算表达式的值，返回一个上下文管理器对象。 加载上下文管理器对象的 __exit__() 方法以备后用 调用上下文管理器对象的 __enter__() 方法 如果 with 语句中设置了目标对象，则将 __enter__() 方法的返回值赋值给目标对象 执行 with 中的代码块 如果步骤5中代码正常结束，调用上下文管理器的 __exit__() 方法，其返回值直接忽略。 如果步骤5中代码执行过程中发生异常，调用上下文管理器的 __exit__() 方法，并将异常类型、值及 traceback 信息作为参数传递给 __exit__() 方法。如果 __exit__() 返回值为 False，则异常会重新抛出；如果其返回值为 True，异常被挂起，程序继续执行。 建议 23：使用 else 子句简化循环（异常处理）建议 24：遵循异常处理的几点基本原则 注意异常的粒度，不推荐在 try 中放入过多的代码。 谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。 注意异常捕获的顺序，在合适的层次处理异常。推荐的方法是将继承结构中子类异常在前面的 except 语句中抛出，而父类异常在后面的 except 语句中抛出。 使用更为友好的异常信息，遵循异常参数的规范。 建议 25：避免 finally 中可能发生的陷阱在实际应用程序开发过程中，并不推荐在 finally 中使用 return 语句或 break 进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。 建议 26：深入理解 None，正确判断对象是否为空Python 中以下数据会当作空来处理： 常量 None 常量 Flase 任何形式的数值类型零，如0、0L、0.0、0j 空的序列，如 ‘’、()、[] 空的字典，如 {} 当用户定义的类中定义了 nonzero() 方法和 len() 方法，并且该方法返回整数0或者布尔值 False 的时候。 其中常量 None 的特殊性体现在它既不是0、False，也不是空字符串，他就是一个空值对象。其数据类型为 NoneType，遵循单例模式，是唯一的，因而不能创建 None 对象。所有赋值为 None 的变量都相等，并且 None 与任何其他非 None 的对象比较结果都为 False 错误的比较12345test_list = []if test_list is not None: print('list is:', test_list)else: print('list is empty') 正确的比较12345test_list = []if test_list: print('list is:', test_list)else: print('list is empty') 建议 27：连接字符串应优先使用 join 而不是 +jion 的效率要高于 + 操作符jion 的时间复杂度为O(n), + 的时间复杂度为 O(n^2) 建议 28：格式化字符串时尽量使用 .format 方式而不是 %% 操作符格式化字符串时有如下几种用法： 直接格式化字符或者数值 1print('your score is %06.1f' % 9.5) 以元组的形式格式化 12import mathprint('the %s of a circle with radius %f is %0.3f' %('circumference', 3, math.pi*radius*2)) 以字典的形式格式化 12itemdict = &#123;'itemname': 'circumference', 'radius': 3, 'value': math.pi*radius*2&#125;print('the %(itemname)s of a circle with radius %(radius)f is %(value)0.3f' % itemdict) .format 方式格式化字符串的基本语法为：[[填充符] 对齐方式][符号][#][0][宽度][,][.精确度][转换类型]其中填充符可以是除了 { 和 } 符号之外的任意符号。 对其方式 解释 &lt; 表示左对其，是大多数对象为默认的对其方式 &gt; 表示右对其，数值默认的对其方式 = 仅对数值类型有效，如果有符号的话，在符号后数值前进行填充，如-0029 ^ 居中对其，用空格进行填充 符号 解释 + 正数前加 +，负数前加 - - 正数前不加符号，负数前加 -，为数值的默认形式 空格 正数前加空格，负数前加 - .format 常用用法： 使用位置符号 使用名称 通过属性 123456789101112class Customer(object): def __init__(self, name, gender, phone): self.name = name self.gender = gender self.phone = phone def __str__(self): # 通过 str() 函数返回格式化的结果 return 'Customer(&#123;self.name&#125;,&#123;self.gender&#125;,&#123;self.phone&#125;)'.format(self=self)str(Customer('Lisa', 'Female', '67889'))'Customer(Lisa, Female, 67889)' 格式化元组的具体项 1234point = (1,3)'X:&#123;0[0]&#125;;Y:&#123;0[1]&#125;'.format(point)'X:1;Y:3' 使用 .format 的理由： format 方式在使用上较 % 操作符更为灵活 format 方式可以方便的作为参数传递 % 最终会被 .format 方式所替代 % 方法在某些情况下使用时需要特别小心 建议 29：区别对待可变对象和不可变对象数字、字符串、元组属于不可变对象字典、列表、字节数组属于可变对象 看一个经典例子：1234567891011121314151617181920212223242526272829303132class Student(object): def __init__(self, name, coures=[]): self.name = name self.course = coures def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item)def main(): stu_a = Student('Wang yi') stu_a.add_course('English') stu_a.add_course('Math') print(stu_a.name + "'s course:") stu_a.print_course() print('----------------------------') stu_b = Student('Li san') stu_b.add_course('Chinese') stu_b.add_course('Physics') print(stu_b.name + "'s course:") stu_b.print_course()if __name__ == '__main__': main() 结果123456789101112C:\Users\MeeSong\AppData\Local\Programs\Python\Python35\python.exe C:/Users/MeeSong/Desktop/test/test.pyWang yi's course:EnglishMath----------------------------Li san's course:EnglishMathChinesePhysicsProcess finished with exit code 0 看到没，结果与预想的并不一样。我们通过 id(stu_a.course) 和 id(stu_b.course) (id 是查看对象的内存标识的，即内存地址) 发现两个结果是一样的，说明两个list对象指的是同一块地址。但 stu_a 和 stu_b 本身却是两个不同的对象。在实例化两个对象的时候，这两个对象被分配了不同的内存空间，并且调用 init() 函数进行了初始化。但由于 init() 函数的第二个参数是个默认参数，默认桉树在函数被调用的时候仅仅被评估一次，以后都会使用第一次评估的结果，因此实际上对象空间里面 course 所指向的是同一个list地址。 我们改成这样就好了123456789101112class Student(object): def __init__(self, name, coures=None): self.name = name self.course = coures if coures else [] def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item) 另外，切片操作相当于浅拷贝。 12345678910111213&gt;&gt;&gt; b['a', 'b', 'c', 'd']&gt;&gt;&gt; a['a', 'b', 'c', 'd']&gt;&gt;&gt; id(a[0])2279905391312&gt;&gt;&gt; id(b[0])2279905391312&gt;&gt;&gt; id(a)2279910237896&gt;&gt;&gt; id(b)2279910245384 对于不可变对象，当我们对其进行相关操作的时候，Python 实际上仍然保持原来的值，并重新创建一个新的对象。比如字符串操作 12345678&gt;&gt;&gt; s1 = '123'&gt;&gt;&gt; s2 = s1&gt;&gt;&gt; id(s2)2279910241368&gt;&gt;&gt; id(s1)2279910241368&gt;&gt;&gt; id(s1[:1])2279905395408 建议 30：[]、() 和 {}：一致的容器初始化形式建议使用列表解析来初始化，即列表推导式（或元组和字典）列表推导式的语法为：[expr for iter_item in iterable if cond_expr]元组推导式的语法为：(expr for iter_item in iterable if cond_expr)集合推导式的语法为：{expr for iter_item in iterable if cond_expr}字典推导式的语法为：{exprk:exprv for iter_item in iterable if cond_expr} 12&gt;&gt;&gt; [v**2 if v%2 == 0 else v+1 for v in [2,3,4,-1] if v&gt;0][4, 4, 16] 列表推导式非常灵活： 支持多重嵌套 支持多重迭代 列表推导式的语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至是函数 列表推导式语法中的iterable可以是任意可迭代对象 为什么推荐俺在需要生成列表的时候使用列表推导式呢？ 使用列表推导式更为直观清晰，代码更为简洁 列表推导式的效率更高 建议 31：记住函数传参既不是传值也不是传引用先看两张图 对于在Python函数参数是传值还是传引用这个问题：正确叫法应该是传对象或者说传对象的引用。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象， 由于并不能真正被修改，因此修改往往是通过生成一个新对象然后赋值来实现的 建议 32： 警惕默认参数潜在的问题这个问题同 建议 29：区别对待可变对象和不可变对象 的例子 建议 33：慎用变长参数Python 支持可变长度的参数列表，可以通过在函数定义的时候使用 args 和 *kwargs 这两个特殊语法来实现。 使用 args 来实现可变参数列表： args 用于接收一个包装为元组形式的参数列表来传递非关键字参数，参数个数可以任意。 使用 **kwargs 接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变参数的参数名和值 为什么要慎用可变长度参数呢： 使用过于灵活 如果一个函数的参数列表很长，虽然可以通过使用 args 和 *kwargs 来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。 可变长参数适合在下列情况下使用： 为函数添加一个装饰器 如果参数的数目不确定，可以考虑使用变长参数 用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候 建议 34：深入理解 str() 和 repr() 的区别函数 str() 和 repr() 都可以将 Python 中的对象转换为字符串，他们的使用及输出都非常相似 区别主要有以下几点： 两者之间的目标不同：str() 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型;而 repr() 面向的是Python解释器，或者说开发人员，其目的是准确性，返回值表示 Python 解释器内部的含义，常作为编程人员 debug 用途 在解释器中输入a时，默认调用 repr() 函数，而 print(a) 则调用 str() 函数 repr() 的返回值一般可以用 eval() 函数来还原对象，通常来说有这个等式：obj == eval(repr(obj)) 这两个方法分别调用内建的 __str__() 和 __repr__() 方法，一般来说在类中都应该定义 __repr__() 方法，而 __str__() 方法则为可选，当可读性比准确性更重要的时候应该考虑定义 __str__() 方法。如果类中没有定义 __str__() 方法，则默认会使用 __repr__() 方法的结果来返回对象的字符串形式。用户实现 __repr__() 方法的时候最好保证其返回值可以用 eval() 方法使对象重新还原 建议 35：分清 staticmenthod 和 classmethod 的适用场景静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数 类方法能够根据不同的类型返回对应的类的实例既不跟特定的实例相关，也不跟特定的类相关的时候，用静态方法更合适 建议 36：掌握字符串的基本用法小技巧Python 遇到未闭合的小括号时会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接到一起。12345&gt;&gt;&gt; s = ('SELECT * '... 'FROM atable '... 'WHERE afield="value"')&gt;&gt;&gt; print(s)SELECT * FROM atable WHERE afield="value" 性质判定 方法 描述 isalnum() 是否只是数字或字母 isalpha() 是否字母 isdigit() 是否数字 islower() 是否小写 isupper() 是否大写 isspace() 是否空白符 istitle() 是否标题化的，即每个单词首字母是否大写 startswith(prefix[,start[,end]]) 是否以prefix开头，可范围内检查，prefix可接受tuple类型的实参 endswith(suffix[,start[,end]]) 是否以suffix结尾，可范围内检查，suffix可接收tuple类型的实参 查找 方法 描述 count(sub[,start[,end]]) 查找sub在字符串中出现的次数，这个数值在调用replace方法时用得着 find(sub[,start[,end]]) 查找sub在字符串中的位置，找不到时返回-1 index(sub[,start[,end]]) 同find，不过找不到会抛出 ValueError 异常，另外对于是否包含字串，更推荐使用 in 和 not in 操作符 rfind(sub[,start[,end]]) 同find，从右侧开始 rindex(sub[,start[,end]]) 同index，从右侧开始 替换 方法 描述 replace(old, new[,count]) 把字符串中的old替换为new，count为最多替换次数 translate(table[,deletechars]) 根据table转换字符串的字符，可以由string.maketrans(frm,to)生成；deletechars为过滤掉的字符 分切 方法 描述 partition(sep) 它接受一个字符串参数，并返回一个3个元素的 tuple 对象。如果sep没出现在母串中，返回值是 (sep, ‘’, ‘’)；否则，返回值的第一个元素是 sep 左端的部分，第二个元素是 sep 自身，第三个元素是 sep 右端的部分。 rpartition(sep) splitlines([keepends]) split([sep [,maxsplit]]) 参数 maxsplit 是分切的次数，即最大的分切次数，所以返回值最多有 maxsplit+1 个元素。 rsplit([sep[,maxsplit]]) 不过有一个需要注意的地方对于字符串s、s.split() 和 s.split(‘ ‘) 返回值是不同的1234&gt;&gt;&gt; ' hello world!'.split()['hello', 'world!']&gt;&gt;&gt; ' hello world!'.split(' ')['', 'hello', '', 'world!'] 产生差异的原因在于当忽略 sep 参数或sep参数为 None 时与明确给 sep 赋予字符串值时 split() 采用两种不同的算法。对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串（即连续的空白符串被当作单一的空白符看待）；对于后者则认为两个连续的 sep 之间存在一个空字符串。 连接join() 函数的高效率（相对于循环相加而言），使它成为最值得关注的字符串方法之一。它的功用是将可迭代的字符串序列连接成一条长字符串，如： 123456&gt;&gt;&gt; conf = &#123;'host':'127.0.0.1',... 'db':'spam',... 'user':'sa',... 'passwd':'eggs'&#125;&gt;&gt;&gt; ';'.join("%s=%s"%(k, v) for k, v in conf.iteritems())'passswd=eggs;db=spam;user=sa;host=127.0.0.1' 变形 方法 描述 lower() 转小写 upper() 转大写 capitalize() 把字符串的第一个字符大写 swapcase() 翻转 string 中的大小写 title() 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写 title()函数是比较特别的，它的功能是将每一个单词的首字母大写，并将单词中的非首字母转换为小写（英文文章的标题通常是这种格式）。 12&gt;&gt;&gt; 'hello world!'.title()'Hello World!' 因为title() 函数并不去除字符串两端的空白符也不会把连续的空白符替换为一个空格，所以建议使用string 模块中的capwords(s)函数，它能够去除两端的空白符，再将连续的空白符用一个空格代替。 1234&gt;&gt;&gt; ' hello world!'.title()' Hello World!'&gt;&gt;&gt; string.capwords(' hello world!')'Hello World!' 删减 方法 描述 strip([chars]) 在 string 上执行 lstrip()和 rstrip() lstrip([chars]) 截掉 string 左边的空格 rstrip([chars]) 删除 string 字符串末尾的空格. *strip()函数族用以去除字符串两端的空白符，空白符由string.whitespace常量定义。 填充 方法 描述 center(width[, fillchar]) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串， fillchar 参数指定了用以填充的字符，默认为空格 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 rjust(width[, fillchar]) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 expandtabs([tabsize]) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 编码 方法 描述 encode([encoding[,errors]]) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ decode([encoding[,errors]]) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ 建议 37：按需选择 sort() 或者 sorted()sorted(iterable[, cmp[, key[, reverse]]])s.sort([cmp[, key[, reverse]]]) cmp 为用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable或者list），函数根据第一个参数与第二个参数的关系依次返回 -1、0、+1（第一个参数小于第二个参数则返回负数）。该参数默认值为None。 key 是带一个参数的函数，用来为每个元素提取比较值，默认为None（即直接比较每个元素） reverse 表示结果是否反转 sort() 与 sorted() 之间的比较： 相比于 sort()，sorted() 使用范围更为广泛 当排序对象为列表的时候两者适合的场景不同。sorted() 函数会返回一个排序后的立标，原有列表保持不变；而 sort() 函数会直接修改原有列表，函数返回为 None 无论是 sort() 还是 sorted() 函数，传入参数 key 比传入参数 cmp 效率要高。 sorted() 函数功能非常强大，使用它可以方便的针对不同的数据结构进行排序，从而满足不同需求。对于 itemgetter 的使用，参见 python operator.itemgetter函数与sorted的妙用 对字典进行排序 12345&gt;&gt;&gt; phonebook = &#123;'Linda':'7750', 'Bob':'9345', 'Carol':'5834'&#125;&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted_pb = sorted(phonebook.items(), key=itemgetter(1))&gt;&gt;&gt; sorted_pb[('Carol', '5834'), ('Linda', '7750'), ('Bob', '9345')] 多维 list 排序 1234&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; gameresult = [['Bob', 95.00, 'A'], ['Alan', 86.0, 'C'], ['Mandy', 82.5, 'A'], ['Rob', 86, 'E']]&gt;&gt;&gt; sorted(gameresult, key=itemgetter(2,1))[['Mandy', 82.5, 'A'], ['Bob', 95.0, 'A'], ['Alan', 86.0, 'C'], ['Rob', 86, 'E']] 字典中混合 list 排序 12345678910mydict = &#123;'Li': ['M', 7], 'Zhang': ['E', 2], 'Wang': ['p', 3], 'Du': ['c', 2], 'Ma': ['c', 9], 'Zhe': ['H', 7]&#125;print(sorted(mydict.items(), key=lambda item: itemgetter(1)(itemgetter(1)(item))))[('Zhang', ['E', 2]), ('Du', ['c', 2]), ('Wang', ['p', 3]), ('Li', ['M', 7]), ('Zhe', ['H', 7]), ('Ma', ['c', 9])] list 中混合字典排序 1234567gameresult = [&#123;'name': 'Bob', 'wins': 10, 'losses': 3, 'rating': 75.00&#125;, &#123;'name': 'David', 'wins':3, 'losses': 5, 'rating': 57.00&#125;, &#123;'name': 'Carol', 'wins':4, 'losses': 5, 'rating': 57.00&#125;]print(sorted(gameresult, key=itemgetter('rating', 'name')))[&#123;'wins': 4, 'name': 'Carol', 'losses': 5, 'rating': 57.0&#125;, &#123;'wins': 3, 'name': 'David', 'losses': 5, 'rating': 57.0&#125;, &#123;'wins': 10, 'name': 'Bob', 'losses': 3, 'rating': 75.0&#125;] 建议 38： 使用 copy 模块进行深拷贝对象概念： 浅拷贝（shallow copy）：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式与多种，如工厂函数、切片操作、copy模块中的copy操作。 深拷贝（deep copy）：也是构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。 建议 39：使用 Counter 进行计数统计Counter 类是自 Python2.7 起增加的，属于字典的子类，是一个容器对象，主要用来统计散列对象。 建议 40：深入掌握 ConfigParser建议 41：使用 argparse 处理命令行参数另外，还有更先进好用的 docopt，不过暂时还没加入标准库。详见 docopt 建议 42：使用 pandas 处理大型 CSV 文件CSV(Comma Separated Values) 作为一种逗号分隔符型值的纯文本格式文件，在实际应用中经常用到，如数据库的导入导出、数据分析中记录的存储等。 CSV 处理相关 API： ‘reader(csvfile[, dialect=’excel’][, fmtparam])’，主要用于 CSV 文件的读取，返回一个 reader 对象用于在 CSV 文件内容上进行行迭代 ‘csv.writer(csvfile, dialect=’excel’, **fmtparams)’，用于写入 CSV 文件。 ‘csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect=’excel’, args, *kwds)’，将读入的信息映射到一个字典中去 ‘csv.DictWrite(csvfile, fieldnames, restval=’’, extrasaction=’raise’, dialect=’excel’, args, *kwds)’，用于支持字典的写入。 但是在处理大型 CSV 文件，上面API会抛出 MemoryError 异常。 Pandas 即 Python Data Analysis Library，是为了解决数据分析而创建的第三方工具，支持多种文件格式处理，包括 CSV、HDF5、HTML 等，能够提供高效的大型数据处理。 Series：它是一种类似数据的带索引的一维数据结构，支持的类型与 NumPy 兼容。 DataFrame：类似于电子表格，其数据为排好序的数据列的集合，每一列都可以是不同的数据类型，它类似于一个二维数据结构，支持行和列的索引。 建议 43：一般情况使用 ElementTree 解析 XML 使用简单 内存上消耗明显低于 DOM 解析。 支持 XPath 查询 建议 44：理解模块 pickle 优劣pickle 估计是最通用的序列化模块了，它还有个 C 语言的实现 cPickle，相比 pickle 来说具有较好的性能，其速度大概是 pickle 的 1000 倍，除了不能被继承之外，它们两者的使用基本上区别不大 pickle 中最主要的两个函数对儿为 dump() 和 load()，分别来进行对象的序列化和反序列化： pickle.dump(obj, file[, protocol])：序列化数据到一个文件描述符。 pickle.load(file)：表示把文件中的对象恢复为原来的对象。 pickle 模块的优点： 接口简单，容易使用 pickle 的存储格式具有通用性，能够被不同平台的 Python 解析器共享 支持的数据类型广泛 pickle 模块是可扩展的 能够自动维护对象间的引用，如果一个对象上存在多个引用，pickle 后不会改变对象间的引用 pickle 模块的限制： pickle 不能保证操作的原子性 pickle 存在安全性问题 pickle 协议是 Python 特性的，不同语言之间的兼容性难以保证 建议 45：序列化的另一个不错的选择——JSON相比 pickle，JSON 具有以下优势： 使用简单，支持多种数据类型，仅存在以下两大数据结构： 名称 / 值 对儿的集合 （dict） 值的有序列表 （list） 存储格式可读性更为友好，容易修改。 JSON 支持跨平台跨语言 具有较强的扩展性，JSON 模块还提供了编码（JSONEncoder）和解码类（JSONDecoder），以便用户对其默认不支持的序列化类型进行扩展 建议 46：使用 traceback 获取栈信息常用方法： traceback.print_exception(type, value, traceback[, limit[, file]])，根据 limit 的设置打印栈信息，file 为 None 的情况下定位到 sys.stderr，否则写入到文件；其中 type、value、traceback 这3个参数对应的值可以从 sys.exc_info() 中获取 traceback.print_exc(limit[, file])，为 print_exception 函数的缩写，不需要传入 type、value、traceback 这三个参数 traceback.format_exc([limit])，与 print_exc() 类似，区别在于返回形式为字符串 traceback.extract_stack([file[, limit]])，从当前栈帧中提取 trace 信息。 建议 47：使用 logging 记录日志信息使用见 Python的日志系统 建议 48：使用 threading 模块编写多线程程序实际应用中推荐使用 threading 模块而不是 thread 模块： threading 模块对同步原语的支持更为完善和丰富 threading 模块在主线程和子线程交互上更为友好 thread 模块不支持守护线程 python3 中已经不存在 thread 模块 使用见 Python中使用线程的技巧 建议 49：使用 Queue 使多线程编程更安全建议 50：利用模块实现单例模式建议 51：用 mixin 模式让程序更加灵活建议 52：用发布订阅模式实现松耦合建议 53：用状态模式美化代码建议 54：理解 built-in objectsPython 一切皆对象。自 Python2.2 之后，为了弥补内建类型和古典类之间的鸿沟，引入了新式类。新式类中，object 是所有内建类型的积累，用户定义的类可以继承自 object 也可继承自内建类型。 这里的鸿沟指的是：在 2.2 版本之前，类和类型并不统一，如 a 是古典类 ClassA 的一个实例，那么 a.__class__ 返回 &#39;class__main__ClassA&#39;，type(a) 返回 &lt;type&#39;instalce&#39;&gt;。当引入新类后，比如 ClassB 是个新类，b 是 ClassB 的实例，b.class 和 type(b) 都是返回 &#39;class__main__.ClassB&#39; 新式类相对于古典类来说有很多优势：能够基于内建类型构建新的用户类型，支持 property 和描述符特性等。 建议 55：__init__() 不是构造方法实际上 __init__() 并不是真正意义上的构造方法，__init__()方法所做的工作是在类的对象创建好之后进行变量的初始化。__new__()方法才会真正创建实例，是类的构方法。 两个方法之间的不同点，总结如下： object.__new__(cls[, args...])：其中 cls 代表类，args 为参数列表 object.__init__(self[, args...])：其中 self 代表实例对象，args 为参数列表 __new__() 方法是静态方法，__init__() 为实例方法 __new__() 方法一般需要返回类的对象，当返回类的对象时将会自动调用 __init__() 方法进行初始化，如果没有对象返回，则 __init__() 方法不会被调用。 __init__() 方法不需要显式返回，默认为 None，否则会在运行时抛出 TypeError 当需要控制实例创建的时候可使用 __new__() 方法，而控制实例初始化的时候用 __init__() 方法 一般情况下不需要覆盖 __new__() 方法，但当子类继承自不可变类型，如 str、int、unicode 或者 tuple 的时候，往往需要覆盖该方法。 当需要覆盖 __new__() 和 __init__() 方法的时候这两个方法的参数必须保持一致，如果不一致将会导致异常。 什么特殊情况下需要覆盖 __new__() 方法呢？ 当类继承不可变类型且默认的 __new__() 方法不能满足需求的时候。 用来实现工厂模式或者单例模式或者进行元类便哼的时候 作为用来初始化的 __init__() 方法在多继承的情况下，子类的 __init__() 方法如果不显式调用父类的 __init__() 方法，则父类的 __init__() 方法不会被调用。 建议 56：理解名字查找机制在 Python 中，所有所谓的变量其实都是名字，这些名字指向一个或者多个 Python 对象。 Python 中有 4 中作用域： 局部作用域：一般来说函数的每次调用都会创建一个新的本地作用于，拥有新的命名空间。 全局作用域：定义在Python模块文件中的变量名拥有全局作用域，需要注意的是这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量必须先导入文件对应的模块 嵌套作用域：一般在多重函数嵌套的情况下才会考虑到，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用 global 进行声明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。 内置作用域：通过一个标准库名为 __builtin__ 的模块来实现的。 Python 的名字查找机制如下： 在最内层范围内查找，一般而言就是函数内部，即在 locals() 里面查找 在模块内查找，即在 globals() 里面查找 在外层查找，即在内置模块中查找，也就是在 __builtin__ 中查找 若要修改全局变量，在 Python3 中可以使用 nonlocal 来声明变量 建议 57：为什么需要 self 参数 Python 在当初设计的时候借鉴了其他语言的一些特征，如 Moudla-3 中方法会显示的在参数列表中传入 self。 Python 语言本身的动态性决定了使用 self 能够带来一定便利。 在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分 建议 58：理解 MRO 与多继承建议 59：理解描述符机制建议 60：区别 __getattr__() 和 __getattribute__() 方法__getattr__() 和 __getattribute__() 都可以用作实例属性的获取和拦截（仅对实例属性）__getattr__() 适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在__getattribute__() 对于所有属性的访问都会调用该方法，仅应用于新式类 覆盖这些方法时，几点注意事项： 避免无穷递归。例如：12345def __getattribute__(self, attr): try: return self.__dict__[attr] except KeyError: return 'default' 属性的访问调用的是覆盖的 __getattribute__() 方法，而该方法中 self.__dict__[attr] 又要调用 __getattribute__(self, attr)，于是产生了无穷递归。正确方法是使用 super(obj, self).__getattribute__(attr)。 访问未定义的属性。如果在 __getattribute__() 方法中不抛出 AttributeError 异常或者显示返回一个值，则会返回 None，此时可能会影响到程序的实际运行预期 覆盖了 __getattribute__() 方法之后，任何属性的访问都会调用用户定义的 __getattribute__() 方法，性能上会有损耗 覆盖的 __getattr__() 方法如果能够动态处理事先未定义的属性，可以更好的实现数据隐藏。 __getattribute__() 总是会被调用，而 __getattr__() 只有在 __getattribute__() 中引发异常的情况下才会被调用。 建议 61：使用更为安全的 propertyproperty 是用来实现属性可管理性的 built-in 数据类型，其实质是一种特殊的数据描述符。它和普通描述符的区别在于：普通描述符提供的是一种较为低级的控制属性访问的机制，而 property 是它的高级应用，它以标准库的形式提供描述符的实现，其签名形式为：property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute property 的优势可以简单概括为以下几点： 代码更简洁，可读性更强。 更好的管理属性的访问 代码可维护性更好 控制属性访问权限，提高数据安全性 建议 62：掌握 metaclass什么是元类？ 元类是关于类的类，是类的模板 元类是用来控制如何创建类的，正如类是创建对象的模板一样 元类的实例为类，正如类的实例为对象 元类需要注意的几点： 区别类方法与元方法 多继承需要严格限制，否则会产生冲突 元类用来指导类的生成，元方法可以从元类或者类中调用，不能从类的实例中调用，而类方法既可以从类中调用，也可以从类的实例中调用。 建议 63： 熟悉 Python 对象协议 用以比较大小的协议，这个协议依赖于 __cmp__() 方法，相等返回0，小于返回负值，大于返回正值。还有其他诸如 __eq__()、__ne__()、__lt__()、__gt__() 等方法来实现相等、不等、小于和大于的判定。这也就是 Python 对 ==、!=、&lt; 和 &gt; 等操作符的进行重载的支撑机制 数值类型相关的协议 分类 方法 操作符 / 函数 说明 数值运算符 __add__ + 加 __sub__ - 减 __mul__ * 乘 __div__ / 除 __floordiv__ // 整除 __truediv__ / 真除法，当 __future__.division 起作用时调用，否则调用 __div__ __pow__ ** 幂运算 __mod__ % 模运算 __divmod__ divmod() 余、除 位运算符 __lshift__ &lt;&lt; 向左移位 __rshift__ &gt;&gt; 向右移位 __and__ &amp; 与 __or__ or 那个符号 或 __xor__ ^ 异或 __invert__ ~ 非 运算赋值符 __iadd__ += __isub__ -= __imul__ *= __idiv__ /= __ifloordiv__ //= __itruediv__ /= __ipow__ **= __imod__ %= __ilshift__ &lt;&lt;= __irshift__ &gt;&gt;= __iand__ &amp;= __ior__ \ = __ixor__ ^= 其他 __pos__ + 正 __neg__ - 负 __abs__ abs() 绝对值 容器类型协议。__len__() 支持内置函数 len()__getitem__()、__setitem__()、__delitem__() 对应读、写、删除__iter__() 对应迭代器__reversed__() 支持内置函数 reversed()__contains__() 支持使用 in 和 not in 运算符 可调用对象协议 __call__() 与可调用对象差不多的，还有一个可哈希对象，他是用过 __hash__() 方法来支持 hash() 这个内置函数的 描述符协议和属性交互协议（__getattr__()、__setattr__()、__delattr__()） 上下文管理器协议这个协议通过 __enter__() 和 __exit__() 这两个方法来实现对资源的清理。 建议 64：利用操作符重载实现中缀语法可以安装 pipe 来实现 pip install pipe 建议 65：熟悉 Python 的迭代器协议迭代器协议归纳： 实现 __iter__() 方法，返回一个迭代器 实现 next() 方法，返回当前的元素，并指向下一个元素的为止，如果当前为止已无元素，则抛出 StopIteration 异常 建议 66：熟悉 Python 的生成器如果一个函数使用了 yield 语句，那么它就是一个生成器函数。每一个生成器函数调用之后，它的函数体并不执行，而是到第一次调用 next() 的时候才开始执行，执行到 yield 表达式为止。 建议 67：基于生成器的协程及 greenlet建议 68：理解 GIL 的局限性针对这种，不建议高密集的计算使用多线程，建议堵塞I/O的使用.. 建议 69：对象的管理与垃圾回收Python 使用引用计数器的方法来管理内存中的对象，即针对每一个对象维护一个引用计数值来表示该对象当前有多少个引用。引用计数算法最明显的缺点是无法解决循环引用的问题，即两个对象相互引用。 我们可以使用自带的 gc 模块来跟踪对象的 “入引用” 和 “出引用”。 建议 70：从 PyPi 安装包PyPi 全称 Python Package Index，直译过来就是 Python包索引，它是Python编程语言的软件仓库。 建议 71：使用 pip 和 yolk 安装、管理包建议 72：做 paster 创建包建议 73：理解单元测试概念单元测试带来以下好处： 减少了潜在 bug，提高了代码的质量。 大大缩减软件修复的成本。 为集成测试提供基本保障 有效的单元测试应该从以下几个方面考虑： 测试先行，遵循单元测试步骤。 创建测试计划 编写测试用例，准备测试数据 编写测试脚本 边界被测试代码，在代码完成之后执行测试脚本 修正代码缺陷，重新测试直到代码可接受为止。 遵循单元测试基本原则 一致性 原子性 单一职责 隔离性 使用单元测试框架 unittest。unittest 相关的概念主要有以下四个： 测试固件。测试相关的准备工作和清理工作，基于类 TestCase 差个内奸测试固件的时候通常需要重新实现 setUp() 和 tearDown() 方法。 测试用例。最小的测试单元，通常基于 TestCase 构建 测试用例集，测试用例的集合，使用 TestSuite 类来实现 测试运行器，控制和驱动整个单元测试过程，一般使用 TestRunner 类作为测试用例的基本执行环境，常用的运行器为 TextTestRunner，它是 TestRunner 的子类，以文字方式运行测试并报告结果。 建议 74：为包编写单元测试 nose建议 75：利用测试驱动开发提高代码的可测性测试驱动开发流程： 编写部分测试用例，并运行测试 如果测试用过，则回到测试用例编写的步骤，继续添加新的测试用例 如果测试失败，则修改代码直到测试通过 当所有测试用例编写完成并通过测试之后，再来考虑对代码进行重构 关于测试驱动开发和提高代码可测性方面有几点说明： TDD 只是手段而不是目的，因此在实践中尽量只验证正确的事情，并且每次仅仅验证一件事儿。 测试驱动开发本身就是一门学问，不要指望通过一个简单的例子就掌握其精髓。 代码的不可测性可以从以下几个方面考量：实践 TDD 困难；外部依赖太多；需要写很多模拟代码才能完成测试；职责太多导致功能模糊；内部状态过多且没有办法去操作和维护这些状态；函数没有明显返回或者参数过多；低内聚高耦合等等 建议 76：使用 Pylint 检查代码风格我使用 PyChrame 貌似内置..严格遵循 PEP8 标准 建议 77：进行高效的代码审查建议 78：将包发布到 PyPI建议 79：了解代码优化的基本原则 优先保证代码是可工作的 权衡优化的代价 定义性能指标，集中力量解决首要问题 不要忽略可读性 建议 80：借助性能优化工具例如 Pypy 建议 81：利用 cProfile 定位性能瓶颈cProfile 的统计结果及其各项意义 统计项 意义 ncalls 函数的被调用次数 tottime 函数总计运行时间，不含调用的函数运行时间 percall 函数运行一次的平均时间，等于 tottime/ncalls cumtime 函数总计运行时间，含调用的函数运行时间 percall 函数一次运行的平均时间，等于 cumtime/ncalls filename:lineno(function) 函数所在的文件名、函数行号、函数名 Stats 提供了对 cProfile 输出结果进行排序、输出控制等功能。 Stats 函数以及对应作用 函数 函数的作用 strip_dirs() 用以除去文件名前面的路径信息 add(filename[,…]) 把 profile 的输出文件加入 Stats 实例中统计 dump_stats(filename) 把 Stats 的统计结果保存到文件 sort_stats(key[,…]) 用以排序 Profile 的输出 reverse_order() 把 Stats 实例里的数据反序重排 print_stats([restriction, …]) 把 Stats 报表输出到 stdout print_callers([restriction, …]) 输出调用了指定的函数的相关信息 print_callees([restriction, …]) 输出指定的函数调用过的函数的相关信息 sort_stats 可接受参数列表 参数 意义 ncalls 被调用次数 cumulative 函数运行的总时间 file 文件名 module 模块名 pcalls 简单的调用统计 line 行号 name 函数名 nfl Name、file、line stdname 标准函数名 time 函数内部运行时间，不计调用子函数的时间 建议 82：使用 memory_profiler 和 objgraph 剖析内存使用建议 83：努力降低算法复杂度常见数据结构基本操作的时间复杂度 数据结构 操作 平均时间复杂度 最差时间复杂度 list 复制 O(n) O(n) 追加、取元素的值，给某个元素赋值 O(1) O(1) 插入、删除某个元素，迭代操作 O(n) O(n) 切片操作 O(k) O(k) set x in s O(1) O(n) 并 s or t O(len(s)+len(t)) 交 s&amp;t O(min(len(s), len(t))) O(len(s) * len(t)) 差 s-t O(len(s)) dict 获取修改元素的值，删除 O(1) O(n) 迭代操作 O(n) O(n) collections.deque 入列、出列、（包括左边出入列） O(1) O(n) 扩大队列 O(k) O(k) 删除元素 O(n) O(n) 建议 84：掌握循环优化的基本技巧 减少循环内部的计算 将显式循环改为隐式循环 在循环中尽量引用局部变量 关注内层嵌套循环 建议 85：使用生成器提高效率生成器的优点有如下几条： 生成器提供了一种更为便利的产生迭代器的方式，用户一般不需要自己实现 __iter__ 和 next 方法，它默认返回一个迭代器 代码更为简洁、优雅 充分利用了延迟评估的特性，仅在需要的时候才产生对应的元素，而不是一次生成所有的元素，从而节省了内存空间，提高效率 使得协程更为容易实现。（Python3.5 中引入了 async 和 wait 关键字） 建议 86：使用不同的数据结构优化性能建议 87：充分利用 set 的优势建议 88：使用 multiprocessing 克服 GIL 的缺陷Multiprocessing 模块在使用上需要注意以下几个要点： 进程之间的通信优先考虑 Pipe 和 Queue，而不是 Lock、Event、Condition、Semaphore 等同步原语 尽量避免资源共享。如果不可避免，可以通过 multiprocessing.Value 和 multiprocessing.Array 或者 multiprocessing.sharedctype 来实现内存共享。也可以通过服务器进程管理器 Manager() 来实现数据和状态的共享。 注意平台之间的差异。 尽量避免使用 terminate() 方式终止进程，并且确保 pool.map 中传入的参数是可以序列化的 建议 89：使用线程池提高效率建议 90：使用 C/C++ 模块扩展提高性能建议 91：使用 Cython 编写扩展模块]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http & http2 学习]]></title>
    <url>%2FStaticBlog%2F2016%2FNetwork%2Fhttp-http2-learn%2F</url>
    <content type="text"><![CDATA[HTTP 1.1Web 使用一种名为 HTTP(HyperText Transfer Protocol, 超文本传输协议/超文本转移协议)的协议作为规范，完成从客户端到服务端等一系列运作流程。TCP/IP 协议族 里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。 TCP/IP 协议族各层的作用如下： 应用层 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务，比如，FTP(File Transfer Protocol, 文件传输协议) 和 DNS(Domain Name System, 域名系统) 服务就是其中两类。 传输层 传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User ata Protocol) 用户数据报协议。 网络层 (又名网络互连层) 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径 (所谓的传输路线) 到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或万灵果设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层 (又名数据链路层，网络接口层) 用来处理链接网络的硬件部分。包括控制操作系统、硬件的设备驱动，NIC(Network Interface Card, 网络适配器，即网卡)，及光纤等物理可见部分 (还包括连接器等一切传输媒介)。硬件上的范畴均在链路层的作用范围之内。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把信息包装起来的做法称为封装 (encapsulate)。 详细学习见《TCP/IP 详解》 HTTP/1.0 和 HTTP/1.1 支持的方法 方法 说明 支持的 HTTP 协议版本 GET 获取资源 1.0、1.1 POST 传输实体主体 1.0、1.1 PUT 传输文件 1.0、1.1 HEAD 获得报文头部 1.0、1.1 DELETE 删除文件 1.0、1.1 OPTIONS 询问支持的方法 1.1 TRACE 追踪路径 1.1 CONNECT 要求用隧道协议连接代理 1.1 LINK 建立和资源之间的联系 1.0 UNLINK 断开连接关系 1.0 持久连接 HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。为了解决持久连接的问题，HTTP/1.1 和 一部分的 HTTP/1.0 相处了持久连接 (HTTP Persistent Connections, 也称为 HTTP keep-alive 或 HTTP connection reuse) 的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 HTTP 报文用于HTTP协议交互的信息被称为 HTTP 报文。请求端 (客户端) 的 HTTP 报文叫做请求报文，响应端 (服务器端) 的叫做响应报文。HTTP 报文本身是由多行 (用 CR+LF 作换行符) 数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两个由最初出现的空行来划分。通常并不一定有报文主体。 报文主体和实体主体 报文 (message)是 HTTP 通信中的基本单位，由 8 位组字节流 (octet sequence, 其中 octet 为 8 个bit) 组成，通过 HTTP 通信传输。 实体 (entity)作为请求或响应的有效载荷数据 (补充项) 被传输，其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 压缩传输的内容编码 常用的内容编码有以下几种： gzip (GNU zip) compress (UNIX 系统的标准压缩) deflate (zlib) identity (不进行编码) HTTP 状态码 状态码 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 2XX 成功 200 OK 204 No Content 206 Partial Content 3XX 重定向 301 Moved Permanently 302 Found 303 See Other 304 Not Modified虽然 304 被分在 3XX 类别中，但是和重定向没有关系。 4XX 客户端错误 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 5XX 服务器错误 500 Internal Server Error 503 Service Unavailable 状态码和状况的不一致 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。 HTTP 首部在请求中，HTTP 报文由方法、URL、HTTP 版本、HTTP 首部字段等部分构成。 在响应中，HTTP 报文由 HTTP 版本、状态码 (数字和原因短语)、HTTP 首部字段 3 部分构成。 HTTP 首部字段 HTTP 首部字段根据实际用途被分为以下4种类型： 通用首部字段 (General Header Fields)请求报文和响应报文两方都会使用的首部 请求首部字段 (Request Header Fields)从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段 (Response Header Fields)从服务端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段 (Entity Header Fields)针对请求报文和响应报文的额实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 通用首部字段 Cache-Control通过制定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。 Cache-Control 指令一览： 缓存请求指令 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必须 响应最大的 Age 值 max-stale( = [秒]) 可省略 接收已过期的响应 min-fresh = [秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记 (token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器缓存的响应有效性再进行确认 max-age = [秒] 必须 响应最大的 Age 值 s-maxage = [秒] 必须 公共缓存服务器响应的最大 Age 值 cache-extension - 新指令标记 (token) ConnectionConnection 首部字段具备如下两个作用： 控制不再转发给代理的首部字段 管理持久连接 Connection: UpgradeConnection: Keep-AliveConnection: close Date首部字段 Date 表明创建 HTTP 报文的日期和时间HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式Date: Tue, 03 Jul 2012 04:40:59 GMT PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。规范定义的形式唯一：Pragma: no-cache Trailer首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段，该字段可应用在 HTTP/1.1 版本分块传输编码时。 1234...Trailer: Expires...(报文主体)...Expires: Tue, 28 Sep 2004 23:59:59 GMT Transfer-Encoding首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 Upgrade首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议使用首部字段 Upgrade 时，需要额外指定 Connection: Upgrade对于富有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。 Via使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。 WarningHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部 (Retry-After) 演变过来的，该首部通常会告知用户一些与缓存相关的问题的警告。 Warning 首部的格式如下：Warning: [警告码] [警告的主机:端口号] &quot;[警告内容]&quot; ([日期时间]) HTTP/1.1 警告码 警告码 警告内容 说明 110 Response is stale (响应已过期) 代理返回已过期的资源 111 Revalidation failed (再次验证失败) 代理再验证资源有效性时失败 (服务器无法到达等原因) 112 Disconnection operation (断开连接操作) 代理与互联网连接被故意切断 113 Heuristic expiration (试探性过期) 响应的使用期超过24小时 (有效缓存设定时间大于24小时的情况下) 199 Miscellaneous warning (杂项警告) 任意的警告内容 214 Transformation applied (使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning (持久杂项警告) 任意的警告内容 请求首部字段 AcceptAccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。若想给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号进行分割。权重值 q 的范围是 0~1 可精确到小数点后3位，且1为最大值。不指定权重 q 值时，默认权重为 q=1.0。Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 Accept-CharsetAccept-Charset 首部字段可用来通知服务器用户代理支持的字符集，及字符集的相对优先顺序。另外可一次性指定多种字符集，与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。Accept-Charset: utf-8 Accept-EncodingAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。Accept-Encoding: gzip, deflate Accept-Language首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级，可一次指定多种自然语言集。Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3 Authorization首部字段 Authorization 是用来告知服务器，用户代理的认证信息 (证书值)。 Expect客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码 417 Expectation Failed。Expect: 100-continue From首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。 Host首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须包含在请求内的首部字段。Host: github.com If-Match形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记 (ETag) 值。 If-Modified-Since首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 If-None-Match首部字段 If-None-Match，属附带条件之一，它和 If-Match 相反。 If-Range首部字段 If-Range，属附带条件之一，它告知服务器若指定的 If-Range 字段值 (ETag 值或者时间) 和请求资源的 ETag 值或时间相一致时，则作为范围请求处理，反之则返回全体资源。 If-Unmodified-Since和 If-Modified-Since 相反 Max-Forwards通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以10进制整数形式指定可经过的服务器最大数目。 Proxy-Authorization接收到从代理服务器发送来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以便告知服务器认证所需的信息。 RangeRange: bytes=5001-10000对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。 RefererReferer: http://github.com/首部字段 Referer 会告知服务器请求的原始资源的URL会被用来爬虫和反爬虫… Referer的正确英语拼法是referrer。由于早期HTTP规范的拼写错误，为了保持向下兼容就将错就错了。其它网络技术的规范企图修正此问题，使用正确拼法，所以目前拼法不统一。 TE首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很像，但是用于传输编码TE: gzip 除了指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码方式。只需把 trailers 赋值给该字段值。TE: trailers User-Agent首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。爬虫要模拟浏览器就要添加该字段。 响应首部字段响应首部字段是由服务器向客户端返回相应报文中所使用的字段，用于补充相应的附加信息、服务器信息，以及客户端的附加要求等信息。 Accept-Ranges用来告知客户端，服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none Age首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 ETag能够告知客户端实体标识 Location可以讲响应接收方引导至某个与请求URL位置不同的资源。 Proxy-Authenticate首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 Retry-After告知客户端应该在多久之后再次发送请求。 Server告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还可能包括版本号和安装时启动的可选项。 Vary源服务器会向代理服务器传达关于本地缓存使用方法的命令。 WWW-Authenticate用于 HTTP 访问认证。它会告知客户端用于访问请求 URL 所制定资源的认证方案 (Basic 或是 Digest) 和带参数提示的质询 (challenge)。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于不中内容的更新时间等与实体相关的信息。 Allow用于通知客户端能够支持 Request-URL 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法是，会以状态码 405 Method Not Allowed 作为响应返回，与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。 Content-Encoding告知客户端服务器对实体的主体部分选用的内容编码方式。 Content-Language告知客户端，实体主体使用的自然语言。 Content-Length告知客户端，实体主体的大小，单位字节。 Content-Location给出与报文主体部分相对应的URL Content-MD5对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。 Content-Range告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。 Content-Type说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。 Expires将资源失效的日期告知客户端。 Last-Modified知名资源最终修改的时间 为 Cookie 服务的首部字段Cookie 的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 Set-CookieSet-Cookie 字段的属性 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值 (必需项) expires=DATE Cookie 的有效期 (若不明确指定则默认为浏览器关闭前为止) path=PATH 将服务器上的文件目录作为Cookie的适用对象 (若不指定则默认为文档所在的文件目录) domain=域名 作为Cookie适用对象的域名 (若不指定则默认为创建Cookie的服务器的域名) Secure 仅在HTTPS安全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问 CookieCookie: status=enableCookie 会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。 其他首部字段HTTP 首部字段是可以自行扩展的。所以在Web服务器和浏览器应用上，会出现各种非标准的首部字段。 X-Frame-Options首部字段 X-Frame-Options 属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持攻击。DENY: 拒绝SAMEORIGIN: 仅同源域名下的页面 (Top-level-browsing-context) 匹配时许可。 X-XSS-Protection首部字段 X-XSS-Protection 属于HTTP响应首部，它是针对跨站脚本攻击的一种对策，用于控制浏览器XSS防护机制的开关。0: 将XSS过滤设置成无效状态1: 将XSS过滤设置成有效状态 DNT首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被手机，是表示拒绝被精准广告追踪的一种方法。0: 同意被追踪1: 拒绝被追踪 P3P首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P (The Platform for Privacy Preferences, 在线隐私偏好平台) 技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。 HTTP/2.0HTTP2 的基本概念HTTP2 是基于SPDY的..HTTP2 有着分厂明确的职责限定： 它必须维持 HTTP 的范式。毕竟它只是一个让客户端发送请求到服务器的基于TCP的协议。 不能盖面 http:// 和 https:// 这样的 URL，也不能对其添加新的结构。使用这类URL的网站太多了，没发指望他们全部改变。 HTTP1的服务器和客户端依然会存在很久，所以我们必须提供HTTP1到HTTP2服务器的代理。 我们也要让这种代理能够将HTTP2的功能一对一的映射到HTTP1.1的客户端 删除或者减少协议里面那些可选的部分。虽然这并不算的上是一个需求，但是SPDY和Google的团队都非常喜欢这样。通过让协议里的所有内容都成为强制性需求，可以防止人们在实现的时候偷懒，从而规避一些将来可能发生的问题。 不再使用小版本号。服务器和客户端都必须确定自己是否完整兼容HTTP2或者彻底不兼容。如果将来协议需要被扩充或者变更，那么新的协议将会是HTTP3，而不是HTTP2.X HTTP2和现有的URI结构HTTP 1.1本身就制定过“升级”的方案：提供一个首部字段， 表示允许服务器在收到旧协议请求的同时， 可以向客户端发送新协议的响应。 但这一方案往往需要多花费一次往返通信来作为升级的代价。而这一代价是SPDY团队不想接受的。 因为他们只实现了基于TLS的SPDY， 所以他们开发了一个TLS的扩展去简化协议的协商。 这个扩展被称作NPN（ Next Protocol Negotiation） ， 借助于此， 服务器会通知客户端所有它支持的协议， 让客户端从中选择一个合适的来进行通讯。 HTTP2将TLS标记成了可选。 然而， 全球两大浏览器领导者 —— Firefox和Chrome都明确地表示， 他们只会实现基于TLS的HTTP2规范中指定了TLS最低版本为1.2， 并且会有加密组的限制。 对于纯文本的HTTP1.1来说， 协商http2的方法就是通过给服务器发送一个带升级头部的报文。 如果服务器支持http2， 它将以“101 Switching”作为回复的状态码， 并从此开始在该连接上使用http2。 也许你很容易就发现这样一个升级的流程会需要消耗掉一整个的往返时延， 但好处是http2连接相比HTTP1可以被更大限度地重用和保持。虽然有些浏览器厂商的发言人宣称他们不会实现这样的http2会话方式， 但IE团队已公开表示他们会实现， 与此同时， curl也已经支持了这种方式 基于TLS之上的HTTP2协商Next Protocol Negotiation (NPN)是一个用来在TLS服务器上协商SPDY的协议。 IETF将这个非正式标准进行规范化， 从而演变成了ALPN（ Application Layer Protocol Negotiation）。ALPN会随着http2的应用被推广， 而SPDY的客户端与服务器则会继续使用NPN。ALPN和NPN的主要区别在于：谁来决定该次会话所使用的协议。 在ALPN的描述中， 是让客户端先发送一个协议优先级列表给服务器， 由服务器最终选择一个合适的。 而NPN则正好相反， 客户端有着最终的决定权。 HTTP2 协议HTTP2 是一个二进制协议。http2会发送有着不同类型的二进制帧， 但他们都有如下的公共字段：Type, Length, Flags, StreamIdentifier和frame payload规范中一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP1.1的DATA和HEADERS。 http2连接上传输的每个帧都关联到一个“流”。 流是一个逻辑上的联合， 一个独立的， 双向的帧序列可以通过一个http2的连接在服务端与客户端之间不断的交换数据。 每个单独的http2连接都可以包含多个并发的流， 这些流中交错的包含着来自两端的帧。 流既可以被客户端/服务器端单方面的建立和使用， 也可以被双方共享， 或者被任意一边关闭。 在流里面， 每一帧发送的顺序非常关键。 接收方会按照收到帧的顺序来进行处理。 每个流都包含一个优先级（ 也就是“权重”） ， 它被用来告诉对端哪个流更重要。 当资源有限的时候， 服务器会根据优先级来选择应该先发送哪些流。借助于PRIORITY帧， 客户端同样可以告知服务器当前的流依赖于其他哪个流。 该功能让客户端能建立一个优先级“树”， 所有“子流”会依赖于“父流”的传输完成情况。 HTTP2 也是一种无状态的协议。 HPACK， HTTP/2头部压缩， 顾名思义它是一个专为http2头部设计的压缩格式。 确切的讲，它甚至被制定写入在另外一个单独的草案里。 新的格式同时引入了一些其他对策让破解压缩变得困难， 例如采用帧的可选填充和用一个bit作为标记， 来让中间人不压缩指定的头部。 在http2里面， 我们可以通过发送RST_STREAM帧来实现重置， 从而避免浪费带宽和中断已有的连接。 服务器推送，这个功能通常被称作“缓存推送”。 主要的思想是：当一个客户端请求资源X， 而服务器知道它很可能也需要资源Z的情况下， 服务器可以在客户端发送请求前， 主动将资源Z推送给客户端。 这个功能帮助客户端将Z放进缓存以备将来之需。如果不需要的话， 客户端可以通过发送一个RST_STREAM帧来中止。 http2上面每个流都拥有自己的公示的流量窗口， 它可以限制另一端发送数据。 扩展协议强制规定了接收方必须读取并忽略掉所有未知帧类型的帧。 双方可以在逐跳原则（ hopby-hop basis） 基础上协商使用新的帧， 这些帧的状态无法被改变， 而且也不受流控制。 备选服务（ Alternative Services） 服务器将会通过发送Alt-Svc头（ 或者http2的ALTSVC帧） 来告知客户端另一个备选服务。 即另外一条指向不同的服务源、 主机或端口， 但却能获取同样内容的路由。藉此， 客户端可以尝试异步的连接并使用该服务， 如果它切实可用的话。 阻塞（ Blocked） 这个类型的帧意味着：当服务端存在需要发送的内容， 但流控制却禁止发送任何数据时， 那么此类型的帧将会被发送且仅发送一次。 这种帧设计的目的在于， 如果你接收到了此帧， 那么连接中必然有错误发生或者是得到了低于期望的传输速度。有可能移除.. 结束HTTP2的学习不详细，后续资料齐全再补充…]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArchLinux 安装笔记]]></title>
    <url>%2FStaticBlog%2F2016%2FArchLinux-install-notes%2F</url>
    <content type="text"><![CDATA[前提说明建议优先选择官方文档为参考，内容随时更新且非常详细。这里记录是包含一些自己遇到的坑。且只针对自己安装需求的情况。 引用参考 Beginners’guide (简体中文)Installation guide (简体中文)给妹子看的 Arch Linux 桌面日常安装ArchLinux 安装笔记寒假折腾Archlinux的一些经验（新手向）–桌面配置篇ArchLinux使用中常见问题集锦 环境机器: DELLBOOT: UEFISSD: 256G内存: 8GCPU: i7-6500U安装需求：本机安装单系统ArchLinux: Release 2016.06.01 LiveUSB参考 USB flash installation media (简体中文)推荐使用里面的手动方法，这样制作的LiveUSB可以使用剩余空间来存储其他东西。 安装准备镜像中不包含软件包，安装的软件是通过服务器上的源下载，所以安装的时候必须要有网络连接。 联网有线： 用ip addr 查看网卡接口型号，比如 enp2s0 启用网卡DHCP功能，systemctl enable dhcpcd@enp2s0.service无线： wifi-menu 选择自己的 wifi 并输入密码连接网络 最后 ping 一下，确认网络无误 更新系统时间timedatectl set-ntp true 准备磁盘 lsblk 查看自己的硬盘所在，比如我的就是 /dev/sda 使用parted 分区注意：我是要全盘安装的，所以重新建立分区表了。a. parted /dev/sdab. (parted) mktable gpt 重建 GPT 分区表c. (parted) mkpart ESP fat32 1M 513M 分配 ESP 分区，前1M是分区表，ESP大小为512Md. (parted) set 1 boot on 设置为ESP分区e. (parted) mkpart primary linux-swap 513M 8705M 分配swap分区，这里使用了与我内存同样大小的8Gf. (parted) mkpart primary ext4 8705M 100% 分配root分区，使用剩余所有空间 格式化分区a. mkfs.vfat –F32 /dev/sda1 ESP分区需要格式化成fat32，否则无法启动b. mkswap /dev/sda2 &amp; swapon /dev/sda2 格式化交换分区，并设置c. mkfs.ext4 –b 4096 /dev/sda3 格式化root分区，并4K对齐 挂载分区a. mount –t ext4 –o discard,noatime /dev/sda3 /mntb. mkdir –p /mnt/boot/EFIc. mount /dev/sda1 /mnt/boot/EFI 安装 配置安装源默认镜像是美国的，在中国速度慢，所以全改中国了..sed -i &#39;/Score/{/China/!{n;s/^/#/}}&#39; /etc/pacman.d/mirrorlist 安装基本系统安装之前先确认是否连网pacstrap /mnt base base-devel vim 生成 fstabgenfstab –U –p /mnt &gt;&gt; /mnt/etc/fstab chrootarch-chroot /mnt /bin/bash Localevim /etc/locale.gen取消下面这些注释en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8 生成locale信息locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.conf 时间选择时区（Shanghai）tzselect 将 /etc/localtime 软连接到 /usr/share/zoneinfo/Zone/SubZoneln –s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置时间标准为 UTC 并调整时间偏移hwclock –systohc –utc 创建初始 ramdisk 环境mkinitcpio –p linux 设置 root 密码passwd 安装 grub先df命令确认一下有木有挂载ESP分区应该是这样的… File system Mounted On /dev/sda3 / /dev/sda1 /boot/EFI … … pacman –S grub efibootmgrgrub-install –target=x86_64-efi –efi-directory=/boot/EFI –bootloader-id=arch_grub –recheckgrub-mkconfig –o /boot/grub/grub.cfg注意:有些BIOS需要自己设置EFI文件位置才能找到efi文件。比如我的DELL 配置网络echo myhostname &gt; /etc/hostname并在 /etc/hosts 添加同样主机名123#&lt;ip-address&gt; &lt;hostname.domain.org&gt; &lt;hostname&gt;127.0.0.1 localhost.localdomain localhost myhostname::1 localhost.localdomain localhost myhostname 有线网络Interface 是您的网络接口名，见连网systemctl enable dhcpcd@interface.service 无线网络pacman –S iw wpa_supplicant dialog 卸载分区并重启系统exitumount -R /mntreboot 折腾新大陆重启之后就阔以以root进入到archlinux系统了，首先我们要进行联网。 添加用户useradd –m –g users –G wheel –s /bin/bash usernamepasswd username sudopacman –S sudovim /etc/sudoers找到 root ALL=(ALL) ALL照着这个，在下面添加一个 username ALL=(ALL) ALL 安装 yaourtvim /etc/pacman.conf加入下面的内容: 1234[archlinuxcn]# The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://mirrors.163.com/archlinux-cn/$arch 更新并安装yaourt123pacman –Syupacman –S yaourtpacman –S archlinuxcn-keyring 安装 SSH、GIT、wgetpacman –S git openssh wget 安装 zsh 123pacman –S zshchsh /bin/zshsh –c “$(curl –fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 安装 screenfetchpacman –S screenfetch NTFS 读写pacman –S ntfs-3g 安装解压缩软件pacman –S file-roller unrar unzip p7zip Shadowsocks-qt5pacman –S shadowsocks-qt5 ProxyChainspacman –S proxychains RP-PPPOE拨号的，按需安装pacman –S rp-pppoenm-connection-editor 安装 xorg 桌面管理器pacman –S xorg-xinit xorg-server xorg-twm xterm 安装 gnome 桌面环境按需，个人安装的gnome，觉得新版3.20挺好看的pacman –S gnomepacman –S gnome-tweak-tool VPN 扩展 123pacman –S networkmanager-pptpyaourt networkmanager-l2tpsystemctl restart NetworkManager 启动服务显示管理器gnome默认是用的GDMsystemctl enable gdm.service 网络管理systemctl enable NetworkManager.service 更新pacman –Syu 安装 chromiumpacman –S chromium 安装输入法依赖pacman –S fcitx-im fcitx-configtool fcitx-gtk3 fcitx-gtk2 fcitx-qt4 fcitx-qt5 自行选择安装的拼音，我选择的sunpacman –S sunpinyin 配置.xprofile文件vim ~/.xprofile 添加如下内容12345678export LC_CTYPE=zh_CN.UTF-8export XIM=fcitxexport XIM_PROGRAM=fcitxexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx"eval `dbus-launch --sh-syntax --exit-with-session`exec fcitx &amp; 注意，即使这样，你会发现还是调用不出输入法…等下重启之后告诉你如何解决~ 安装网易云音乐pacman –S netease-cloud-music 重启reboot 来到新的世界重启你会发现有了界面~ 配置输入法前面说即使安装完那些东西也调不出来，是有个地方需要配置一下左下角可以有个后台程序栏。右键输入法，选择配置。发现输入法里面并没有拼音，我们添加进安装的 sunpinyin 就好了。注意:切换输入法与 gnome 显示的不一致。默认切换输入法是 ctrl+space 中文化安装中文字体，推荐思源黑体，安装方法见 Github 上的安装过程。安装等宽字体，推荐 Source Code Pro打开 Gnome Tweak Tool，切换到字体栏，将窗口、界面、文档的字体改为 Source Han Sans Normal将等宽字体设置为 Source Code Pro VMWare我这里环境：VMWare: VMware-Workstation-Full-12.1.1-3770994.x86_64.bundleLinux: Linux 4.6.2-1-ARCH 首先从VMWare官网下载个 VMWare二进制包安装部分详见 VMware_(简体中文) 安装依赖mkdir /etc/init.d 添加VMWare服务配置文件yaourt vmware-systemd-servicessystemctl enable vmware.servicesystemctl start vmware.service 有一个地方我要说明一下。在启动提示有个服务跟新的时候，更新会失败，导致不能启动VMWare注意：下面的方法不一定在你的版本适用，请注意备份。解决方法是： 进入 /usr/lib/vmware/modules/source 解包 vmnet.tar vmmon.tar Replace function &quot;get_user_pages()&quot; with &quot;get_user_pages_remote()&quot; in vmmon-only/linux/hostif.c and vmnet-only/userif.c files. 重新打包回去 具体如下：cd /usr/lib/vmware/modules/source 解包sudo tar –xvf vmnet.tarsudo tar –xvf vmmon.tar 把下面两个文件里面的 get_user_pages 函数替换成 get_user_pages_remotesudo vim vmnet-only/driver.csudo vim vmmon-only/linux/hostif.c 打包sudo tar -uvf vmnet.tar vmnet-onlysudo tar -uvf vmmon.tar vmmon-only 然后删除那解包的文件夹sudo rm -r vmnet-onlysudo rm -r vmmon-only 结束]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2] ARK-Tool develop log : Enumerate Process & Thread.]]></title>
    <url>%2FStaticBlog%2F2016%2FARK%2F2-ARK-Tool-develop-log-Enumerate-process-thread%2F</url>
    <content type="text"><![CDATA[枚举 Process &amp; Thread按照惯例，玩儿这些东西总是从进程开始哒，那么我们今儿就说一下枚举进程&amp;线程~ 在R3，我们阔以用以下方法来遍历进程&amp;线程： ToolHelp ZwQuerySystemInformation 但是到了R0，就阔以用各种方法来实现： ZwQuerySystemInformation 遍历 活动进程链（PEPROCESS-&gt;ActiveProcessLinks） 通过 PsLookupProcessByProcessId 搜索 遍历 PspCidTable 句柄表 ZwQuerySystemInformation这个算是标准的方法，网上一堆，不再赘述。 遍历进程活动链表什么是活动进程链？ EPROCESS 块中有一个 ActiveProcessLinks 成员，它是一个 PLIST_ENTRY 结构的双向链表。当一个新进程建立的时候父进程负责完成 EPROCESS 块，然后把 ActiveProcessLinks 链接到一个全局内核变量 PsActiveProcessHead 链表中。 在 PspCreateProcess 内核API中能清晰的找到： InsertTailList (&amp;PsActiveProcessHead, &amp;Process-&gt;ActiveProcessLinks); 当进程结束的时候，该进程EPROCESS结构从活动进程链上摘除。（但是 EPROCESS 结构不一定马上释放。） 在 PspExitProcess 内核API中能看到 RemoveEntryList(&amp;Process-&gt;ActiveProcessLinks);遍历进程活动链表（ActiveProcessLinks）、DKOM隐藏进程 ZwQuerySystemInformation 就是遍历这个链表来实现的。 由于很容易摘链来隐藏进程，所以这里只是简单的说下。 有一个要注意的地方，就是链表里面存的是 EPROCESS-&gt;ActiveProcessLinks 所以要得到EPROCESS就要减去这个偏移。 12345678910111213141516kd&gt; dt nt!_EPROCESS 0xfffffa80`03510f80 +0x000 Pcb : _KPROCESS +0x160 ProcessLock : _EX_PUSH_LOCK +0x168 CreateTime : _LARGE_INTEGER 0x0 +0x170 ExitTime : _LARGE_INTEGER 0x00000003`00000006 +0x178 RundownProtect : _EX_RUNDOWN_REF +0x180 UniqueProcessId : 0xfffffa80`03511010 Void +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffff8a0`014aac28 - 0xfffffa80`03511138 ] ... kd&gt; ? 0xfffffa80`02de4ab8 - 0x188Evaluate expression: -6047265830608 = fffffa80`02de4930kd&gt; !object fffffa80`02de4930Object: fffffa8002de4930 Type: (fffffa800184aa20) Process ObjectHeader: fffffa8002de4900 (new version) HandleCount: 1 PointerCount: 25 通过 PsLookupProcessByProcessId 搜索这个方案虽然简单，但相对于以上两种方法，更推荐使用这种方案。 原因就是 活动进程链 太简单，很容易被摘掉。 而 PsLookupProcessByProcessId 是通过遍历 PspCidTable 来实现。 进程要逃避检测，必须从 PspCidTable 中删除自身对象，句柄项被用 NULL 替代。但当系统关闭进程的时候，它将找到 PspCidTable 并且得到一个 NULL 对象指针，这将导致蓝屏。隐藏进程在被终止之前必须调用 PsSetCreateProcessNotifyRoutine 安装一个回调避免BSOD，但实现方法难度相对来说略高。 当然，也有我不并不知道的方法，请各位童鞋告知~共同探讨学习~~ 注意：可以通过HOOK来解决掉这个函数，所以阔以自己遍历 PspCidTable 来尽量避免隐藏进程 12345678910111213141516171819202122232425template &lt;typename F&gt;static NTSTATUS EnumProcess( _In_ F aCallBack )&#123; NTSTATUS vStatus = STATUS_UNSUCCESSFUL; PEPROCESS vProcess = NULL; for (Size_t i = 4; i &lt; 262144; i += 4) // 262144 = 2^18 &#123; // 遍历线程同理，换成 PsLookupThreadByThreadId vStatus = PsLookupProcessByProcessId((HANDLE)i, &amp;vProcess); if (NT_SUCCESS(vStatus)) &#123; vStatus = aCallBack(vProcess); ObDereferenceObject(vProcess); if (STATUS_SUCCESS == vStatus) &#123; break; &#125; &#125; &#125; return vStatus;&#125; 遍历 PspCidTable 句柄表这部分内容留到下一篇文章 “检测隐藏进程” ~ 我先去研究研究（逃~]]></content>
      <categories>
        <category>ARK</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>内核</tag>
        <tag>ARK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[1] ARK-Tool develop log : Global Overloaded new & delete.]]></title>
    <url>%2FStaticBlog%2F2016%2FARK%2F1-ARK-Tool-develop-log-Global-Overloaded-new-delete%2F</url>
    <content type="text"><![CDATA[全局重载 New &amp; Delete（DTL系列）由于在驱动层，WDK并没有提供 new 和 delete，所以我们要用内核的内存分配函数自己重载一套。 new 和 delete 的重载有以下注意的地方： 要符合 C++ 标准 有 new 就要有对应的 delete 以下 new &amp; delete 必须重载，以供 C++ 基本使用： 一般形式 数组形式 placement new 用于类对象的 delete 重载 operator new 的参数个数是可以任意的 , 只需要保证第一个参数为 size_t, 返回类型为 void * 即可 , 而且其重载的参数类型也不必包含自定义类型 . 更一般的说 , operator new 的重载更像是一个函数的重载 , 而不是一个操作符的重载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 默认参数值static const POOL_TYPE DEFAULT_NEW_POOL_TYPE = NonPagedPool;static const unsigned long DEFAULT_NEW_TAG = &apos; New&apos;;// 一般形式void * __cdecl operator new (size_t aSize) noexcept&#123; if (0 == aSize) &#123; // 按照 C++ 标准， // 当 size 为 0 时， // 申请 1 字节内存 aSize = 1; &#125; return ExAllocatePoolWithTag(DEFAULT_NEW_POOL_TYPE, aSize, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete (void *aPtr) noexcept&#123; if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;// placement new// 不需要delete，对象可以直接调用析构void * __cdecl operator new (size_t /*aSize*/, void *aBuffer) noexcept&#123; // placement new的作用就是：创建对象(调用该类的构造函数)但是不分配内存， // 而是在已有的内存块上面创建对象。用于需要反复创建并删除的对象上， // 可以降低分配释放内存的性能消耗 return aBuffer;&#125;// 数组形式void * __cdecl operator new[] (size_t aSize) noexcept&#123; if (0 == aSize) &#123; aSize = 1; &#125; return ExAllocatePoolWithTag(DEFAULT_NEW_POOL_TYPE, aSize, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete[] (void *aPtr) noexcept&#123; if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;// 用于类对象的 deletevoid __cdecl operator delete (void *aPtr, size_t /*aSize*/) noexcept&#123; // sized class - specific deallocation functions if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete[] (void *aPtr, size_t /*aSize*/) noexcept&#123; // sized class - specific deallocation functions if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;]]></content>
      <categories>
        <category>ARK</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>内核</tag>
        <tag>ARK</tag>
        <tag>DTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[0] ARK-Tool develop log : 前言]]></title>
    <url>%2FStaticBlog%2F2016%2FARK%2F0-ARK-Tool-develop-log-Perface%2F</url>
    <content type="text"><![CDATA[前言声明：这一系列文章是我边学边写，内容不免会有错误，望指出不足，希望能够共同提高~么么哒~ 写一款自己的ARK工具的怨念已经产生很久了，一直拖拖拉拉到现在终于行动起来。 原因无非如下： 学习 装13，（ 哈哈哈哈哈~ 给自己的作品库填点儿玩具 开发环境： 测试平台 ：Windows 7 x86/x64 语言 ：C++11 IDE ：Visual Studio 2015 其他工具 ：Windbg，IDA，Source Insight，PowerTool，WinObj，SymbolTypeViewer 开发原则： Warning Level：4 安全，稳定，尽量无硬编码，设计时就支持x86/x64平台。 以 PowerTool 和 WIN64AST 为目标~ 将采用C++11的一些特性来写，毕竟用起来很爽~ 当然，在驱动不能使用原有的标准库，用到的东西基本上要自己先实现一套。 注意：自己要在测试环境中测试，若造成系统损坏，本人将不负任何责任~ 大致分为以下项目：用户层： 界面 驱动管理模块 驱动层： 驱动模板库（即R0的STL） 驱动基础库 ARK驱动 库将采用静态库的方式编译，每个静态库项目都会有个Unit的编译选项方便调试~ ARK项目我将其命名为 Illidan Stormrage，即魔兽里面的那个帅锅~ 而驱动部分我将其命名为 Warglaive，就是它那把“埃辛诺斯战刃” 这一系列文章将会记录开发ARK这一路各个功能的实现方法，遇到的问题以及解决方案。 致谢毛哥, 羡B, ithurricanept (PowerTool作者), Tesla.Angela, 小丽 (我司大神..)… 感谢 毛哥 平日里的各种科普，各种唠叨~ 感谢 羡B 对我各种白痴问题解答~ 感谢 Ithurricanept 大神的工具，以及公众号分享的知识~ 感谢 TA 大神提供的基础教程，以及提供的论坛~ 感谢 小丽 对我潜移默化的影响和鞭策~ … …]]></content>
      <categories>
        <category>ARK</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>内核</tag>
        <tag>ARK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XP 兼容系列：神奇的静态对象 (magic statics)]]></title>
    <url>%2FStaticBlog%2F2016%2FXP-Compatible-magic-statics%2F</url>
    <content type="text"><![CDATA[神奇的静态对象 (magic statics)前置声明：文章可能有错误的地方，希望各位童鞋能够提出~ 事故缘由…为了使用很爽的C++11 特性，我司最新项目是用的VS2015进行开发的。但是同时又要对XP做兼容（讲真，我个人是不支持对Win7之前的系统做兼容的，我觉得影响发展）。 我们写了个COM组件作为插件，和驱动进行通讯。在我们进行单元测试的时候，一切正常。但是出了测试安装包之后，发现加载插件会崩溃。然后我们挂载了Windbg神器来定位崩溃点。崩溃点是一个读取TLS，这个值为空(外部静态对象才会有TLS) 想到单元测试程序也是通过VS2015编译的。我们就比较两个进程有啥不一样。如图: 然后我们看一下 nt!_TEB 结构，发现 Tls Storage 就是 _TEB::ThreadLocalStoragePointer 字段。如图： 于是我们查了一下 ReactOS 0.3.15 看下这个字段到底是啥，找到了这个分配Tls的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpAllocateTls(VOID)&#123; PTEB Teb = NtCurrentTeb(); PLIST_ENTRY NextEntry, ListHead; PLDRP_TLS_DATA TlsData; SIZE_T TlsDataSize; PVOID *TlsVector; /* Check if we have any entries */ if (!LdrpNumberOfTlsEntries) return STATUS_SUCCESS; /* Allocate the vector array */ TlsVector = RtlAllocateHeap(RtlGetProcessHeap(), 0, LdrpNumberOfTlsEntries * sizeof(PVOID)); if (!TlsVector) return STATUS_NO_MEMORY; Teb-&gt;ThreadLocalStoragePointer = TlsVector; /* Loop the TLS Array */ ListHead = &amp;LdrpTlsList; NextEntry = ListHead-&gt;Flink; while (NextEntry != ListHead) &#123; /* Get the entry */ TlsData = CONTAINING_RECORD(NextEntry, LDRP_TLS_DATA, TlsLinks); NextEntry = NextEntry-&gt;Flink; /* Allocate this vector */ TlsDataSize = TlsData-&gt;TlsDirectory.EndAddressOfRawData - TlsData-&gt;TlsDirectory.StartAddressOfRawData; TlsVector[TlsData-&gt;TlsDirectory.Characteristics] = RtlAllocateHeap(RtlGetProcessHeap(), 0, TlsDataSize); if (!TlsVector[TlsData-&gt;TlsDirectory.Characteristics]) &#123; /* Out of memory */ return STATUS_NO_MEMORY; &#125; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: TlsVector %x Index %d = %x copied from %x to %x\n&quot;, TlsVector, TlsData-&gt;TlsDirectory.Characteristics, &amp;TlsVector[TlsData-&gt;TlsDirectory.Characteristics], TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsVector[TlsData-&gt;TlsDirectory.Characteristics]); &#125; /* Copy the data */ RtlCopyMemory(TlsVector[TlsData-&gt;TlsDirectory.Characteristics], (PVOID)TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsDataSize); &#125; /* Done */ return STATUS_SUCCESS;&#125; 但是这个函数并不能得到太多有用信息。我们又看了下谁调用了它，得到了 LdrpInitializeTls 这个函数，从这个函数里面，我们就知道，实际上 _TEB::ThreadLocalStoragePointer 这个字段就是 初始化好的PE文件里面的 Tls 表。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpInitializeTls(VOID)&#123; PLIST_ENTRY NextEntry, ListHead; PLDR_DATA_TABLE_ENTRY LdrEntry; PIMAGE_TLS_DIRECTORY TlsDirectory; PLDRP_TLS_DATA TlsData; ULONG Size; /* Initialize the TLS List */ InitializeListHead(&amp;LdrpTlsList); /* Loop all the modules */ ListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList; NextEntry = ListHead-&gt;Flink; while (ListHead != NextEntry) &#123; /* Get the entry */ LdrEntry = CONTAINING_RECORD(NextEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); NextEntry = NextEntry-&gt;Flink; /* Get the TLS directory */ TlsDirectory = RtlImageDirectoryEntryToData(LdrEntry-&gt;DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &amp;Size); /* Check if we have a directory */ if (!TlsDirectory) continue; /* Check if the image has TLS */ if (!LdrpImageHasTls) LdrpImageHasTls = TRUE; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: Tls Found in %wZ at %p\n&quot;, &amp;LdrEntry-&gt;BaseDllName, TlsDirectory); &#125; /* Allocate an entry */ TlsData = RtlAllocateHeap(RtlGetProcessHeap(), 0, sizeof(LDRP_TLS_DATA)); if (!TlsData) return STATUS_NO_MEMORY; /* Lock the DLL and mark it for TLS Usage */ LdrEntry-&gt;LoadCount = -1; LdrEntry-&gt;TlsIndex = -1; /* Save the cached TLS data */ TlsData-&gt;TlsDirectory = *TlsDirectory; InsertTailList(&amp;LdrpTlsList, &amp;TlsData-&gt;TlsLinks); /* Update the index */ *(PLONG)TlsData-&gt;TlsDirectory.AddressOfIndex = LdrpNumberOfTlsEntries; TlsData-&gt;TlsDirectory.Characteristics = LdrpNumberOfTlsEntries++; &#125; /* Done setting up TLS, allocate entries */ return LdrpAllocateTls();&#125; 到了这步，我们以为可以很容易的解决问题，既然需要Tls目录，那我们给它一个不就行了？所以我们给测试代码添加了一个Tls目录..1234567#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)#pragma data_seg(&quot;.CRT$XLB&quot;) PIMAGE_TLS_CALLBACK TlsCallBackArray[] = &#123; TlsCallBackFunction &#125;;#pragma data_seg() 不过我们还是太天真了..我们的Tls的回调啥也没做，所以在程序执行的时候，执行到并没有初始化的对象直接崩溃了..（对，VS2015生成的Tls表（回调）就是用来初始化静态对象的。） 后来…我们在 MSDN 发现一个相关的说明 Starting in C++11, a static local variable initialization is guaranteed to be thread-safe.This feature is sometimes called magic statics.However, in a multithreaded application all subsequent assignments must be synchronized.The thread-safe statics feature can be disabled by using the /Zc:threadSafeInit- flag to avoid taking a dependency on the CRT. 大致意思是，由于在C++11开始可以保证静态本地变量初始化时是线程安全的，即“神奇的静态对象”但是这个特性是默认需要CRT支持的，所以要关闭则需要增加一条编译选项1/Zc:threadSafeInit- 这样在XP上运行就不会出现问题了。 好了，结束~以此记录，来避免自己再遇到同样的坑 (●ˇ∀ˇ●) 引用链接：Storage class (C++)]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>XP Compatible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 基本使用]]></title>
    <url>%2FStaticBlog%2F2016%2FHexo-basic%2F</url>
    <content type="text"><![CDATA[Hexo 安装步骤 安装node.js 全局安装 hexo npm install -g hexo-cli 如果有版本什么的警告可以试试这个 npm install --unsafe-perm --verbose -g hexo cd &lt;file folder&gt; 到指定目录 hexo init 初始化hexo npm install 安装依赖 hexo generate 生成静态网页 hexo server 在服务器上运行 可以登录 Loaclhost 测试了 hexo new post “标题” 创建一个博文 MD博文示例 title: 博文标题 data : 2015-12-13 19:05:28 tags : 标签 updata: 最后修改时间 comments:定义能否评论此文章（true） categories: 文章分类 &lt;!-- more --&gt; 使文章在 more 位置折叠 多级分类123categories: - Sports - Baseball 配置文件——“_config.yml” 主题在 themes 目录 默认主题在 themes/landscape 目录 可以在配置文件里面改 部署设置 在配置文件 deploy 项 type: git (github 也是 git) repository: 库地址 branch: 分支 更新新版本 hexo npm update -g hexo 查看 hexo 版本 hexo version 常用命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清楚缓存，网页正常情况写可以忽略此条命令hexo g #生成静态页面hexo d #部署 （要先在 _Config.yml 配置文件配置 deploy 项） 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令作用是一样的hexo generate --deployhexo deploy --generate hexo deploy -ghexo server -g 模板hexo new &quot;postname&quot; #新建文章hexo new page &quot;pagename&quot; #新建页面 变量 描述 :layout 布局 :title 标题 :date 文件建立日期 其实这是测试表格的..]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>