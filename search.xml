<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C 学习笔记]]></title>
    <url>%2FStaticBlog%2F2016%2F09%2F03%2FObjective-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[之前学习 Objective-C 时整理的笔记，文章内错误之处还望指点… Hello World123456789#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char *argv[])&#123; @autoreleasepool &#123; // insert code here... NSLog(@"Hello, World"); &#125; return 0;&#125; #import 就相当于 C++ 里面的 #include 123@autoreleasepool &#123; ...&#125; {...} 之间的语句会在被称之为 “自动释放池” 的语境中执行。 自动释放池的机制是：它使得应用在创建新对象时，系统能够有效的管理应用所使用的内容。 @&quot;Hello, World&quot; 此处的 @ 符号在位于一对双引号的字符串前面，这称为常量 NSString 对象。如果前面没有 @ 字符，就是在编写常量 C 类型的字符串。有了这个符号就是在编写 NSString 字符串对象。 同 C 语言一样，Objective-C 的所有程序语句必须使用分号（;）结束。 这篇文章主要是讲 Objective-C 与 C++ 的区别… 类、对象和方法消息传递Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格/在源码风格方面，这是它与C Family语言（包括C/C++、Java、世界上最好的语言PHP）差别最大的地方。 在Java、C++世界，我们调用一个对象的某个方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同。 在Java、C++里，对象和方法关系非常严格，一个方法必须属于一个类对象，否则编译要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态确定，给类型发送一个它无法处理的消息，也只会抛出一个异常而不会挂掉。 Language Call Method Objective-C [obj undefineMethod]; C++ obj.undefineMethod(); 在代码里调用没定义的方法（这是Java、C++世界习惯的说法，专业叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但能编译成功，运行的时候会出错。它会输出这样一个错误： 函数调用前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例： 不带参数 1StartedBlock(); 带参数 12NSLog(@"decrypted string: %@", str);CGRectMake(0, 0, 0, 0); 传递消息给类 / 实例方法 不带参数 Language Method Objective-C [obj method]; C++ obj.method(); 带一个参数 Language Method Objective-C [counter increase:1]; C++ counter.increase(1); 带多个参数对于C Family 程序员来说，这是最难接收，最反人类的 Language Method Objective-C -(void) setColorToRed: (float)red Green: (float)green Blue: (float)blue {…} // 定义方法 [myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; // 传递消息 C++ public void setColorToRedGreenBlue(float red, float green, float blue) {…} myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2); 消息嵌套 Language Method Objective-C UINavigationBar *bar = [ [ [UINavigationBar alloc] init] autorelease]; C++ UINavigationBar bar = UINavigationBar.alloc().inti().autorelease(); 类的定义与实现Objective-C中强烈要求将类的定义（interface）与实现（implementation）分为两个部分。类的定义文件遵循C语言之习惯，头文件以.h为后缀，实现文件以.m为后缀（也有.mm的扩展名，表示Objective-C与C++混合编程） 举个栗子： Interface定义部分，清楚定义了类的名称、数据成员和方法。以关键字@interface作为开始，@end作为结束。 1234567891011@interface MyObject : NSObject &#123; int memberVar1; //实体变量 id memberVar2;&#125;+(return_type) class_method; // 类方法-(return_type) instance_method1; // 实例方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+/-号代表函数的类型：加号（+）代表类方法（class method），不需要实例就可以调用，与C++的静态函数（static member function）相似。减号（-）即是一般的实例方法（instance method）。 下面是意义相近的 C++ 语法对照： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void *memberVar2; public: static return_type class_method(); // 类方法 return_type instance_method1(); // 实例方法 return_type instance_method2(int p1); return_type instance_method3(int p1, int p2);&#125; Objective-C 定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C 方法使得参数可以夹于名称中间，不必全部依附于方法名称的尾端，可以提高程序可读性。设定颜色RGB值得方法为例子：123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; // 宣告方法[myColor setColorToRed:1.0 Green:0.8 Blue:0.2]; // 呼叫方法 这个方法的签名是setColorToRed:Green:Blue:。每个冒号后面都带着一个float类别的参数，分别代表红，绿，蓝三色。 Implementation实现区块则包含了公开方法的实现，以及定义私有变量及方法。以关键字@implementation作为区块起头，@end结尾。 1234567891011121314151617181920@Implementation MyObject &#123; int memberVar3; // 私有实体变量&#125;+(return_type) class_method &#123; ... // method Implementation&#125;-(return_type) instance_method1 &#123; ...&#125;-(return_type) instance_method2: (int) p1 &#123; ...&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ...&#125;@end 值得一提的是不只Interface区块可定义实体变量，Implementation区块也可以定义实体变量，两者的差别在于访问权限的不同。Interface区块内的实体变量默认权限为protected，宣告于implementation区块的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为如此类别之私有信息就不需曝露于公开interface（.h文件）中。 创建对象Objective-C创建对象需通过alloc以及init两个消息。alloc的作用是分配内存，init则是初始化对象。 init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例：1MyObject *my = [[MyObject alloc] init]; 在Objective-C 2.0里，若创建对象不需要参数，则可直接使用new1MyObject *my = [MyObject new]; 仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写init方法，来添加额外的工作。（用途类似C++ 的构造函数constructor）123456- (id) init &#123; if (self = [super init]) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125; 数据类型和表达式OC 有4个基本数据类型：int, float, double, char。概念同C++一样5个限定词：long, long long, short, unsigned, signed。概念同 C++ 一样 下面来说几个特殊的类型： BOOL 类型概念同 C++ 一样，但是预定义的真假值与 C++ 不同： Language 真 假 Objective-C YES NO C++ true false id 类型id类型是 OC 里一个比较特殊的类型。概念上与 void 类型很像，但是他们两个有很大区别。在内部处理上，这种类型被定义为 指向对象的指针，实际上是一个 *指向这种对象的实例变量的指针 下面是 id 在 Objc.h 中的定义： 1234567/// Represents an instance of a class.struct objc_object &#123; class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 从上面看出，id是指向struct objc_object的一个指针。也就是说，id是指向任何一个继承了Object（或者NSObject）类的对象。需要注意的是，id是一个指针，所以在使用的时候不需要加星号（*）。 SEL 类型在 Objective-C 中，SEL 是选择器的一个类型。我们可以将 SEL 理解为函数指针，但他们之间并非完全一样。 nil 类型与 C++ 中 null 概念一样，是是对 nill 操作不会有任何作用，C++ 中对 null 操作会异常。 基础数据类型表： 类型 实例 NSLog 字符 char ‘a’、’\n’ %c short int - %hi、%hx、%ho unsigned short int - %hu、%hx、%ho int 12、-97、0xFFE0、0177 %i、%x、%o unsigned int 12u、100U、0XFFu %u、%x、%o long int 12L、-200l、0xffffL %li、%lx、%lo unsigned long int 12UL、100ul、0xffeeUL %lu、%lx、%lo long long int 0xe5e5e5e5LL、0xffeeUL %lli、%llx、%llo unsigned long long int 12ull、0xffeeULL %llu、%llx、%llo float 12.34f、3.1e-5f、0x1.5p10、0x1P-1 %f、%e、%g、%a double 12.34、3.1e-5、0x.1p3 %f、%e、%g、%a long double 12.34L、3.1e-5l %Lf、%Le、%Lg id nil %p 基本算术运算符概念同 C++ 一样 循环结构和选择结构同C++11一样，for循环有两种：普通for循环，快速for循环 123456789101112// 第一种遍历：普通 for 循环long int count = [array count];for (int i = 0; i &lt; count; ++i) &#123; NSLog(@"1 遍历 array：%zi -&gt; %@", i, [array objectAtIndex:i]);&#125;// 第二种遍历：快速 for 循环int i = 0;for (id obj in array) &#123; NSLog(@"2 遍历 array：%zi -&gt; %@", i, obj); ++i;&#125; 其他的 while，do…while，break，continue 都同 C++ 一致选择结构，if，if…else…，switch同 C++ 一致 类合成存取方法12345678910111213141516171819202122232425262728293031323334353637@interface Fraction : NSObject@property int numerator, denominator;- (void) print;- (double) convertToNum;@ end@Implementation Fraction@synthesize numerator, denominator;- (void) print &#123; NSLog(@"%i / %i", numerator, denominator);&#125;- (double) convertToNum &#123; if (denominator != 0) &#123; return (double) numerator / denominator; &#125; else &#123; return NAN; &#125;&#125;@ endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *objFraction = [Fraction new]; [objFraction setNumerator:1]; [objFraction setDenominator:2]; [objFraction print]; &#125; return 0;&#125; 从OC 2.0开始，可自动生成设值方法和取值方法。第一步是在接口部分中使用@property指令标识属性。第二步是在实现部分中使用@synthesize 如果使用了@property指令，就不需要再实现部分声明相应的实例变量。 当然，你并不需要使用@synthesize指令，使用@property指令编译器也会自动为你生成setter和getter。但是要注意，如果你不使用@sythesize，那么编译器生成的实例变量会以下画线（_）字符作为其名称的第一个字符。 访问属性访问属性有两种格式：Instance.property = value; 等价为 [Instance setProperty: value]; 继承123456789101112131415161718192021222324@interface ClassA : NSObject &#123; int x;&#125;- (void) initVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;@end@interface ClassB : ClassA- (void) printVar;@end@implementation ClassB- (void) printVar &#123; NSLog(@"x = %i", x);&#125;@end 在这段代码里面，ClassA继承于NSObject，ClassB继承于ClassA。语法同C++差不多。但是有一点要注意：OC只能是单继承，而C++可以多继承。 继承的概念作用于整个继承链。 @class 指令例如 @class XYPoint;在头文件声明中，告诉编译器XYPoint是一个类的名字。而不需要 #import 导入整个 XYPoint.h在C++中相当于 class XYPoint; 处理动态类型的方法： 方法 问题或行为 -(BOOL) isKindOfClass: class-object 对象是不是 class-object 或其子类的成员 -(BOOL) isMemberOfClass: class-object 对象是不是 class-object 的成员 -(BOOL) respondsToSelector: Selector 对象是否能够相应 selector 所指定的方法 -(BOOL) instancesRespondToSelector: Selector 指定的类实例是否能够响应 selector -(BOOL) isSubclassOfClass: class-object 对象是否是指定类的子类 -(id) performSelector: selector 应用 selector 指定的方法 -(id) performSelector: selector withObject: object 应用 selector 指定的方法，传递参数 object -(id) performSelector: selector withObject: object1 withObject: object2 应用 selector 指定的方法，传递参数 object1 和 object2 多态在OC里面的多态与C++有些不一样。在OC里面，不同类的相同方法名即为多态。而在C++里面就不一样咯。C++里面的多态是通过继承来实现的。 举个最简单的例子： Objective-C 12345678910111213141516171819202122232425262728293031323334353637383940@interface ClassA : NSObject &#123; int x;&#125;- (void) intVar;- (void) printVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;- (void) printVar &#123; NSLog(@"x = %i", x)&#125;@end@interface ClassB : ClassA- (void) initVar;@end@implementation ClassB- (void) initVar &#123; x = 200;&#125;@endint main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; ClassA *myClassA = [ClassB new]; [myClassA initVar]; [myClassA printVar]; &#125; return 0;&#125; C++ 1234567891011121314151617181920212223242526272829303132333435class ClassA&#123;protected: int x;public: void initVar() &#123; x = 100; &#125; void printVar() &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;&#125;;class ClassB : public ClassA&#123;public: void initVar() &#123; x = 200; &#125;&#125;int main(int argc, const char *argv[])&#123; ClassA *myClassA = new ClassB(); myClassA-&gt;initVar(); myClassA-&gt;printVar(); getchar(); return 0;&#125; C++ 输出的结果是100而OC输出的结果是200，OC是真的覆盖… 另外，OC不支持运算符重载… 异常处理@try、@catch、@throw、@finally这些概念同C一样。 分类和协议分类在Objective-C的设计中，一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示，改进代码的一种主要方法即为将其分解为更小的片段。Objective-C借用并扩展了Smalltalk实现中的“分类”概念，用以帮助达到分解代码的目的。 分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。 举个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Integer.h#import &lt;objc/Object.h&gt;@interface Integer : Object &#123;@private int integer;&#125;@property (assign, nonatomic) integer;@end// Integer.m#import "Integer.h"@implementation Integer@synthesize integer;@end// Arithmetic.h#import "Integer.h"@interface Integer(Arithmetic)- (id) add: (Integer *) addend;- (id) sub: (Integer *) subtrahend;@end// Arithmetic.m#import "Arithmetic.h"@implementation Integer(Arithmetic)- (id) add: (Integer *) addend &#123; self.integer = self.integer + addend.integer; return self;&#125;- (id) sub: (Integer *) subtrahend &#123; self.integer = self.integer - subtrahend.integer; return self;&#125;@end// Display.h#import "Integer.h"@interface Integer(Display)- (id) showstars;- (id) showint;@end// Display.m#import "Display.h"@implementation Integer(Display)- (id) showstars &#123; int i, x = self.integer; for (i = 0; i &lt; x; ++i) printf("*"); printf("\n"); return self;&#125;- (id) showint &#123; printf("%d\n", self.integer); return self;&#125;@end// main.m#import "Integer.h"#import "Arithmetic.h"#import "Display.h"int main (void) &#123; Integer *num1 = [Integer new], *num2 = [Integer new]; int x; printf("Enter an integer: "); scanf("%d", &amp;x); num1.integer = x; [num1 showstars]; printf("Enter an integer: "); scanf("%d", &amp;x); num2.integer = x; [num2 showstars]; [num1 add:num2]; [num1 showint]; return 0;&#125; 类的扩展有一种特殊的情况是创建一个未命名的分类，且在括号“（）”之间不指定名字。这种特殊的语法定义称为类的扩展。定义一个像这样命名的分类时，可以通过定义额外的实例变量和属性来扩展类，这在有命名的分类中是不允许的。未命名分类中声明的方法需要在主实现区域实现，而不是在分离的实现区域中实现。未命名的分类是非常有用的，因为他们的方法都是私有的。如果需要写一个类，而且数据和方法仅供这个类本身使用，未命名分类比较合适。 通过使用分类添加新方法来扩展类不仅会影响这个类，同时也会影响他的所有子类。 协议协议是一组没有实现的方法列表，任何的类均可采纳协议并具体实现这组方法。协议列出了一组方法，有些可以是选择实现，有些是必须实现。定义一个协议很简单：只要使用@protocol指令，后面跟上你给出的协议名称。然后和处理接口部分一样，声明一些方法。@end指令之前的所有方法声明都是协议的一部分。在@optional指令之后列出的所有方法都是可选的。 个人感觉类似于C++的虚基类… 举个栗子：1234@protocol Printable@optional - (void) print:(NSString)str;@end 加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。 12@interface class MyClass : NSObject &lt;Printable, Drawable&gt;@end 一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。 可以使用conformsToProtocol:方法检查一个对象是否遵循某项协议。 12345id currentObject;...if ([currentObject conformsToProtocol: @protocol (Drawable)] == YES) &#123; ...&#125; 这里使用的专用@protocol指令用于获取一个协议名称，并产生一个protocol对象，conformsToProtocol: 方法期望这个对象作为它的参数。 为了测试一个对象是否实现了可选的print方法，可以编写下列代码： 123if ([currentObject respondsToSelector: @selector (print)] == YES) &#123; [currentObject print];&#125; 通过在类型名称之后的尖括号中添加协议名称，借助编译器来检查变量的一致性：id &lt;Drawable&gt; currentObject; 块概念上，匿名函数，lambda，closure（或OC中的blocks）是一个东西。详见：浅析匿名函数、lambda表达式、闭包（closure）区别与作用 块是以插入字符 ^ 开头为标识的。后面跟的一个括号表示块所需要的参数列表。同样，也可以将这个块赋给一个变量。举个栗子： 123456789...__block int foo = 10;void (^printFoo)(void) = ^(void) &#123; foo = 20; NSLog(@"foo = %i", foo); &#125;;printFoo(); 如果要试图在块内部改变变量的值，需要在定义本地变量之前插入 __block 修改器。 数字、字符串和集合在Foundation框架包括大量的类、方法和函数。可以通过这条代码来导入：#import &lt;Foundation/Foundation.h&gt; 里面的东西就相当于C++的标准库似的。使用的时候看看文档就好了。 数字对象NSNumber类包含多个方法，可以使用初始值创建NSNumber对象。 NSNumber 的创建方法和检索方法： 创建和初始化方法 初始化实例方法 检索实例方法 numberWithChar; initWithChar; charValue numberWithUnsignedChar; initWithUnsignedChar; unsignedCharValue numberWithShort; initWithShort; shortValue numberWithUnsignedShort; initWithUnsignedShort; unsignedShortValue numberWithInteger; initWithInteger; integerValue numberWithUnsignedInteger; initWithUnsignedInteger; unsignedIntegerValue numberWithInt; initWithInt; intValue numberWithUnsignedInt; initWithUnsignedInt; unsignedIntValue numberWithLong; initWithLong; longValue numberWithUnsignedLong; initWithUnsignedLong; unsignedLongValue numberWithLongLong; initWithLongLong; longLongValue numberWithUnsignedLongLong; initWithUnsignedLongLong; unsignedLongLongValue numberWithFloat; initWithFloat; floatValue numberWithDouble; initWithDouble; doubleValue numberWithBool; initWithBool; boolValue OC是允许通过@表达式创建数字对象的。 举栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Foundation/Foundation.h&gt;int main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSNumber *myNumber, *floatNumber, *intNumber; NSInteger myInt; // integer 整值 intNumber = [NSNumber numberWithInteger: 100]; myInt = [intNumber integerValue]; NSLog(@"%li", (long)myInt); // long 整值 myNumber = [NSNumber numberWithLong: 0xabcdef]; NSLog(@"%lx", [myNumber longValue]); // char 整值 myNumber = [NSNumber numberWithChar: 'X']; NSLog(@"%c", [myNumber charValue]); // float 整值 floatNumber = [NSNumber numberWithFloat: 100.00]; NSLog(@"%g", [floatNumber floatValue]); // double myNumber = [NSNumber numberWithDouble: 12345e+15]; NSLog(@"%lg", [myNumber doubleValue]); // 发生错误 NSLog(@"%li", (long)[myNumber integerValue]); // 验证两个 Number 是否相等 if ([intNumber isEqualToNumber: floatNumber] == YES) NSLog(@"Numbers are equal"); &#125;&#125; 字符串对象@”Hello World!” 就是一个字符串对象。即NSString类的对象。特殊情况下，它属于NSConstantString类的常量字符串对象。NSConstantString类是字符串对象NSString类的子类 description 方法可以使用格式化字符%@显示数组、字典和集合的全部内容。事实上，通过覆盖集成的description方法，还可以使用这些格式字符显示你自己的类对象。如果不覆盖方法，NSLog仅仅显示类名和该对象在内存中的地址，这是从NSObject类继承的description方法的默认实现。 举个栗子： 1234567891011121314151617181920212223242526@interface Fraction : NSObject@ property int numberator, denominator;- (void) setNumerator: (int)numerator andDenominator: (int) denominator;- (NSString *) description;@end@implementation Fraction- (void) setNumerator: (int)numerator andDenominator: (int)denominator &#123; self.numerator = numerator; self.denominator = denominator;&#125;- (NSString *) description &#123; return [NSString stringWithFormat:@"%i/%i", self.numerator, self.denominator];&#125;@endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f = [Fraction new]; [f setNumerator:1 andDenominator:2]; NSLog(@"%@", f); &#125; return 0;&#125; 结果：2016-06-28 16:26:08.873 Learn[18105:485920] 1/2 可变对象与不可变对象@”Hello World!”创建字符串对象时，会创建一个内容不可更改的对象，称为不可变对象，可以使用NSString类处理不可变字符串。若要需要经常处理字符串并更改字符串中的字符，可以使用NSMutableString类处理 数组对象可变数组：NSArray不可变数组：NSMutableArray 挺简单的…使用的时候看看文档就行了.. 这里就说一下排序：利用NSArray数组排序的方法很容易实现。这里以NSMutableArray为例子：在NSMutableArray类中sortUsingSelegtor: 的方法很容易实现。举个栗子: 1234567- (NSComparisonResult) compareNames: (id) element &#123; return [name compare: [element name]];&#125;- (void) sort &#123; [book sortUsingSelector: @selector (compareNames)];&#125; sortUsingSelector: 方法会使用selector比较两个元素。由于数组可以包含任何类型的对象，所以要实现一般的排序方法，唯一途径就是由你来判断数组中的元素是否有序，为此，你必须添加一个方法比较数组中的两个元素。 这个方法返回的结果是NSComparisonResult类型的值。如果希望排序方法将第一个元素放在第二个元素之前，那么方法的返回值应是NSOrderedAscending。如果认为这两个元素相等，那么返回NSOrderedSame。如果排序后的数组中，第一个元素应该在第二个元素之后，那么返回NSOrderedDescending。 也阔以使用块排序：SortUsingComparator: (NSComparator) block;NSComparator 作为typedef定义在系统头文件中：Typedef NSComparisonResult (^NSComparator) (id obje1, id obj2);NSComparator 是一个区块，使用两个对象作为参数，并返回NSComparisonResult类型的值。 123456- (void) sort &#123; [book SortUsingComparator: ^(id obj1, id obj2) &#123; return [[obj1 name] compare: [obj2 name]]; &#125;];&#125; NSValue 类像数组这样的Foundation集合只能存储对象，而有些类型是源于C语言的一种数据类型，比如结构，它不是对象。我们可以利用 NSValue 把结构包装（wrapping）成对象。逆向的处理是从对象中解出基本类型，简称展开（unwrapping）。 NSValue 包装和展开方法 Typedef 数据类型 描述 包装方法 展开方法 CGPoint x 和 y 值组成的点 valueWithPoint; pointValue CGSize 宽和高组成的尺寸 valueWithSize; sizeValue CGRect 矩形包含原点和尺寸 valueWithRect; rectValue NSRange 描述位置和大小的范围 valueWithRange; rangeValue 词典对象词典是由键-对象对儿组成的数据集合。概念和C++里面的std::map一样。词典中的键必须是单值的，通常他们是字符串，但也可以是其他对象类型，和键关联的值可以使任何对象类型，但不能是nil。 不可变字典：NSDictionary可变字典：NSMutableDictionary [NSMutableDictionary dictionary]; 创建一个空字典 其他也挺简单的，使用上也和map差不多。看看文档就好了~ 集合对象set是一组单值对象集合，它可以是可变的，也可以是不可变的。操作包括：搜索、添加、删除集合中的成员（仅可变集合），比较两个集合，计算两个集合的交集和并集等。 也是和C++里面的std::set差不多 Foundation框架同样提供了一个名为NSCountedSet的类，这种集合同一对象可以出现多次，然而并非在集合众存在多次这个对象，而是维护一个计数值。 使用文件管理文件和目录：NSFileManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSDictionary *attr; NSError *err; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@"File doesn't exist!"); return 1; &#125; // 创建一个副本 // 这里要注意下比较坑，如果同名文件存在，是会copy失败的 // 而且返回的失败信息是 testfile 文件不存在.... if ([fm copyItemAtPath: fName toPath: @"newfile" error: &amp;err] == NO) &#123; NSLog(@"File Copy failed!, %@", err); return 2; &#125; // 测试两个文件是否一致 if ([fm contentsEqualAtPath: fName andPath: @"newfile"] == NO) &#123; NSLog(@"Files are not equal!") return 3; &#125; // 重命名副本 if ([fm moveItemAtPath:@"newfile" toPath:@"newfile2" error:&amp;err] == NO) &#123; NSLog(@"File rename failed"); return 4; &#125; // 获取 newfile2 的大小 if ((attr = [fm attributesOfItemAtPath:@"newfile2" error:&amp;err]) == nil) &#123; NSLog(@"Couldn't get file attributes!"); return 5; &#125; NSLog(@"File size is %llu bytes", [[attr objectForKey:NSFileSize] unsignedLongLongValue]); // 最后删除原始文件 if ([fm removeItemAtPath:fName error:&amp;err] == NO) &#123; NSLog(@"file removal failed"); return 6; &#125; NSLog(@"All operations were successful"); // 显示新创建的文件内容 NSLog(@"%@", [NSString stringWithContentsOfFile:@"newfile2" encoding:NSUTF8StringEncoding error:&amp;err]); &#125; return 0;&#125; 使用 NSData 类使用文件时，需要频繁的将数据读入到一个缓冲区，Foundation的NSData类提供了一种简单的方式，它用来设置缓冲区，将文件的内容读入缓冲区，或将缓冲区的内容写到一个文件。据说，据说哈，32位应用的NSData缓冲区最多可存储2G的数据。64位的最多可存储8EB的数据… 举例子： 1234567891011121314151617181920212223242526272829303132333435int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSData *fileData; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@"File doesn't exist!"); return 1; &#125; // 读取文件 fileData = [fm contentsAtPath:fName]; if (fileData == nil) &#123; NSLog(@"File read failed!"); return 2; &#125; // 将数据写入 newfile3 if ([fm createFileAtPath:@"newfile3" contents:fileData attributes:nil] == NO) &#123; NSLog(@"couldn't create the copy!"); return 3; &#125; NSLog(@"File copy was successful!"); &#125; return 0;&#125; 枚举目录中的内容123456789101112131415161718192021222324252627282930int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"~/Documents/testfile"; NSFileManager *fm; NSDirectoryEnumerator *dirEnum; NSArray *dirArray; // 把短路径转换成全路径 fName = [fName stringByExpandingTildeInPath]; fm = [NSFileManager defaultManager]; dirEnum = [fm enumeratorAtPath:path]; NSLog(@"contents of %@", path); while ((path = [dirEnum nextObject]) != nil) &#123; NSLog(@"%@", path); &#125; NSLog(@"-----------------------------------"); // 另一种遍历方法 dirArray = [fm contentsOfDirectoryAtPath:[fm currentDirectoryPath] error:NULL]; NSLog(@"contents using contentsOfDirectoryAtPath:error:"); for (path in dirArray) &#123; NSLog(@"%@", path); &#125; &#125; return 0;&#125; 这两种枚举技术的不同在于：enumeratorAtPath: 方法列出了目录中的内容，包含子目录contentsOfDirectoryAtPath:error: 方法不会列出子目录内容 使用路径：NSPathUtilities.h123456789101112131415161718192021222324252627282930313233343536int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @"path.m"; NSFileManager *fm= [NSFileManager defaultManager]; NSString *path, *tempdir, *extension, *homedir, *fullpath; NSArray *components; // 获取临时目录 tempdir = NSTemporaryDirectory(); NSLog(@"tempoary directory is %@", tempdir); // 从当前目录中提取基本目录 path = [fm currentDirectoryPath]; NSLog(@"Base dir is %@", [path lastPathComponent]); // 创建 fName 在当前目录的完整路径 fullpath = [path stringByAppendingPathComponent:fName]; NSLog(@"fullpath to %@ is %@", fName, fullpath); // 获取文件扩展名 extension = [fullpath pathExtension]; NSLog(@"extension for %@ is %@", fullpath, extension); // 获取用户主目录 homedir = NSHomeDirectory(); NSLog(@"Your home directory is %@", homedir); // 拆分路径为各个组成部分 components = [homedir pathComponents]; for (path in components) &#123; NSLog(@"%@", path); &#125; &#125; return 0;&#125; Foundation框架的NSSearchPathForDirectoriesInDomains 函数，用于获取系统的特殊目录，如 Application 和 Documents 目录。 12NSArray *dirList = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docDir = dirList[0]; 例子就是获取一个Documents目录。函数的第二个参数可以是多个值，用于指定需要列出的目录，如用户的，系统的或者所有目录。最后一个参数用于指定是否展开路径中的~字符 NSSearchPathForDirectoriesInDomains返回一组路径的数组，如果仅是查找用户的目录，这个数组只包含一个元素，如果第二个参数指定多个值，该数组会包含多个元素。 当为Ios编写程序时，NSSearchPathForDirectoriesInDomains函数第二个参数应是NSUserDoMainMask,并希望得到一个包含单个路径的数组作为返回。 常用的 iOS 目录 目录 用途 Documents (NSDocumentDirectory) 用于写入应用相关数据文件的目录。在 iOS 中写入这里的文件能够与 iTunes 共享并访问，存储在这里的文件会自动备份到 iCloud Library/Caches (NSCachesDirectory) 用于写入应用支持文件的目录，保存应用程序再次启动需要的信息。iTunes 不会对这个目录的内容进行备份 tmp (use NSTemporaryDirectory()) 这个目录用于存放临时文件，在程序终止时需要移除这些文件。当应用程序不再需要这些临时文件时，应该将其从这个目录删除 Library/Preferences 这个目录包含应用程序的偏好设置文件。使用 NSUserDefaults 类进行偏好设置文件的创建、读取和修改 使用 NSProcessInfo 类NSProcessInfo 类方法 方法 描述 +(NSProcessInfo *) processInfo 返回当前进程信息 -(NSArray *) arguments 以 NSString 对象数组的形式返回当前进程参数 -(NSDictionary *) environment 返回变量/值对字典，以描述当前的环境变量，比如 PATH 和 HOME 及其值 -(int) processIdentifier 返回进程标识符，它是操作系统赋予进程的唯一数字，用于标识每个正在运行的进程 -(NSString *) processName 返回当前正在执行的进程名称 -(NSString *) globallyUniqueString 每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名 -(NSString *) hostname 返回主机系统名称 -(NSUInteger) operationsSystem 返回表示操作系统的数字 -(NSString *) operationsSystemName 返回操作系统名称 -(NSString *) operationsSystemVersionString 返回操作系统的当前版本 -(void) setProcessName: (NSString *) name 将当前进程名称设置为 name，应该谨慎的使用这个方法，因为关于进程名称存在一些假设，比如用户默认设置 深拷贝，实现 协议如果我们要实现深拷贝，就要根据协议实现其中一两个方法。实现协议是，类必须实现copyWithZone: 方法来响应copy消息（这条copy消息仅将一条带有nil参数的copyWithZone:消息发送给你的类）。如果要想区分可变不可变副本，还要根据协议实现mutableCopyWithZone: 方法。产生对象的可变副本并不要求被复制的对象本身也是可变的（反之亦然）。 举例子： 1234567891011121314151617181920212223242526272829...- (id) copyWithZone: (NSZone* ) zone &#123; // 如果类产生子类，那么这个方法将被继承 // 这种情况下，应该使用 [self class] // 即从该类分配一个新对象，而不是 copy 的接收者 Fraction *newFract = [[[self class] allocWithZone: zone] init]; [newFract setTo: numerator over: denominator]; return newFract;&#125;...int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f1 = [Fraction new]; Fraction *f2; [f1 setTo:2 over:5]; f2 = [f1 copy]; [f2 setTo:1 over:3]; [f1 print]; [f2 print]; &#125; return 0;&#125; Cocoa 和 Cocoa Touch 简介Cocoa 是一种为Mac OS X应用程序提供了丰富用户体验的框架，实际上由3个框架组成：Foundation框架、便于使用数据库存储和管理数据的Core Data框架，以及Application Kit (AppKit)框架。AppKit 框架提供了与窗口、按钮、列表等相关的类。 框架层 内核以设备驱动程序的形式提供与硬件的底层通信。它负责管理系统资源，包括调度需要执行的程序、管理内存和电源，以及执行基本的I/O操作。 核心服务提供的支持比它上面层次更加底层或更加“核心”。例如提供对集合、网络、调试、文件管理、文件夹、内存管理、线程、时间和电源的管理。 应用层包含打印和图形渲染的支持，包括Quartz、OpenGL、和 Quicktime。 Cocoa层位于应用程序层之下。Cocoa包括Foundation、Core Data 和 AppKit框架。Foundation框架提供处理集合、字符串、内存管理、文件系统、存档等相关的类。AppKit框架提供管理视图、窗口、文档和多用户界面相关的类。 Cocoa TouchCocoa框架应用于Mac OS X桌面与笔记本电脑应用程序的开发，而Cocoa Touch框架应用于iOS设备上应用程序的开发。 Cocoa 和 Cocoa Touch 都有 Foundation 和 Core Data 框架。然而在Cocoa Touch下，UIKit代替了AppKit框架。提供了很多相同类型对象的自持。比如窗口、视图、按钮、文本域等。另外Cocoa Touch 还提供使用陀螺仪和加速器的类和触摸式界面。去掉了不需要的类。 引用参考 《Objective-C程序设计，第六版》《Objective-C维基百科》《iOS开发60分钟入门》]]></content>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改 Bash on Ubuntu on Windows 的默认 shell]]></title>
    <url>%2FStaticBlog%2F2016%2F08%2F28%2F%E6%9B%B4%E6%94%B9-Bash-on-Ubuntu-on-Windows-%E7%9A%84%E9%BB%98%E8%AE%A4-shell%2F</url>
    <content type="text"><![CDATA[引用参考 How to Use Zsh (or Another Shell) in Windows 10 这里以 zsh 为例： vim ~/.bashrc 添加如下内容到 #for examples 注释下面，并保存 1234# Launch Zshif [ -t 1 ]; thenexec zshfi 退出bash，到cmd，重新bash进入]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挖坑——开发计划]]></title>
    <url>%2FStaticBlog%2F2016%2F08%2F27%2F%E6%8C%96%E5%9D%91%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[先给自己挖坑，以后慢慢填…不定期更新和补充… KSTL——内核版STL 重载 new / delete 标准类型重定义 Allocator function bind iterators 和 Traits vector list deque、stack、queue heap、pripority queue tuple 红黑树 set、multiset map、multimap hashtable hashset、hashmap string R0 &lt;-&gt; R3 通讯框架 minifilter 框架 object 相关框架 WFP 框架 Intel-VT 框架 AMD-SVM 框架 …]]></content>
      <tags>
        <tag>挖坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 阅读书单]]></title>
    <url>%2FStaticBlog%2F2016%2F08%2F21%2F2016-%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[这里记录的都是我2016年阅读的书籍，但是各种未成书的文档就不在这里记录了… 技术类 《深入理解C++11：C++11新特性解析与应用》 [读完]2016.04 适合有C++基础上，学习C++11的新特性。这本书系统的讲解了C++11新标准中的所有语言新特性、新标准库特性、对原有特性的改进，以及如何应用这些新特性。 《Objective-C程序设计6》 [读完]2016.06 本来公司需要iOS，可是学完就改了需求，不需要了….三天即可看完..了解下与C++之间的区别，超级简单.. 《iOS开发指南：从零基础到AppStore上架3》 [读完]2016.06 也是iOS学习一系列的..4天看完，能够走一遍iOS基本开发流程…另外，学习iOS建议好好看一遍官方文档.. 《图解HTTP》 [读完]2016.07 为了写爬虫学的..半天就看完，非常简单。能够了解HTTP基本概念和规范，适合初学了解。 《Python Cookbook3》 [读完]2016.08 非常实用的一本书，里面讲了各种问题场景的解决方案，实乃编码必备好书。在写Python的时候遇到的很多问题都是在这里找到的方案。 《编写高质量代码：改善Python程序的91个建议》 [读完]2016.08 作为有强迫症的人，一定要看..教你如何写更 Pythonic 的代码，另外还建议阅读 PEP8 《C++并发编程实战》 [在读]2016.09 听说，翻译的不好。所以建议读英文版。或者GitBook有第三方翻译的版本。这本书是基于 C++11 新标准的并发和原子库的内容。可以学习新标准库的使用，以及在使用过程中需要注意的地方。这是一本神书.. 《STL 源码剖析》 [在读]2016.09 虽然书听老的，但是里面的设计思想不会过时，不会影响对 STL 的理解。我看这本书主要就是因为前两天挖的坑..写一套 内核版STL..干巴得~ 非技术类 《三体》 [读完]2016.01 非常好看的一套硬科幻小说，里面涉及到很多物理、历史、数学、哲学的知识，而且许多概念都让我细思极恐..比如黑暗森林。 《上帝在掷骰子吗：量子物理史话》 [读完]2016.05 非常好看的科普类书籍，尤其是对于我这种没上过学而又对物理数学感兴趣的人。这本书能够让你了解物理学的发展历史，里面有很多有趣的物理概念。 《从0到1：开启商业与未来的秘密》 [读完]2016.03 看忘了… 《人类简史：从动物到上帝》 [在读]2016.04 这不是一本简单的历史书，作者从不同的视角来审视人类发展的过程，以及人类所产生的影响，不止如此，里面还有很多很多有趣的东西，非常值得阅读！ 《北京折叠》 [未读]~ 仅仅看了一段话，就让我非常想阅读它.. 未来的穷人连被剥削的价值都没有]]></content>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Writing Solid Python Code》 Notes]]></title>
    <url>%2FStaticBlog%2F2016%2F08%2F02%2FWriting-Solid-Python-Code-Notes%2F</url>
    <content type="text"><![CDATA[《编写高质量代码：改善 Python 程序的 91 个建议》 学习笔记之前自己学了很多次 Python，由于用不到，所以总是学完就忘掉了。刚好最近工作需要用到 Python，就借此机会好好学习了一番。Pyhton 的各种特性和风格让我甚是喜欢。不过我总是感觉自己写的代码不是那么漂亮，不够 Pythonic。所以我想通过学习一些经典建议来让我有个思路。 建议 1：理解 Pythonic 概念对于 Pythonic 的概念，大家心中的指南就是 Tim Peters 的 《The Zen of Python》（Python 之禅）。下面几点来自其中的内容： 美胜丑，显胜隐，简胜杂，平胜陡，疏胜密。 找到简单问题的一个方法，最好是唯一的方法（正确的解决之道）。 难以解释的实现，源自不好的主意；如有非常棒的主意，它的实现肯定易于解释。 代码风格建议参考 PEP8 和 Python 风格指南比如： 包和模块的命名采用小写、单数形式，而且短小。 包通常仅作为命名空间，如只包含空的 __init__.py 文件 建议 2：编写 Pythonic 代码 要避免劣化代码 避免只用大小写来区分不同的对象 避免使用容易引起混淆的名称比如，重复使用已经存在于上下文中的变量名来表示不同的类型；误用了内建名称来表示其他含义的名称而使之在当前命名空间被屏蔽；没有构建新的数据类型的情况下使用类似于 element、list、dict等作为变量名；使用o、l、等作为变量名。 不要害怕过长的变量名，可读性更重要 深入认识 Python 有助于编写 Pythonic 代码 全面掌握 Python 提供给我们的所有特性，包括语言特性和库特性。 学习每个 Python 新版本提供的新特性，使用 Python 推荐的惯用法来完成任务 深入学习业界公认的比较 Pythonic 的代码，比如 Flask、gevent 和 requests 等。 使用工具来达到检查和约束，比如我个人使用 Pycharm IDE 来写 Python，对代码风格的要求挺严格的… 建议 3：理解 Python 与 C 语言的不同之处我们都知道，Python 底层是用 C 语言实现的，但切忌用 C 语言的思维和风格来编写 Python 代码。尤其重要的是，不要使用之前的编程思想。 “缩进”与“{}”与 C、C++、Java 等语言使用花括号来分隔代码段不同，Python 中使用严格的代码缩进方式分隔代码块。另外，建议 Tab 替换成 4 个空格，不要混用 Tab 键和空格。 ‘ 与 “C 语言中单引号 &#39; 与双引号 &quot; 由严格的区别，单引号代表一个字符，它实际对应于编译器所采用的字符集中的一个整数值。而双引号则表示字符串，默认以 \0 结尾。但是在 Python 中，单引号与双引号没有明显区别。 三元操作符 “?:”三元操作符是 if…else 的简写方法，语法形式为 C ? X: Y，而在 Python 中的等价形式为 X if C else Y switch…casePython 中没有像 C 语言那样的 switch…case 分支语句。不过在 Python 中有很多替代的解决方法： C1234567891011121314switch(n) &#123; case 0: printf("You typed zero.\n"); break; case 1: printf("You are in top.\n"); break; case 2: printf("n is an even number.\n"); break; default: printf("Only single-digit numbers are allowed.\n"); break;&#125; Python12345678if n == 0: print("You typed zero.")elif n == 1: print("You are in top.")elif n == 2: print("n is an even number.")else: print("Only single-digit numbers are allowed.) 或者123456def f(n): return &#123; 0: "You typed zero.", 1: "You are in top.", 2: "n is an even number." &#125;.get(n, "Only single-digit numbers are allowed.") Python 和其他语言的差异远不止这些。但总归一句话：不要被其他语言的思维和习惯困扰，掌握 Python 的这些和思维方式才是硬道理。 建议 4：在代码中适当添加注释Python 中有三种形式的代码注释：块注释、行注释以及文档注释（docstring）。这三种注释的惯用法大概如下几种： 使用块或行注释的时候仅仅注释那些复杂的操作、算法，还有可能别人难以理解的技巧或者不够一目了然地代码。 注释和代码隔开一定的距离，同时在块注释之后最好多留几行空白再写代码。 给外部可访问的函数和方法添加文档注释，无论简单与否。注释要清楚地描述方法的功能，并对参数、返回值以及可能发生的异常进行说明，使得外部调用它的人员仅仅看docstring就能正确使用。较为复杂的内部方法也需要进行注释。 推荐在文件头中包含 copyright 申明、模块描述等，如有比较可以考虑加入作者信息及变更记录。 建议 5：通过适当添加空行使代码布局更为优雅、合理Python 代码布局也有一些基本规则可以遵循（PEP8 中有详细规范..）： 在一组代码表达完一个完整的思路之后，应该用空白行进行间隔。如每个函数之间，导入声明、变量赋值等。 尽量保持上下文语义的易理解性 避免过长的代码行，每行最好不要超过 80 字符。 不要为了保持水平对其而使用多余的空格 （写C/C++就有这习惯…） 空格的使用要能够在需要强调的时候竟是读者，在疏松关系的实体间起到分隔作用。 二元运算符、布尔运算的左右两边应该有空格 逗号和分号前不要使用空格 函数名和左括号之间、序列索引操作时序列名和 [] 之间不需要空格，函数的默认参数两侧不需要空格。 强调前面的操作符的时候使用空格 建议 6：编写函数的 4 个原则 原则 1 函数设计要尽量短小，嵌套层次不宜过深。 原则 2 函数申明应该做到合理、简单、易于使用。 原则 3 函数参数设计应该考虑向下兼容。 原则 4 一个函数只做一件事儿，尽量保证函数语句粒度的一致性。 Python 中函数设计的好习惯还包括：不要再函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。 建议 7：将常量集中到一个文件Python 中使用常量一般有以下两种方式： 通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下划线连接各个单词，如 MAX_OVERFLOW，这只是一种约定俗成的风格。 通过自定义的类实现常量功能。这要求符合“命名全部为大写”和“值一旦绑定便不可再修改”这两个条件。12345678910111213class _const: class ConstError(TypeError): pass class ConstCaseError(ConstError): pass def __setattr__(self, name, value): if self.__dict__.has_key(name): raise self.ConstError, "Can't change const.&#123;&#125;".format(name) if not name.isupper(): raise self.ConstCaseError, 'const name "&#123;&#125;" is not all uppercase'.format(name) self.__dict__[name] = valueimport syssys.modules[__name__] = _const() 如果上面的代码对应的模块名为 const，使用的时候只需要 import const，便可直接定义常量了，如下代码：12import constconst.COMPANY = "IBM" 建议 8：利用 assert 语句来发现问题断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便的检查程序的异常或者发现不恰当的输入等，可防止意想不到的情况出现。 对 Python 中使用断言需要说明如下： debug 的值默认设置为 True，而且是只读的。 断言是有性能影响的。Python 可以在运行脚本时通过 -O 标识来禁用断言。比如 Python -O test.py 断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此食用断言需要注意以下几点： 不要滥用，这是使用断言最基本的原则。 如果 Python 本身的异常能够处理就不要再使用断言。断言没有明确的异常类型。 不要使用断言来检查用户的输入。 在函数调用后，当需要确认返回值是否合理时可以使用断言。 当条件是业务逻辑继续下去的先决条件时可以使用断言。 建议 9：数据交换值得时候不推荐使用中间变量建议 10：充分利用 Lazy evaluation 的特性Lazy evaluation 常被译为“延迟计算”或“惰性计算”，值得是仅仅在真正需要执行的时候才会计算表达式的值。充分利用 Lazy evaluation 的特性带来的好处有两个方面： 避免不必要的计算，带来性能上的提升。 节省空间，使得无限循环的数据结构成为可能。 建议 11：理解枚举替代实现的缺陷在 Python 3.4 之前，并没有提供枚举类型。所以人们充分利用 Python 的dong’tai动态性这个特征，行除了美剧的各种替代实现： 使用类属性 12class Seasons: Spring, Summer, Autumn, Winter = range(4) 借助函数 12def enum(*posarg, **keysarg): return type("Enum", (object,), dict(zip(posarg, xrange(len(posarg))), **keysarg)) 使用 collections.nametuple 1Seasons = namedtuple(&apos;Seasons&apos;, &apos;Spring Summer Autumn Winter&apos;)._make(range(4)) 但是这些替代有其不合理的地方： 允许枚举值重复 支持无意义的操作，比如相加 在3.4之后，加入了枚举 Enum，其实现主要参考 flufl.enum，但两者之间存在一些差别。 建议 12：不推荐使用 type 来进行类型检查基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。任意泪的实例的 type() 返回结果都是 &lt;type &#39;instance&#39;&gt;。我们可以使用 isinstance() 函数来检测类型。 建议 13：尽量转换为浮点类型后再做除法建议 14：警惕 eval() 的安全漏洞Python 中 eval() 函数将字符串 str 当初有效的表达式来求值并返回计算结果。其函数声明如下：eval(expression[, globals[, locals]])其中参数 globals 为字典形式，locals 为任何映射对象，他们分别表示全局和局部命名空间。如果传入 globals 参数的字典中缺少 __builtins__ 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。locals 参数默认与 globals 相同，如果两者都省略的话，表达式将在 eval() 调用的环境中执行。 如果使用对象不是信任源，应该尽量避免使用 eval，在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。 建议 15：使用 enumerate() 获取序列迭代的索引和值建议 16：分清 == 与 is 的适用场景 操作符 意义 is object identity == equal is 表示的是对象标识符 (object identity)，而 == 表示的意思是相等。is 的作用是用来检查对象的标识符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间。== 才是用来检验两个对象的值是否相等的，它实际调用内部 __eq__() 方法。 建议 17：考虑兼容性，尽可能使用 Unicode建议 18：构建合理的包层次来管理 module什么是包？简单说包即是目录，但是与目录不同，它除了包含常规的 Python 文件以外，还包含一个 __init__.py 文件，同时它允许嵌套。包有以下几种导入方法： 直接导入一个包import Package 导入子模块或子包，包嵌套的情况下可以进行嵌套导入12from Package import Module1import Package.Module1 包的使用能够带来以下便利： 合理组织代码，便于维护和使用 能够有效的避免命名空间冲突 建议 19：有节制的使用 from…import 语句在使用 import 的时候注意以下几点： 一般情况下尽量优先使用 import a 形式 有节制地使用 from a import B 形式，可以直接访问 B 尽量避免使用 from a import *，因为这会污染命名空间，并且无法清晰的表示导入了哪些对象 当加载一个模块的时候，解释器实际上要完成以下动作： 在 sys.modules 中进行搜索看看模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。 如果在 sys.modules 中找不到对应的模块名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入 sys.modules 中。 加载钱确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。 对于 from…import 无节制的使用会带来什么问题： 命名空间的冲突 循环嵌套导入的问题 建议 20：优先使用 absolute import 来导入模块建议 21：i+=1 不等于 ++iPython 中是不支持概念中 ++i 操作的。但是如果你这么写，会被 Python 解释成 +(+i)，其中 + 表示正号 建议 22：使用 with 自动关闭资源with 语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有 with 语句的代码块的执行过程如下： 计算表达式的值，返回一个上下文管理器对象。 加载上下文管理器对象的 __exit__() 方法以备后用 调用上下文管理器对象的 __enter__() 方法 如果 with 语句中设置了目标对象，则将 __enter__() 方法的返回值赋值给目标对象 执行 with 中的代码块 如果步骤5中代码正常结束，调用上下文管理器的 __exit__() 方法，其返回值直接忽略。 如果步骤5中代码执行过程中发生异常，调用上下文管理器的 __exit__() 方法，并将异常类型、值及 traceback 信息作为参数传递给 __exit__() 方法。如果 __exit__() 返回值为 False，则异常会重新抛出；如果其返回值为 True，异常被挂起，程序继续执行。 建议 23：使用 else 子句简化循环（异常处理）建议 24：遵循异常处理的几点基本原则 注意异常的粒度，不推荐在 try 中放入过多的代码。 谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。 注意异常捕获的顺序，在合适的层次处理异常。推荐的方法是将继承结构中子类异常在前面的 except 语句中抛出，而父类异常在后面的 except 语句中抛出。 使用更为友好的异常信息，遵循异常参数的规范。 建议 25：避免 finally 中可能发生的陷阱在实际应用程序开发过程中，并不推荐在 finally 中使用 return 语句或 break 进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。 建议 26：深入理解 None，正确判断对象是否为空Python 中以下数据会当作空来处理： 常量 None 常量 Flase 任何形式的数值类型零，如0、0L、0.0、0j 空的序列，如 ‘’、()、[] 空的字典，如 {} 当用户定义的类中定义了 nonzero() 方法和 len() 方法，并且该方法返回整数0或者布尔值 False 的时候。 其中常量 None 的特殊性体现在它既不是0、False，也不是空字符串，他就是一个空值对象。其数据类型为 NoneType，遵循单例模式，是唯一的，因而不能创建 None 对象。所有赋值为 None 的变量都相等，并且 None 与任何其他非 None 的对象比较结果都为 False 错误的比较12345test_list = []if test_list is not None: print('list is:', test_list)else: print('list is empty') 正确的比较12345test_list = []if test_list: print('list is:', test_list)else: print('list is empty') 建议 27：连接字符串应优先使用 join 而不是 +jion 的效率要高于 + 操作符jion 的时间复杂度为O(n), + 的时间复杂度为 O(n^2) 建议 28：格式化字符串时尽量使用 .format 方式而不是 %% 操作符格式化字符串时有如下几种用法： 直接格式化字符或者数值 1print('your score is %06.1f' % 9.5) 以元组的形式格式化 12import mathprint('the %s of a circle with radius %f is %0.3f' %('circumference', 3, math.pi*radius*2)) 以字典的形式格式化 12itemdict = &#123;'itemname': 'circumference', 'radius': 3, 'value': math.pi*radius*2&#125;print('the %(itemname)s of a circle with radius %(radius)f is %(value)0.3f' % itemdict) .format 方式格式化字符串的基本语法为：[[填充符] 对齐方式][符号][#][0][宽度][,][.精确度][转换类型]其中填充符可以是除了 { 和 } 符号之外的任意符号。 对其方式 解释 &lt; 表示左对其，是大多数对象为默认的对其方式 &gt; 表示右对其，数值默认的对其方式 = 仅对数值类型有效，如果有符号的话，在符号后数值前进行填充，如-0029 ^ 居中对其，用空格进行填充 符号 解释 + 正数前加 +，负数前加 - - 正数前不加符号，负数前加 -，为数值的默认形式 空格 正数前加空格，负数前加 - .format 常用用法： 使用位置符号 使用名称 通过属性 123456789101112class Customer(object): def __init__(self, name, gender, phone): self.name = name self.gender = gender self.phone = phone def __str__(self): # 通过 str() 函数返回格式化的结果 return 'Customer(&#123;self.name&#125;,&#123;self.gender&#125;,&#123;self.phone&#125;)'.format(self=self)str(Customer('Lisa', 'Female', '67889'))'Customer(Lisa, Female, 67889)' 格式化元组的具体项 1234point = (1,3)'X:&#123;0[0]&#125;;Y:&#123;0[1]&#125;'.format(point)'X:1;Y:3' 使用 .format 的理由： format 方式在使用上较 % 操作符更为灵活 format 方式可以方便的作为参数传递 % 最终会被 .format 方式所替代 % 方法在某些情况下使用时需要特别小心 建议 29：区别对待可变对象和不可变对象数字、字符串、元组属于不可变对象字典、列表、字节数组属于可变对象 看一个经典例子：1234567891011121314151617181920212223242526272829303132class Student(object): def __init__(self, name, coures=[]): self.name = name self.course = coures def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item)def main(): stu_a = Student('Wang yi') stu_a.add_course('English') stu_a.add_course('Math') print(stu_a.name + "'s course:") stu_a.print_course() print('----------------------------') stu_b = Student('Li san') stu_b.add_course('Chinese') stu_b.add_course('Physics') print(stu_b.name + "'s course:") stu_b.print_course()if __name__ == '__main__': main() 结果123456789101112C:\Users\MeeSong\AppData\Local\Programs\Python\Python35\python.exe C:/Users/MeeSong/Desktop/test/test.pyWang yi's course:EnglishMath----------------------------Li san's course:EnglishMathChinesePhysicsProcess finished with exit code 0 看到没，结果与预想的并不一样。我们通过 id(stu_a.course) 和 id(stu_b.course) (id 是查看对象的内存标识的，即内存地址) 发现两个结果是一样的，说明两个list对象指的是同一块地址。但 stu_a 和 stu_b 本身却是两个不同的对象。在实例化两个对象的时候，这两个对象被分配了不同的内存空间，并且调用 init() 函数进行了初始化。但由于 init() 函数的第二个参数是个默认参数，默认桉树在函数被调用的时候仅仅被评估一次，以后都会使用第一次评估的结果，因此实际上对象空间里面 course 所指向的是同一个list地址。 我们改成这样就好了123456789101112class Student(object): def __init__(self, name, coures=None): self.name = name self.course = coures if coures else [] def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item) 另外，切片操作相当于浅拷贝。 12345678910111213&gt;&gt;&gt; b['a', 'b', 'c', 'd']&gt;&gt;&gt; a['a', 'b', 'c', 'd']&gt;&gt;&gt; id(a[0])2279905391312&gt;&gt;&gt; id(b[0])2279905391312&gt;&gt;&gt; id(a)2279910237896&gt;&gt;&gt; id(b)2279910245384 对于不可变对象，当我们对其进行相关操作的时候，Python 实际上仍然保持原来的值，并重新创建一个新的对象。比如字符串操作 12345678&gt;&gt;&gt; s1 = '123'&gt;&gt;&gt; s2 = s1&gt;&gt;&gt; id(s2)2279910241368&gt;&gt;&gt; id(s1)2279910241368&gt;&gt;&gt; id(s1[:1])2279905395408 建议 30：[]、() 和 {}：一致的容器初始化形式建议使用列表解析来初始化，即列表推导式（或元组和字典）列表推导式的语法为：[expr for iter_item in iterable if cond_expr]元组推导式的语法为：(expr for iter_item in iterable if cond_expr)集合推导式的语法为：{expr for iter_item in iterable if cond_expr}字典推导式的语法为：{exprk:exprv for iter_item in iterable if cond_expr} 12&gt;&gt;&gt; [v**2 if v%2 == 0 else v+1 for v in [2,3,4,-1] if v&gt;0][4, 4, 16] 列表推导式非常灵活： 支持多重嵌套 支持多重迭代 列表推导式的语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至是函数 列表推导式语法中的iterable可以是任意可迭代对象 为什么推荐俺在需要生成列表的时候使用列表推导式呢？ 使用列表推导式更为直观清晰，代码更为简洁 列表推导式的效率更高 建议 31：记住函数传参既不是传值也不是传引用先看两张图 对于在Python函数参数是传值还是传引用这个问题：正确叫法应该是传对象或者说传对象的引用。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象， 由于并不能真正被修改，因此修改往往是通过生成一个新对象然后赋值来实现的 建议 32： 警惕默认参数潜在的问题这个问题同 建议 29：区别对待可变对象和不可变对象 的例子 建议 33：慎用变长参数Python 支持可变长度的参数列表，可以通过在函数定义的时候使用 args 和 *kwargs 这两个特殊语法来实现。 使用 args 来实现可变参数列表： args 用于接收一个包装为元组形式的参数列表来传递非关键字参数，参数个数可以任意。 使用 **kwargs 接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变参数的参数名和值 为什么要慎用可变长度参数呢： 使用过于灵活 如果一个函数的参数列表很长，虽然可以通过使用 args 和 *kwargs 来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。 可变长参数适合在下列情况下使用： 为函数添加一个装饰器 如果参数的数目不确定，可以考虑使用变长参数 用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候 建议 34：深入理解 str() 和 repr() 的区别函数 str() 和 repr() 都可以将 Python 中的对象转换为字符串，他们的使用及输出都非常相似 区别主要有以下几点： 两者之间的目标不同：str() 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型;而 repr() 面向的是Python解释器，或者说开发人员，其目的是准确性，返回值表示 Python 解释器内部的含义，常作为编程人员 debug 用途 在解释器中输入a时，默认调用 repr() 函数，而 print(a) 则调用 str() 函数 repr() 的返回值一般可以用 eval() 函数来还原对象，通常来说有这个等式：obj == eval(repr(obj)) 这两个方法分别调用内建的 __str__() 和 __repr__() 方法，一般来说在类中都应该定义 __repr__() 方法，而 __str__() 方法则为可选，当可读性比准确性更重要的时候应该考虑定义 __str__() 方法。如果类中没有定义 __str__() 方法，则默认会使用 __repr__() 方法的结果来返回对象的字符串形式。用户实现 __repr__() 方法的时候最好保证其返回值可以用 eval() 方法使对象重新还原 建议 35：分清 staticmenthod 和 classmethod 的适用场景静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数 类方法能够根据不同的类型返回对应的类的实例既不跟特定的实例相关，也不跟特定的类相关的时候，用静态方法更合适 建议 36：掌握字符串的基本用法小技巧Python 遇到未闭合的小括号时会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接到一起。12345&gt;&gt;&gt; s = ('SELECT * '... 'FROM atable '... 'WHERE afield="value"')&gt;&gt;&gt; print(s)SELECT * FROM atable WHERE afield="value" 性质判定 方法 描述 isalnum() 是否只是数字或字母 isalpha() 是否字母 isdigit() 是否数字 islower() 是否小写 isupper() 是否大写 isspace() 是否空白符 istitle() 是否标题化的，即每个单词首字母是否大写 startswith(prefix[,start[,end]]) 是否以prefix开头，可范围内检查，prefix可接受tuple类型的实参 endswith(suffix[,start[,end]]) 是否以suffix结尾，可范围内检查，suffix可接收tuple类型的实参 查找 方法 描述 count(sub[,start[,end]]) 查找sub在字符串中出现的次数，这个数值在调用replace方法时用得着 find(sub[,start[,end]]) 查找sub在字符串中的位置，找不到时返回-1 index(sub[,start[,end]]) 同find，不过找不到会抛出 ValueError 异常，另外对于是否包含字串，更推荐使用 in 和 not in 操作符 rfind(sub[,start[,end]]) 同find，从右侧开始 rindex(sub[,start[,end]]) 同index，从右侧开始 替换 方法 描述 replace(old, new[,count]) 把字符串中的old替换为new，count为最多替换次数 translate(table[,deletechars]) 根据table转换字符串的字符，可以由string.maketrans(frm,to)生成；deletechars为过滤掉的字符 分切 方法 描述 partition(sep) 它接受一个字符串参数，并返回一个3个元素的 tuple 对象。如果sep没出现在母串中，返回值是 (sep, ‘’, ‘’)；否则，返回值的第一个元素是 sep 左端的部分，第二个元素是 sep 自身，第三个元素是 sep 右端的部分。 rpartition(sep) splitlines([keepends]) split([sep [,maxsplit]]) 参数 maxsplit 是分切的次数，即最大的分切次数，所以返回值最多有 maxsplit+1 个元素。 rsplit([sep[,maxsplit]]) 不过有一个需要注意的地方对于字符串s、s.split() 和 s.split(‘ ‘) 返回值是不同的1234&gt;&gt;&gt; ' hello world!'.split()['hello', 'world!']&gt;&gt;&gt; ' hello world!'.split(' ')['', 'hello', '', 'world!'] 产生差异的原因在于当忽略 sep 参数或sep参数为 None 时与明确给 sep 赋予字符串值时 split() 采用两种不同的算法。对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串（即连续的空白符串被当作单一的空白符看待）；对于后者则认为两个连续的 sep 之间存在一个空字符串。 连接join() 函数的高效率（相对于循环相加而言），使它成为最值得关注的字符串方法之一。它的功用是将可迭代的字符串序列连接成一条长字符串，如： 123456&gt;&gt;&gt; conf = &#123;'host':'127.0.0.1',... 'db':'spam',... 'user':'sa',... 'passwd':'eggs'&#125;&gt;&gt;&gt; ';'.join("%s=%s"%(k, v) for k, v in conf.iteritems())'passswd=eggs;db=spam;user=sa;host=127.0.0.1' 变形 方法 描述 lower() 转小写 upper() 转大写 capitalize() 把字符串的第一个字符大写 swapcase() 翻转 string 中的大小写 title() 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写 title()函数是比较特别的，它的功能是将每一个单词的首字母大写，并将单词中的非首字母转换为小写（英文文章的标题通常是这种格式）。 12&gt;&gt;&gt; 'hello world!'.title()'Hello World!' 因为title() 函数并不去除字符串两端的空白符也不会把连续的空白符替换为一个空格，所以建议使用string 模块中的capwords(s)函数，它能够去除两端的空白符，再将连续的空白符用一个空格代替。 1234&gt;&gt;&gt; ' hello world!'.title()' Hello World!'&gt;&gt;&gt; string.capwords(' hello world!')'Hello World!' 删减 方法 描述 strip([chars]) 在 string 上执行 lstrip()和 rstrip() lstrip([chars]) 截掉 string 左边的空格 rstrip([chars]) 删除 string 字符串末尾的空格. *strip()函数族用以去除字符串两端的空白符，空白符由string.whitespace常量定义。 填充 方法 描述 center(width[, fillchar]) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串， fillchar 参数指定了用以填充的字符，默认为空格 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 rjust(width[, fillchar]) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 expandtabs([tabsize]) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 编码 方法 描述 encode([encoding[,errors]]) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ decode([encoding[,errors]]) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ 建议 37：按需选择 sort() 或者 sorted()sorted(iterable[, cmp[, key[, reverse]]])s.sort([cmp[, key[, reverse]]]) cmp 为用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable或者list），函数根据第一个参数与第二个参数的关系依次返回 -1、0、+1（第一个参数小于第二个参数则返回负数）。该参数默认值为None。 key 是带一个参数的函数，用来为每个元素提取比较值，默认为None（即直接比较每个元素） reverse 表示结果是否反转 sort() 与 sorted() 之间的比较： 相比于 sort()，sorted() 使用范围更为广泛 当排序对象为列表的时候两者适合的场景不同。sorted() 函数会返回一个排序后的立标，原有列表保持不变；而 sort() 函数会直接修改原有列表，函数返回为 None 无论是 sort() 还是 sorted() 函数，传入参数 key 比传入参数 cmp 效率要高。 sorted() 函数功能非常强大，使用它可以方便的针对不同的数据结构进行排序，从而满足不同需求。对于 itemgetter 的使用，参见 python operator.itemgetter函数与sorted的妙用 对字典进行排序 12345&gt;&gt;&gt; phonebook = &#123;'Linda':'7750', 'Bob':'9345', 'Carol':'5834'&#125;&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted_pb = sorted(phonebook.items(), key=itemgetter(1))&gt;&gt;&gt; sorted_pb[('Carol', '5834'), ('Linda', '7750'), ('Bob', '9345')] 多维 list 排序 1234&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; gameresult = [['Bob', 95.00, 'A'], ['Alan', 86.0, 'C'], ['Mandy', 82.5, 'A'], ['Rob', 86, 'E']]&gt;&gt;&gt; sorted(gameresult, key=itemgetter(2,1))[['Mandy', 82.5, 'A'], ['Bob', 95.0, 'A'], ['Alan', 86.0, 'C'], ['Rob', 86, 'E']] 字典中混合 list 排序 12345678910mydict = &#123;'Li': ['M', 7], 'Zhang': ['E', 2], 'Wang': ['p', 3], 'Du': ['c', 2], 'Ma': ['c', 9], 'Zhe': ['H', 7]&#125;print(sorted(mydict.items(), key=lambda item: itemgetter(1)(itemgetter(1)(item))))[('Zhang', ['E', 2]), ('Du', ['c', 2]), ('Wang', ['p', 3]), ('Li', ['M', 7]), ('Zhe', ['H', 7]), ('Ma', ['c', 9])] list 中混合字典排序 1234567gameresult = [&#123;'name': 'Bob', 'wins': 10, 'losses': 3, 'rating': 75.00&#125;, &#123;'name': 'David', 'wins':3, 'losses': 5, 'rating': 57.00&#125;, &#123;'name': 'Carol', 'wins':4, 'losses': 5, 'rating': 57.00&#125;]print(sorted(gameresult, key=itemgetter('rating', 'name')))[&#123;'wins': 4, 'name': 'Carol', 'losses': 5, 'rating': 57.0&#125;, &#123;'wins': 3, 'name': 'David', 'losses': 5, 'rating': 57.0&#125;, &#123;'wins': 10, 'name': 'Bob', 'losses': 3, 'rating': 75.0&#125;] 建议 38： 使用 copy 模块进行深拷贝对象概念： 浅拷贝（shallow copy）：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式与多种，如工厂函数、切片操作、copy模块中的copy操作。 深拷贝（deep copy）：也是构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。 建议 39：使用 Counter 进行计数统计Counter 类是自 Python2.7 起增加的，属于字典的子类，是一个容器对象，主要用来统计散列对象。 建议 40：深入掌握 ConfigParser建议 41：使用 argparse 处理命令行参数另外，还有更先进好用的 docopt，不过暂时还没加入标准库。详见 docopt 建议 42：使用 pandas 处理大型 CSV 文件CSV(Comma Separated Values) 作为一种逗号分隔符型值的纯文本格式文件，在实际应用中经常用到，如数据库的导入导出、数据分析中记录的存储等。 CSV 处理相关 API： ‘reader(csvfile[, dialect=’excel’][, fmtparam])’，主要用于 CSV 文件的读取，返回一个 reader 对象用于在 CSV 文件内容上进行行迭代 ‘csv.writer(csvfile, dialect=’excel’, **fmtparams)’，用于写入 CSV 文件。 ‘csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect=’excel’, args, *kwds)’，将读入的信息映射到一个字典中去 ‘csv.DictWrite(csvfile, fieldnames, restval=’’, extrasaction=’raise’, dialect=’excel’, args, *kwds)’，用于支持字典的写入。 但是在处理大型 CSV 文件，上面API会抛出 MemoryError 异常。 Pandas 即 Python Data Analysis Library，是为了解决数据分析而创建的第三方工具，支持多种文件格式处理，包括 CSV、HDF5、HTML 等，能够提供高效的大型数据处理。 Series：它是一种类似数据的带索引的一维数据结构，支持的类型与 NumPy 兼容。 DataFrame：类似于电子表格，其数据为排好序的数据列的集合，每一列都可以是不同的数据类型，它类似于一个二维数据结构，支持行和列的索引。 建议 43：一般情况使用 ElementTree 解析 XML 使用简单 内存上消耗明显低于 DOM 解析。 支持 XPath 查询 建议 44：理解模块 pickle 优劣pickle 估计是最通用的序列化模块了，它还有个 C 语言的实现 cPickle，相比 pickle 来说具有较好的性能，其速度大概是 pickle 的 1000 倍，除了不能被继承之外，它们两者的使用基本上区别不大 pickle 中最主要的两个函数对儿为 dump() 和 load()，分别来进行对象的序列化和反序列化： pickle.dump(obj, file[, protocol])：序列化数据到一个文件描述符。 pickle.load(file)：表示把文件中的对象恢复为原来的对象。 pickle 模块的优点： 接口简单，容易使用 pickle 的存储格式具有通用性，能够被不同平台的 Python 解析器共享 支持的数据类型广泛 pickle 模块是可扩展的 能够自动维护对象间的引用，如果一个对象上存在多个引用，pickle 后不会改变对象间的引用 pickle 模块的限制： pickle 不能保证操作的原子性 pickle 存在安全性问题 pickle 协议是 Python 特性的，不同语言之间的兼容性难以保证 建议 45：序列化的另一个不错的选择——JSON相比 pickle，JSON 具有以下优势： 使用简单，支持多种数据类型，仅存在以下两大数据结构： 名称 / 值 对儿的集合 （dict） 值的有序列表 （list） 存储格式可读性更为友好，容易修改。 JSON 支持跨平台跨语言 具有较强的扩展性，JSON 模块还提供了编码（JSONEncoder）和解码类（JSONDecoder），以便用户对其默认不支持的序列化类型进行扩展 建议 46：使用 traceback 获取栈信息常用方法： traceback.print_exception(type, value, traceback[, limit[, file]])，根据 limit 的设置打印栈信息，file 为 None 的情况下定位到 sys.stderr，否则写入到文件；其中 type、value、traceback 这3个参数对应的值可以从 sys.exc_info() 中获取 traceback.print_exc(limit[, file])，为 print_exception 函数的缩写，不需要传入 type、value、traceback 这三个参数 traceback.format_exc([limit])，与 print_exc() 类似，区别在于返回形式为字符串 traceback.extract_stack([file[, limit]])，从当前栈帧中提取 trace 信息。 建议 47：使用 logging 记录日志信息使用见 Python的日志系统 建议 48：使用 threading 模块编写多线程程序实际应用中推荐使用 threading 模块而不是 thread 模块： threading 模块对同步原语的支持更为完善和丰富 threading 模块在主线程和子线程交互上更为友好 thread 模块不支持守护线程 python3 中已经不存在 thread 模块 使用见 Python中使用线程的技巧 建议 49：使用 Queue 使多线程编程更安全建议 50：利用模块实现单例模式建议 51：用 mixin 模式让程序更加灵活建议 52：用发布订阅模式实现松耦合建议 53：用状态模式美化代码建议 54：理解 built-in objectsPython 一切皆对象。自 Python2.2 之后，为了弥补内建类型和古典类之间的鸿沟，引入了新式类。新式类中，object 是所有内建类型的积累，用户定义的类可以继承自 object 也可继承自内建类型。 这里的鸿沟指的是：在 2.2 版本之前，类和类型并不统一，如 a 是古典类 ClassA 的一个实例，那么 a.__class__ 返回 &#39;class__main__ClassA&#39;，type(a) 返回 &lt;type&#39;instalce&#39;&gt;。当引入新类后，比如 ClassB 是个新类，b 是 ClassB 的实例，b.class 和 type(b) 都是返回 &#39;class__main__.ClassB&#39; 新式类相对于古典类来说有很多优势：能够基于内建类型构建新的用户类型，支持 property 和描述符特性等。 建议 55：__init__() 不是构造方法实际上 __init__() 并不是真正意义上的构造方法，__init__()方法所做的工作是在类的对象创建好之后进行变量的初始化。__new__()方法才会真正创建实例，是类的构方法。 两个方法之间的不同点，总结如下： object.__new__(cls[, args...])：其中 cls 代表类，args 为参数列表 object.__init__(self[, args...])：其中 self 代表实例对象，args 为参数列表 __new__() 方法是静态方法，__init__() 为实例方法 __new__() 方法一般需要返回类的对象，当返回类的对象时将会自动调用 __init__() 方法进行初始化，如果没有对象返回，则 __init__() 方法不会被调用。 __init__() 方法不需要显式返回，默认为 None，否则会在运行时抛出 TypeError 当需要控制实例创建的时候可使用 __new__() 方法，而控制实例初始化的时候用 __init__() 方法 一般情况下不需要覆盖 __new__() 方法，但当子类继承自不可变类型，如 str、int、unicode 或者 tuple 的时候，往往需要覆盖该方法。 当需要覆盖 __new__() 和 __init__() 方法的时候这两个方法的参数必须保持一致，如果不一致将会导致异常。 什么特殊情况下需要覆盖 __new__() 方法呢？ 当类继承不可变类型且默认的 __new__() 方法不能满足需求的时候。 用来实现工厂模式或者单例模式或者进行元类便哼的时候 作为用来初始化的 __init__() 方法在多继承的情况下，子类的 __init__() 方法如果不显式调用父类的 __init__() 方法，则父类的 __init__() 方法不会被调用。 建议 56：理解名字查找机制在 Python 中，所有所谓的变量其实都是名字，这些名字指向一个或者多个 Python 对象。 Python 中有 4 中作用域： 局部作用域：一般来说函数的每次调用都会创建一个新的本地作用于，拥有新的命名空间。 全局作用域：定义在Python模块文件中的变量名拥有全局作用域，需要注意的是这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量必须先导入文件对应的模块 嵌套作用域：一般在多重函数嵌套的情况下才会考虑到，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用 global 进行声明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。 内置作用域：通过一个标准库名为 __builtin__ 的模块来实现的。 Python 的名字查找机制如下： 在最内层范围内查找，一般而言就是函数内部，即在 locals() 里面查找 在模块内查找，即在 globals() 里面查找 在外层查找，即在内置模块中查找，也就是在 __builtin__ 中查找 若要修改全局变量，在 Python3 中可以使用 nonlocal 来声明变量 建议 57：为什么需要 self 参数 Python 在当初设计的时候借鉴了其他语言的一些特征，如 Moudla-3 中方法会显示的在参数列表中传入 self。 Python 语言本身的动态性决定了使用 self 能够带来一定便利。 在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分 建议 58：理解 MRO 与多继承建议 59：理解描述符机制建议 60：区别 __getattr__() 和 __getattribute__() 方法__getattr__() 和 __getattribute__() 都可以用作实例属性的获取和拦截（仅对实例属性）__getattr__() 适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在__getattribute__() 对于所有属性的访问都会调用该方法，仅应用于新式类 覆盖这些方法时，几点注意事项： 避免无穷递归。例如：12345def __getattribute__(self, attr): try: return self.__dict__[attr] except KeyError: return 'default' 属性的访问调用的是覆盖的 __getattribute__() 方法，而该方法中 self.__dict__[attr] 又要调用 __getattribute__(self, attr)，于是产生了无穷递归。正确方法是使用 super(obj, self).__getattribute__(attr)。 访问未定义的属性。如果在 __getattribute__() 方法中不抛出 AttributeError 异常或者显示返回一个值，则会返回 None，此时可能会影响到程序的实际运行预期 覆盖了 __getattribute__() 方法之后，任何属性的访问都会调用用户定义的 __getattribute__() 方法，性能上会有损耗 覆盖的 __getattr__() 方法如果能够动态处理事先未定义的属性，可以更好的实现数据隐藏。 __getattribute__() 总是会被调用，而 __getattr__() 只有在 __getattribute__() 中引发异常的情况下才会被调用。 建议 61：使用更为安全的 propertyproperty 是用来实现属性可管理性的 built-in 数据类型，其实质是一种特殊的数据描述符。它和普通描述符的区别在于：普通描述符提供的是一种较为低级的控制属性访问的机制，而 property 是它的高级应用，它以标准库的形式提供描述符的实现，其签名形式为：property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute property 的优势可以简单概括为以下几点： 代码更简洁，可读性更强。 更好的管理属性的访问 代码可维护性更好 控制属性访问权限，提高数据安全性 建议 62：掌握 metaclass什么是元类？ 元类是关于类的类，是类的模板 元类是用来控制如何创建类的，正如类是创建对象的模板一样 元类的实例为类，正如类的实例为对象 元类需要注意的几点： 区别类方法与元方法 多继承需要严格限制，否则会产生冲突 元类用来指导类的生成，元方法可以从元类或者类中调用，不能从类的实例中调用，而类方法既可以从类中调用，也可以从类的实例中调用。 建议 63： 熟悉 Python 对象协议 用以比较大小的协议，这个协议依赖于 __cmp__() 方法，相等返回0，小于返回负值，大于返回正值。还有其他诸如 __eq__()、__ne__()、__lt__()、__gt__() 等方法来实现相等、不等、小于和大于的判定。这也就是 Python 对 ==、!=、&lt; 和 &gt; 等操作符的进行重载的支撑机制 数值类型相关的协议 分类 方法 操作符 / 函数 说明 数值运算符 __add__ + 加 __sub__ - 减 __mul__ * 乘 __div__ / 除 __floordiv__ // 整除 __truediv__ / 真除法，当 __future__.division 起作用时调用，否则调用 __div__ __pow__ ** 幂运算 __mod__ % 模运算 __divmod__ divmod() 余、除 位运算符 __lshift__ &lt;&lt; 向左移位 __rshift__ &gt;&gt; 向右移位 __and__ &amp; 与 __or__ or 那个符号 或 __xor__ ^ 异或 __invert__ ~ 非 运算赋值符 __iadd__ += __isub__ -= __imul__ *= __idiv__ /= __ifloordiv__ //= __itruediv__ /= __ipow__ **= __imod__ %= __ilshift__ &lt;&lt;= __irshift__ &gt;&gt;= __iand__ &amp;= __ior__ \ = __ixor__ ^= 其他 __pos__ + 正 __neg__ - 负 __abs__ abs() 绝对值 容器类型协议。__len__() 支持内置函数 len()__getitem__()、__setitem__()、__delitem__() 对应读、写、删除__iter__() 对应迭代器__reversed__() 支持内置函数 reversed()__contains__() 支持使用 in 和 not in 运算符 可调用对象协议 __call__() 与可调用对象差不多的，还有一个可哈希对象，他是用过 __hash__() 方法来支持 hash() 这个内置函数的 描述符协议和属性交互协议（__getattr__()、__setattr__()、__delattr__()） 上下文管理器协议这个协议通过 __enter__() 和 __exit__() 这两个方法来实现对资源的清理。 建议 64：利用操作符重载实现中缀语法可以安装 pipe 来实现 pip install pipe 建议 65：熟悉 Python 的迭代器协议迭代器协议归纳： 实现 __iter__() 方法，返回一个迭代器 实现 next() 方法，返回当前的元素，并指向下一个元素的为止，如果当前为止已无元素，则抛出 StopIteration 异常 建议 66：熟悉 Python 的生成器如果一个函数使用了 yield 语句，那么它就是一个生成器函数。每一个生成器函数调用之后，它的函数体并不执行，而是到第一次调用 next() 的时候才开始执行，执行到 yield 表达式为止。 建议 67：基于生成器的协程及 greenlet建议 68：理解 GIL 的局限性针对这种，不建议高密集的计算使用多线程，建议堵塞I/O的使用.. 建议 69：对象的管理与垃圾回收Python 使用引用计数器的方法来管理内存中的对象，即针对每一个对象维护一个引用计数值来表示该对象当前有多少个引用。引用计数算法最明显的缺点是无法解决循环引用的问题，即两个对象相互引用。 我们可以使用自带的 gc 模块来跟踪对象的 “入引用” 和 “出引用”。 建议 70：从 PyPi 安装包PyPi 全称 Python Package Index，直译过来就是 Python包索引，它是Python编程语言的软件仓库。 建议 71：使用 pip 和 yolk 安装、管理包建议 72：做 paster 创建包建议 73：理解单元测试概念单元测试带来以下好处： 减少了潜在 bug，提高了代码的质量。 大大缩减软件修复的成本。 为集成测试提供基本保障 有效的单元测试应该从以下几个方面考虑： 测试先行，遵循单元测试步骤。 创建测试计划 编写测试用例，准备测试数据 编写测试脚本 边界被测试代码，在代码完成之后执行测试脚本 修正代码缺陷，重新测试直到代码可接受为止。 遵循单元测试基本原则 一致性 原子性 单一职责 隔离性 使用单元测试框架 unittest。unittest 相关的概念主要有以下四个： 测试固件。测试相关的准备工作和清理工作，基于类 TestCase 差个内奸测试固件的时候通常需要重新实现 setUp() 和 tearDown() 方法。 测试用例。最小的测试单元，通常基于 TestCase 构建 测试用例集，测试用例的集合，使用 TestSuite 类来实现 测试运行器，控制和驱动整个单元测试过程，一般使用 TestRunner 类作为测试用例的基本执行环境，常用的运行器为 TextTestRunner，它是 TestRunner 的子类，以文字方式运行测试并报告结果。 建议 74：为包编写单元测试 nose建议 75：利用测试驱动开发提高代码的可测性测试驱动开发流程： 编写部分测试用例，并运行测试 如果测试用过，则回到测试用例编写的步骤，继续添加新的测试用例 如果测试失败，则修改代码直到测试通过 当所有测试用例编写完成并通过测试之后，再来考虑对代码进行重构 关于测试驱动开发和提高代码可测性方面有几点说明： TDD 只是手段而不是目的，因此在实践中尽量只验证正确的事情，并且每次仅仅验证一件事儿。 测试驱动开发本身就是一门学问，不要指望通过一个简单的例子就掌握其精髓。 代码的不可测性可以从以下几个方面考量：实践 TDD 困难；外部依赖太多；需要写很多模拟代码才能完成测试；职责太多导致功能模糊；内部状态过多且没有办法去操作和维护这些状态；函数没有明显返回或者参数过多；低内聚高耦合等等 建议 76：使用 Pylint 检查代码风格我使用 PyChrame 貌似内置..严格遵循 PEP8 标准 建议 77：进行高效的代码审查建议 78：将包发布到 PyPI建议 79：了解代码优化的基本原则 优先保证代码是可工作的 权衡优化的代价 定义性能指标，集中力量解决首要问题 不要忽略可读性 建议 80：借助性能优化工具例如 Pypy 建议 81：利用 cProfile 定位性能瓶颈cProfile 的统计结果及其各项意义 统计项 意义 ncalls 函数的被调用次数 tottime 函数总计运行时间，不含调用的函数运行时间 percall 函数运行一次的平均时间，等于 tottime/ncalls cumtime 函数总计运行时间，含调用的函数运行时间 percall 函数一次运行的平均时间，等于 cumtime/ncalls filename:lineno(function) 函数所在的文件名、函数行号、函数名 Stats 提供了对 cProfile 输出结果进行排序、输出控制等功能。 Stats 函数以及对应作用 函数 函数的作用 strip_dirs() 用以除去文件名前面的路径信息 add(filename[,…]) 把 profile 的输出文件加入 Stats 实例中统计 dump_stats(filename) 把 Stats 的统计结果保存到文件 sort_stats(key[,…]) 用以排序 Profile 的输出 reverse_order() 把 Stats 实例里的数据反序重排 print_stats([restriction, …]) 把 Stats 报表输出到 stdout print_callers([restriction, …]) 输出调用了指定的函数的相关信息 print_callees([restriction, …]) 输出指定的函数调用过的函数的相关信息 sort_stats 可接受参数列表 参数 意义 ncalls 被调用次数 cumulative 函数运行的总时间 file 文件名 module 模块名 pcalls 简单的调用统计 line 行号 name 函数名 nfl Name、file、line stdname 标准函数名 time 函数内部运行时间，不计调用子函数的时间 建议 82：使用 memory_profiler 和 objgraph 剖析内存使用建议 83：努力降低算法复杂度常见数据结构基本操作的时间复杂度 数据结构 操作 平均时间复杂度 最差时间复杂度 list 复制 O(n) O(n) 追加、取元素的值，给某个元素赋值 O(1) O(1) 插入、删除某个元素，迭代操作 O(n) O(n) 切片操作 O(k) O(k) set x in s O(1) O(n) 并 s or t O(len(s)+len(t)) 交 s&amp;t O(min(len(s), len(t))) O(len(s) * len(t)) 差 s-t O(len(s)) dict 获取修改元素的值，删除 O(1) O(n) 迭代操作 O(n) O(n) collections.deque 入列、出列、（包括左边出入列） O(1) O(n) 扩大队列 O(k) O(k) 删除元素 O(n) O(n) 建议 84：掌握循环优化的基本技巧 减少循环内部的计算 将显式循环改为隐式循环 在循环中尽量引用局部变量 关注内层嵌套循环 建议 85：使用生成器提高效率生成器的优点有如下几条： 生成器提供了一种更为便利的产生迭代器的方式，用户一般不需要自己实现 __iter__ 和 next 方法，它默认返回一个迭代器 代码更为简洁、优雅 充分利用了延迟评估的特性，仅在需要的时候才产生对应的元素，而不是一次生成所有的元素，从而节省了内存空间，提高效率 使得协程更为容易实现。（Python3.5 中引入了 async 和 wait 关键字） 建议 86：使用不同的数据结构优化性能建议 87：充分利用 set 的优势建议 88：使用 multiprocessing 克服 GIL 的缺陷Multiprocessing 模块在使用上需要注意以下几个要点： 进程之间的通信优先考虑 Pipe 和 Queue，而不是 Lock、Event、Condition、Semaphore 等同步原语 尽量避免资源共享。如果不可避免，可以通过 multiprocessing.Value 和 multiprocessing.Array 或者 multiprocessing.sharedctype 来实现内存共享。也可以通过服务器进程管理器 Manager() 来实现数据和状态的共享。 注意平台之间的差异。 尽量避免使用 terminate() 方式终止进程，并且确保 pool.map 中传入的参数是可以序列化的 建议 89：使用线程池提高效率建议 90：使用 C/C++ 模块扩展提高性能建议 91：使用 Cython 编写扩展模块]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http & http2 学习]]></title>
    <url>%2FStaticBlog%2F2016%2F07%2F31%2Fhttp-http2-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTTP 1.1Web 使用一种名为 HTTP(HyperText Transfer Protocol, 超文本传输协议/超文本转移协议)的协议作为规范，完成从客户端到服务端等一系列运作流程。TCP/IP 协议族 里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。 TCP/IP 协议族各层的作用如下： 应用层 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务，比如，FTP(File Transfer Protocol, 文件传输协议) 和 DNS(Domain Name System, 域名系统) 服务就是其中两类。 传输层 传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User ata Protocol) 用户数据报协议。 网络层 (又名网络互连层) 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径 (所谓的传输路线) 到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或万灵果设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层 (又名数据链路层，网络接口层) 用来处理链接网络的硬件部分。包括控制操作系统、硬件的设备驱动，NIC(Network Interface Card, 网络适配器，即网卡)，及光纤等物理可见部分 (还包括连接器等一切传输媒介)。硬件上的范畴均在链路层的作用范围之内。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把信息包装起来的做法称为封装 (encapsulate)。 详细学习见《TCP/IP 详解》 HTTP/1.0 和 HTTP/1.1 支持的方法 方法 说明 支持的 HTTP 协议版本 GET 获取资源 1.0、1.1 POST 传输实体主体 1.0、1.1 PUT 传输文件 1.0、1.1 HEAD 获得报文头部 1.0、1.1 DELETE 删除文件 1.0、1.1 OPTIONS 询问支持的方法 1.1 TRACE 追踪路径 1.1 CONNECT 要求用隧道协议连接代理 1.1 LINK 建立和资源之间的联系 1.0 UNLINK 断开连接关系 1.0 持久连接 HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。为了解决持久连接的问题，HTTP/1.1 和 一部分的 HTTP/1.0 相处了持久连接 (HTTP Persistent Connections, 也称为 HTTP keep-alive 或 HTTP connection reuse) 的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 HTTP 报文用于HTTP协议交互的信息被称为 HTTP 报文。请求端 (客户端) 的 HTTP 报文叫做请求报文，响应端 (服务器端) 的叫做响应报文。HTTP 报文本身是由多行 (用 CR+LF 作换行符) 数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两个由最初出现的空行来划分。通常并不一定有报文主体。 报文主体和实体主体 报文 (message)是 HTTP 通信中的基本单位，由 8 位组字节流 (octet sequence, 其中 octet 为 8 个bit) 组成，通过 HTTP 通信传输。 实体 (entity)作为请求或响应的有效载荷数据 (补充项) 被传输，其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。 压缩传输的内容编码 常用的内容编码有以下几种： gzip (GNU zip) compress (UNIX 系统的标准压缩) deflate (zlib) identity (不进行编码) HTTP 状态码 状态码 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 2XX 成功 200 OK 204 No Content 206 Partial Content 3XX 重定向 301 Moved Permanently 302 Found 303 See Other 304 Not Modified虽然 304 被分在 3XX 类别中，但是和重定向没有关系。 4XX 客户端错误 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 5XX 服务器错误 500 Internal Server Error 503 Service Unavailable 状态码和状况的不一致 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。 HTTP 首部在请求中，HTTP 报文由方法、URL、HTTP 版本、HTTP 首部字段等部分构成。 在响应中，HTTP 报文由 HTTP 版本、状态码 (数字和原因短语)、HTTP 首部字段 3 部分构成。 HTTP 首部字段 HTTP 首部字段根据实际用途被分为以下4种类型： 通用首部字段 (General Header Fields)请求报文和响应报文两方都会使用的首部 请求首部字段 (Request Header Fields)从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段 (Response Header Fields)从服务端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段 (Entity Header Fields)针对请求报文和响应报文的额实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 通用首部字段 Cache-Control通过制定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。 Cache-Control 指令一览： 缓存请求指令 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必须 响应最大的 Age 值 max-stale( = [秒]) 可省略 接收已过期的响应 min-fresh = [秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记 (token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器缓存的响应有效性再进行确认 max-age = [秒] 必须 响应最大的 Age 值 s-maxage = [秒] 必须 公共缓存服务器响应的最大 Age 值 cache-extension - 新指令标记 (token) ConnectionConnection 首部字段具备如下两个作用： 控制不再转发给代理的首部字段 管理持久连接 Connection: UpgradeConnection: Keep-AliveConnection: close Date首部字段 Date 表明创建 HTTP 报文的日期和时间HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式Date: Tue, 03 Jul 2012 04:40:59 GMT PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。规范定义的形式唯一：Pragma: no-cache Trailer首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段，该字段可应用在 HTTP/1.1 版本分块传输编码时。 1234...Trailer: Expires...(报文主体)...Expires: Tue, 28 Sep 2004 23:59:59 GMT Transfer-Encoding首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 Upgrade首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议使用首部字段 Upgrade 时，需要额外指定 Connection: Upgrade对于富有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。 Via使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。 WarningHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部 (Retry-After) 演变过来的，该首部通常会告知用户一些与缓存相关的问题的警告。 Warning 首部的格式如下：Warning: [警告码] [警告的主机:端口号] &quot;[警告内容]&quot; ([日期时间]) HTTP/1.1 警告码 警告码 警告内容 说明 110 Response is stale (响应已过期) 代理返回已过期的资源 111 Revalidation failed (再次验证失败) 代理再验证资源有效性时失败 (服务器无法到达等原因) 112 Disconnection operation (断开连接操作) 代理与互联网连接被故意切断 113 Heuristic expiration (试探性过期) 响应的使用期超过24小时 (有效缓存设定时间大于24小时的情况下) 199 Miscellaneous warning (杂项警告) 任意的警告内容 214 Transformation applied (使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning (持久杂项警告) 任意的警告内容 请求首部字段 AcceptAccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。若想给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号进行分割。权重值 q 的范围是 0~1 可精确到小数点后3位，且1为最大值。不指定权重 q 值时，默认权重为 q=1.0。Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 Accept-CharsetAccept-Charset 首部字段可用来通知服务器用户代理支持的字符集，及字符集的相对优先顺序。另外可一次性指定多种字符集，与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。Accept-Charset: utf-8 Accept-EncodingAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。Accept-Encoding: gzip, deflate Accept-Language首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级，可一次指定多种自然语言集。Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3 Authorization首部字段 Authorization 是用来告知服务器，用户代理的认证信息 (证书值)。 Expect客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码 417 Expectation Failed。Expect: 100-continue From首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。 Host首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须包含在请求内的首部字段。Host: github.com If-Match形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记 (ETag) 值。 If-Modified-Since首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 If-None-Match首部字段 If-None-Match，属附带条件之一，它和 If-Match 相反。 If-Range首部字段 If-Range，属附带条件之一，它告知服务器若指定的 If-Range 字段值 (ETag 值或者时间) 和请求资源的 ETag 值或时间相一致时，则作为范围请求处理，反之则返回全体资源。 If-Unmodified-Since和 If-Modified-Since 相反 Max-Forwards通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以10进制整数形式指定可经过的服务器最大数目。 Proxy-Authorization接收到从代理服务器发送来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以便告知服务器认证所需的信息。 RangeRange: bytes=5001-10000对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。 RefererReferer: http://github.com/首部字段 Referer 会告知服务器请求的原始资源的URL会被用来爬虫和反爬虫… Referer的正确英语拼法是referrer。由于早期HTTP规范的拼写错误，为了保持向下兼容就将错就错了。其它网络技术的规范企图修正此问题，使用正确拼法，所以目前拼法不统一。 TE首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很像，但是用于传输编码TE: gzip 除了指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码方式。只需把 trailers 赋值给该字段值。TE: trailers User-Agent首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。爬虫要模拟浏览器就要添加该字段。 响应首部字段响应首部字段是由服务器向客户端返回相应报文中所使用的字段，用于补充相应的附加信息、服务器信息，以及客户端的附加要求等信息。 Accept-Ranges用来告知客户端，服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none Age首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 ETag能够告知客户端实体标识 Location可以讲响应接收方引导至某个与请求URL位置不同的资源。 Proxy-Authenticate首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 Retry-After告知客户端应该在多久之后再次发送请求。 Server告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还可能包括版本号和安装时启动的可选项。 Vary源服务器会向代理服务器传达关于本地缓存使用方法的命令。 WWW-Authenticate用于 HTTP 访问认证。它会告知客户端用于访问请求 URL 所制定资源的认证方案 (Basic 或是 Digest) 和带参数提示的质询 (challenge)。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于不中内容的更新时间等与实体相关的信息。 Allow用于通知客户端能够支持 Request-URL 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法是，会以状态码 405 Method Not Allowed 作为响应返回，与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。 Content-Encoding告知客户端服务器对实体的主体部分选用的内容编码方式。 Content-Language告知客户端，实体主体使用的自然语言。 Content-Length告知客户端，实体主体的大小，单位字节。 Content-Location给出与报文主体部分相对应的URL Content-MD5对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。 Content-Range告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。 Content-Type说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。 Expires将资源失效的日期告知客户端。 Last-Modified知名资源最终修改的时间 为 Cookie 服务的首部字段Cookie 的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 Set-CookieSet-Cookie 字段的属性 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值 (必需项) expires=DATE Cookie 的有效期 (若不明确指定则默认为浏览器关闭前为止) path=PATH 将服务器上的文件目录作为Cookie的适用对象 (若不指定则默认为文档所在的文件目录) domain=域名 作为Cookie适用对象的域名 (若不指定则默认为创建Cookie的服务器的域名) Secure 仅在HTTPS安全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问 CookieCookie: status=enableCookie 会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。 其他首部字段HTTP 首部字段是可以自行扩展的。所以在Web服务器和浏览器应用上，会出现各种非标准的首部字段。 X-Frame-Options首部字段 X-Frame-Options 属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持攻击。DENY: 拒绝SAMEORIGIN: 仅同源域名下的页面 (Top-level-browsing-context) 匹配时许可。 X-XSS-Protection首部字段 X-XSS-Protection 属于HTTP响应首部，它是针对跨站脚本攻击的一种对策，用于控制浏览器XSS防护机制的开关。0: 将XSS过滤设置成无效状态1: 将XSS过滤设置成有效状态 DNT首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被手机，是表示拒绝被精准广告追踪的一种方法。0: 同意被追踪1: 拒绝被追踪 P3P首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P (The Platform for Privacy Preferences, 在线隐私偏好平台) 技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。 HTTP/2.0HTTP2 的基本概念HTTP2 是基于SPDY的..HTTP2 有着分厂明确的职责限定： 它必须维持 HTTP 的范式。毕竟它只是一个让客户端发送请求到服务器的基于TCP的协议。 不能盖面 http:// 和 https:// 这样的 URL，也不能对其添加新的结构。使用这类URL的网站太多了，没发指望他们全部改变。 HTTP1的服务器和客户端依然会存在很久，所以我们必须提供HTTP1到HTTP2服务器的代理。 我们也要让这种代理能够将HTTP2的功能一对一的映射到HTTP1.1的客户端 删除或者减少协议里面那些可选的部分。虽然这并不算的上是一个需求，但是SPDY和Google的团队都非常喜欢这样。通过让协议里的所有内容都成为强制性需求，可以防止人们在实现的时候偷懒，从而规避一些将来可能发生的问题。 不再使用小版本号。服务器和客户端都必须确定自己是否完整兼容HTTP2或者彻底不兼容。如果将来协议需要被扩充或者变更，那么新的协议将会是HTTP3，而不是HTTP2.X HTTP2和现有的URI结构HTTP 1.1本身就制定过“升级”的方案：提供一个首部字段， 表示允许服务器在收到旧协议请求的同时， 可以向客户端发送新协议的响应。 但这一方案往往需要多花费一次往返通信来作为升级的代价。而这一代价是SPDY团队不想接受的。 因为他们只实现了基于TLS的SPDY， 所以他们开发了一个TLS的扩展去简化协议的协商。 这个扩展被称作NPN（ Next Protocol Negotiation） ， 借助于此， 服务器会通知客户端所有它支持的协议， 让客户端从中选择一个合适的来进行通讯。 HTTP2将TLS标记成了可选。 然而， 全球两大浏览器领导者 —— Firefox和Chrome都明确地表示， 他们只会实现基于TLS的HTTP2规范中指定了TLS最低版本为1.2， 并且会有加密组的限制。 对于纯文本的HTTP1.1来说， 协商http2的方法就是通过给服务器发送一个带升级头部的报文。 如果服务器支持http2， 它将以“101 Switching”作为回复的状态码， 并从此开始在该连接上使用http2。 也许你很容易就发现这样一个升级的流程会需要消耗掉一整个的往返时延， 但好处是http2连接相比HTTP1可以被更大限度地重用和保持。虽然有些浏览器厂商的发言人宣称他们不会实现这样的http2会话方式， 但IE团队已公开表示他们会实现， 与此同时， curl也已经支持了这种方式 基于TLS之上的HTTP2协商Next Protocol Negotiation (NPN)是一个用来在TLS服务器上协商SPDY的协议。 IETF将这个非正式标准进行规范化， 从而演变成了ALPN（ Application Layer Protocol Negotiation）。ALPN会随着http2的应用被推广， 而SPDY的客户端与服务器则会继续使用NPN。ALPN和NPN的主要区别在于：谁来决定该次会话所使用的协议。 在ALPN的描述中， 是让客户端先发送一个协议优先级列表给服务器， 由服务器最终选择一个合适的。 而NPN则正好相反， 客户端有着最终的决定权。 HTTP2 协议HTTP2 是一个二进制协议。http2会发送有着不同类型的二进制帧， 但他们都有如下的公共字段：Type, Length, Flags, StreamIdentifier和frame payload规范中一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP1.1的DATA和HEADERS。 http2连接上传输的每个帧都关联到一个“流”。 流是一个逻辑上的联合， 一个独立的， 双向的帧序列可以通过一个http2的连接在服务端与客户端之间不断的交换数据。 每个单独的http2连接都可以包含多个并发的流， 这些流中交错的包含着来自两端的帧。 流既可以被客户端/服务器端单方面的建立和使用， 也可以被双方共享， 或者被任意一边关闭。 在流里面， 每一帧发送的顺序非常关键。 接收方会按照收到帧的顺序来进行处理。 每个流都包含一个优先级（ 也就是“权重”） ， 它被用来告诉对端哪个流更重要。 当资源有限的时候， 服务器会根据优先级来选择应该先发送哪些流。借助于PRIORITY帧， 客户端同样可以告知服务器当前的流依赖于其他哪个流。 该功能让客户端能建立一个优先级“树”， 所有“子流”会依赖于“父流”的传输完成情况。 HTTP2 也是一种无状态的协议。 HPACK， HTTP/2头部压缩， 顾名思义它是一个专为http2头部设计的压缩格式。 确切的讲，它甚至被制定写入在另外一个单独的草案里。 新的格式同时引入了一些其他对策让破解压缩变得困难， 例如采用帧的可选填充和用一个bit作为标记， 来让中间人不压缩指定的头部。 在http2里面， 我们可以通过发送RST_STREAM帧来实现重置， 从而避免浪费带宽和中断已有的连接。 服务器推送，这个功能通常被称作“缓存推送”。 主要的思想是：当一个客户端请求资源X， 而服务器知道它很可能也需要资源Z的情况下， 服务器可以在客户端发送请求前， 主动将资源Z推送给客户端。 这个功能帮助客户端将Z放进缓存以备将来之需。如果不需要的话， 客户端可以通过发送一个RST_STREAM帧来中止。 http2上面每个流都拥有自己的公示的流量窗口， 它可以限制另一端发送数据。 扩展协议强制规定了接收方必须读取并忽略掉所有未知帧类型的帧。 双方可以在逐跳原则（ hopby-hop basis） 基础上协商使用新的帧， 这些帧的状态无法被改变， 而且也不受流控制。 备选服务（ Alternative Services） 服务器将会通过发送Alt-Svc头（ 或者http2的ALTSVC帧） 来告知客户端另一个备选服务。 即另外一条指向不同的服务源、 主机或端口， 但却能获取同样内容的路由。藉此， 客户端可以尝试异步的连接并使用该服务， 如果它切实可用的话。 阻塞（ Blocked） 这个类型的帧意味着：当服务端存在需要发送的内容， 但流控制却禁止发送任何数据时， 那么此类型的帧将会被发送且仅发送一次。 这种帧设计的目的在于， 如果你接收到了此帧， 那么连接中必然有错误发生或者是得到了低于期望的传输速度。有可能移除.. 结束HTTP2的学习不详细，后续资料齐全再补充…]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArchLinux 安装笔记]]></title>
    <url>%2FStaticBlog%2F2016%2F07%2F17%2FArchLinux-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前提说明建议优先选择官方文档为参考，内容随时更新且非常详细。这里记录是包含一些自己遇到的坑。且只针对自己安装需求的情况。 引用参考 Beginners’guide (简体中文)Installation guide (简体中文)给妹子看的 Arch Linux 桌面日常安装ArchLinux 安装笔记寒假折腾Archlinux的一些经验（新手向）–桌面配置篇ArchLinux使用中常见问题集锦 环境机器: DELLBOOT: UEFISSD: 256G内存: 8GCPU: i7-6500U安装需求：本机安装单系统ArchLinux: Release 2016.06.01 LiveUSB参考 USB flash installation media (简体中文)推荐使用里面的手动方法，这样制作的LiveUSB可以使用剩余空间来存储其他东西。 安装准备镜像中不包含软件包，安装的软件是通过服务器上的源下载，所以安装的时候必须要有网络连接。 联网有线： 用ip addr 查看网卡接口型号，比如 enp2s0 启用网卡DHCP功能，systemctl enable dhcpcd@enp2s0.service无线： wifi-menu 选择自己的 wifi 并输入密码连接网络 最后 ping 一下，确认网络无误 更新系统时间timedatectl set-ntp true 准备磁盘 lsblk 查看自己的硬盘所在，比如我的就是 /dev/sda 使用parted 分区注意：我是要全盘安装的，所以重新建立分区表了。a. parted /dev/sdab. (parted) mktable gpt 重建 GPT 分区表c. (parted) mkpart ESP fat32 1M 513M 分配 ESP 分区，前1M是分区表，ESP大小为512Md. (parted) set 1 boot on 设置为ESP分区e. (parted) mkpart primary linux-swap 513M 8705M 分配swap分区，这里使用了与我内存同样大小的8Gf. (parted) mkpart primary ext4 8705M 100% 分配root分区，使用剩余所有空间 格式化分区a. mkfs.vfat –F32 /dev/sda1 ESP分区需要格式化成fat32，否则无法启动b. mkswap /dev/sda2 &amp; swapon /dev/sda2 格式化交换分区，并设置c. mkfs.ext4 –b 4096 /dev/sda3 格式化root分区，并4K对齐 挂载分区a. mount –t ext4 –o discard,noatime /dev/sda3 /mntb. mkdir –p /mnt/boot/EFIc. mount /dev/sda1 /mnt/boot/EFI 安装 配置安装源默认镜像是美国的，在中国速度慢，所以全改中国了..sed -i &#39;/Score/{/China/!{n;s/^/#/}}&#39; /etc/pacman.d/mirrorlist 安装基本系统安装之前先确认是否连网pacstrap /mnt base base-devel vim 生成 fstabgenfstab –U –p /mnt &gt;&gt; /mnt/etc/fstab chrootarch-chroot /mnt /bin/bash Localevim /etc/locale.gen取消下面这些注释en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8 生成locale信息locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.conf 时间选择时区（Shanghai）tzselect 将 /etc/localtime 软连接到 /usr/share/zoneinfo/Zone/SubZoneln –s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置时间标准为 UTC 并调整时间偏移hwclock –systohc –utc 创建初始 ramdisk 环境mkinitcpio –p linux 设置 root 密码passwd 安装 grub先df命令确认一下有木有挂载ESP分区应该是这样的… File system Mounted On /dev/sda3 / /dev/sda1 /boot/EFI … … pacman –S grub efibootmgrgrub-install –target=x86_64-efi –efi-directory=/boot/EFI –bootloader-id=arch_grub –recheckgrub-mkconfig –o /boot/grub/grub.cfg注意:有些BIOS需要自己设置EFI文件位置才能找到efi文件。比如我的DELL 配置网络echo myhostname &gt; /etc/hostname并在 /etc/hosts 添加同样主机名123#&lt;ip-address&gt; &lt;hostname.domain.org&gt; &lt;hostname&gt;127.0.0.1 localhost.localdomain localhost myhostname::1 localhost.localdomain localhost myhostname 有线网络Interface 是您的网络接口名，见连网systemctl enable dhcpcd@interface.service 无线网络pacman –S iw wpa_supplicant dialog 卸载分区并重启系统exitumount -R /mntreboot 折腾新大陆重启之后就阔以以root进入到archlinux系统了，首先我们要进行联网。 添加用户useradd –m –g users –G wheel –s /bin/bash usernamepasswd username sudopacman –S sudovim /etc/sudoers找到 root ALL=(ALL) ALL照着这个，在下面添加一个 username ALL=(ALL) ALL 安装 yaourtvim /etc/pacman.conf加入下面的内容: 1234[archlinuxcn]# The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://mirrors.163.com/archlinux-cn/$arch 更新并安装yaourt123pacman –Syupacman –S yaourtpacman –S archlinuxcn-keyring 安装 SSH、GIT、wgetpacman –S git openssh wget 安装 zsh 123pacman –S zshchsh /bin/zshsh –c “$(curl –fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 安装 screenfetchpacman –S screenfetch NTFS 读写pacman –S ntfs-3g 安装解压缩软件pacman –S file-roller unrar unzip p7zip Shadowsocks-qt5pacman –S shadowsocks-qt5 ProxyChainspacman –S proxychains RP-PPPOE拨号的，按需安装pacman –S rp-pppoenm-connection-editor 安装 xorg 桌面管理器pacman –S xorg-xinit xorg-server xorg-twm xterm 安装 gnome 桌面环境按需，个人安装的gnome，觉得新版3.20挺好看的pacman –S gnomepacman –S gnome-tweak-tool VPN 扩展 123pacman –S networkmanager-pptpyaourt networkmanager-l2tpsystemctl restart NetworkManager 启动服务显示管理器gnome默认是用的GDMsystemctl enable gdm.service 网络管理systemctl enable NetworkManager.service 更新pacman –Syu 安装 chromiumpacman –S chromium 安装输入法依赖pacman –S fcitx-im fcitx-configtool fcitx-gtk3 fcitx-gtk2 fcitx-qt4 fcitx-qt5 自行选择安装的拼音，我选择的sunpacman –S sunpinyin 配置.xprofile文件vim ~/.xprofile 添加如下内容12345678export LC_CTYPE=zh_CN.UTF-8export XIM=fcitxexport XIM_PROGRAM=fcitxexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx"eval `dbus-launch --sh-syntax --exit-with-session`exec fcitx &amp; 注意，即使这样，你会发现还是调用不出输入法…等下重启之后告诉你如何解决~ 安装网易云音乐pacman –S netease-cloud-music 重启reboot 来到新的世界重启你会发现有了界面~ 配置输入法前面说即使安装完那些东西也调不出来，是有个地方需要配置一下左下角可以有个后台程序栏。右键输入法，选择配置。发现输入法里面并没有拼音，我们添加进安装的 sunpinyin 就好了。注意:切换输入法与 gnome 显示的不一致。默认切换输入法是 ctrl+space 中文化安装中文字体，推荐思源黑体，安装方法见 Github 上的安装过程。安装等宽字体，推荐 Source Code Pro打开 Gnome Tweak Tool，切换到字体栏，将窗口、界面、文档的字体改为 Source Han Sans Normal将等宽字体设置为 Source Code Pro VMWare我这里环境：VMWare: VMware-Workstation-Full-12.1.1-3770994.x86_64.bundleLinux: Linux 4.6.2-1-ARCH 首先从VMWare官网下载个 VMWare二进制包安装部分详见 VMware_(简体中文) 安装依赖mkdir /etc/init.d 添加VMWare服务配置文件yaourt vmware-systemd-servicessystemctl enable vmware.servicesystemctl start vmware.service 有一个地方我要说明一下。在启动提示有个服务跟新的时候，更新会失败，导致不能启动VMWare注意：下面的方法不一定在你的版本适用，请注意备份。解决方法是： 进入 /usr/lib/vmware/modules/source 解包 vmnet.tar vmmon.tar Replace function &quot;get_user_pages()&quot; with &quot;get_user_pages_remote()&quot; in vmmon-only/linux/hostif.c and vmnet-only/userif.c files. 重新打包回去 具体如下：cd /usr/lib/vmware/modules/source 解包sudo tar –xvf vmnet.tarsudo tar –xvf vmmon.tar 把下面两个文件里面的 get_user_pages 函数替换成 get_user_pages_remotesudo vim vmnet-only/driver.csudo vim vmmon-only/linux/hostif.c 打包sudo tar -uvf vmnet.tar vmnet-onlysudo tar -uvf vmmon.tar vmmon-only 然后删除那解包的文件夹sudo rm -r vmnet-onlysudo rm -r vmmon-only 结束]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2] ARK-Tool develop log : Enumerate Process & Thread.]]></title>
    <url>%2FStaticBlog%2F2016%2F02%2F09%2F2-ARK-Tool-develop-log-Enumerate-process-thread%2F</url>
    <content type="text"><![CDATA[枚举 Process &amp; Thread按照惯例，玩儿这些东西总是从进程开始哒，那么我们今儿就说一下枚举进程&amp;线程~ 在R3，我们阔以用以下方法来遍历进程&amp;线程： ToolHelp ZwQuerySystemInformation 但是到了R0，就阔以用各种方法来实现： ZwQuerySystemInformation 遍历 活动进程链（PEPROCESS-&gt;ActiveProcessLinks） 通过 PsLookupProcessByProcessId 搜索 遍历 PspCidTable 句柄表 ZwQuerySystemInformation这个算是标准的方法，网上一堆，不再赘述。 遍历进程活动链表什么是活动进程链？ EPROCESS 块中有一个 ActiveProcessLinks 成员，它是一个 PLIST_ENTRY 结构的双向链表。当一个新进程建立的时候父进程负责完成 EPROCESS 块，然后把 ActiveProcessLinks 链接到一个全局内核变量 PsActiveProcessHead 链表中。 在 PspCreateProcess 内核API中能清晰的找到： InsertTailList (&amp;PsActiveProcessHead, &amp;Process-&gt;ActiveProcessLinks); 当进程结束的时候，该进程EPROCESS结构从活动进程链上摘除。（但是 EPROCESS 结构不一定马上释放。） 在 PspExitProcess 内核API中能看到 RemoveEntryList(&amp;Process-&gt;ActiveProcessLinks);遍历进程活动链表（ActiveProcessLinks）、DKOM隐藏进程 ZwQuerySystemInformation 就是遍历这个链表来实现的。 由于很容易摘链来隐藏进程，所以这里只是简单的说下。 有一个要注意的地方，就是链表里面存的是 EPROCESS-&gt;ActiveProcessLinks 所以要得到EPROCESS就要减去这个偏移。 12345678910111213141516kd&gt; dt nt!_EPROCESS 0xfffffa80`03510f80 +0x000 Pcb : _KPROCESS +0x160 ProcessLock : _EX_PUSH_LOCK +0x168 CreateTime : _LARGE_INTEGER 0x0 +0x170 ExitTime : _LARGE_INTEGER 0x00000003`00000006 +0x178 RundownProtect : _EX_RUNDOWN_REF +0x180 UniqueProcessId : 0xfffffa80`03511010 Void +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffff8a0`014aac28 - 0xfffffa80`03511138 ] ... kd&gt; ? 0xfffffa80`02de4ab8 - 0x188Evaluate expression: -6047265830608 = fffffa80`02de4930kd&gt; !object fffffa80`02de4930Object: fffffa8002de4930 Type: (fffffa800184aa20) Process ObjectHeader: fffffa8002de4900 (new version) HandleCount: 1 PointerCount: 25 通过 PsLookupProcessByProcessId 搜索这个方案虽然简单，但相对于以上两种方法，更推荐使用这种方案。 原因就是 活动进程链 太简单，很容易被摘掉。 而 PsLookupProcessByProcessId 是通过遍历 PspCidTable 来实现。 进程要逃避检测，必须从 PspCidTable 中删除自身对象，句柄项被用 NULL 替代。但当系统关闭进程的时候，它将找到 PspCidTable 并且得到一个 NULL 对象指针，这将导致蓝屏。隐藏进程在被终止之前必须调用 PsSetCreateProcessNotifyRoutine 安装一个回调避免BSOD，但实现方法难度相对来说略高。 当然，也有我不并不知道的方法，请各位童鞋告知~共同探讨学习~~ 注意：可以通过HOOK来解决掉这个函数，所以阔以自己遍历 PspCidTable 来尽量避免隐藏进程 12345678910111213141516171819202122232425template &lt;typename F&gt;static NTSTATUS EnumProcess( _In_ F aCallBack )&#123; NTSTATUS vStatus = STATUS_UNSUCCESSFUL; PEPROCESS vProcess = NULL; for (Size_t i = 4; i &lt; 262144; i += 4) // 262144 = 2^18 &#123; // 遍历线程同理，换成 PsLookupThreadByThreadId vStatus = PsLookupProcessByProcessId((HANDLE)i, &amp;vProcess); if (NT_SUCCESS(vStatus)) &#123; vStatus = aCallBack(vProcess); ObDereferenceObject(vProcess); if (STATUS_SUCCESS == vStatus) &#123; break; &#125; &#125; &#125; return vStatus;&#125; 遍历 PspCidTable 句柄表这部分内容留到下一篇文章 “检测隐藏进程” ~ 我先去研究研究（逃~]]></content>
      <tags>
        <tag>内核</tag>
        <tag>ARK</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[1] ARK-Tool develop log : Global Overloaded new & delete.]]></title>
    <url>%2FStaticBlog%2F2016%2F02%2F08%2F1-ARK-Tool-develop-log-Global-Overloaded-new-delete%2F</url>
    <content type="text"><![CDATA[全局重载 New &amp; Delete（DTL系列）由于在驱动层，WDK并没有提供 new 和 delete，所以我们要用内核的内存分配函数自己重载一套。 new 和 delete 的重载有以下注意的地方： 要符合 C++ 标准 有 new 就要有对应的 delete 以下 new &amp; delete 必须重载，以供 C++ 基本使用： 一般形式 数组形式 placement new 用于类对象的 delete 重载 operator new 的参数个数是可以任意的 , 只需要保证第一个参数为 size_t, 返回类型为 void * 即可 , 而且其重载的参数类型也不必包含自定义类型 . 更一般的说 , operator new 的重载更像是一个函数的重载 , 而不是一个操作符的重载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 默认参数值static const POOL_TYPE DEFAULT_NEW_POOL_TYPE = NonPagedPool;static const unsigned long DEFAULT_NEW_TAG = &apos; New&apos;;// 一般形式void * __cdecl operator new (size_t aSize) noexcept&#123; if (0 == aSize) &#123; // 按照 C++ 标准， // 当 size 为 0 时， // 申请 1 字节内存 aSize = 1; &#125; return ExAllocatePoolWithTag(DEFAULT_NEW_POOL_TYPE, aSize, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete (void *aPtr) noexcept&#123; if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;// placement new// 不需要delete，对象可以直接调用析构void * __cdecl operator new (size_t /*aSize*/, void *aBuffer) noexcept&#123; // placement new的作用就是：创建对象(调用该类的构造函数)但是不分配内存， // 而是在已有的内存块上面创建对象。用于需要反复创建并删除的对象上， // 可以降低分配释放内存的性能消耗 return aBuffer;&#125;// 数组形式void * __cdecl operator new[] (size_t aSize) noexcept&#123; if (0 == aSize) &#123; aSize = 1; &#125; return ExAllocatePoolWithTag(DEFAULT_NEW_POOL_TYPE, aSize, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete[] (void *aPtr) noexcept&#123; if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;// 用于类对象的 deletevoid __cdecl operator delete (void *aPtr, size_t /*aSize*/) noexcept&#123; // sized class - specific deallocation functions if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;void __cdecl operator delete[] (void *aPtr, size_t /*aSize*/) noexcept&#123; // sized class - specific deallocation functions if (nullptr == aPtr) &#123; return; &#125; return ExFreePoolWithTag(aPtr, DEFAULT_NEW_TAG);&#125;]]></content>
      <tags>
        <tag>内核</tag>
        <tag>ARK</tag>
        <tag>Windows</tag>
        <tag>DTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[0] ARK-Tool develop log : 前言]]></title>
    <url>%2FStaticBlog%2F2016%2F02%2F08%2F0-ARK-Tool-develop-log-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言声明：这一系列文章是我边学边写，内容不免会有错误，望指出不足，希望能够共同提高~么么哒~ 写一款自己的ARK工具的怨念已经产生很久了，一直拖拖拉拉到现在终于行动起来。 原因无非如下： 学习 装13，（ 哈哈哈哈哈~ 给自己的作品库填点儿玩具 开发环境： 测试平台 ：Windows 7 x86/x64 语言 ：C++11 IDE ：Visual Studio 2015 其他工具 ：Windbg，IDA，Source Insight，PowerTool，WinObj，SymbolTypeViewer 开发原则： Warning Level：4 安全，稳定，尽量无硬编码，设计时就支持x86/x64平台。 以 PowerTool 和 WIN64AST 为目标~ 将采用C++11的一些特性来写，毕竟用起来很爽~ 当然，在驱动不能使用原有的标准库，用到的东西基本上要自己先实现一套。 注意：自己要在测试环境中测试，若造成系统损坏，本人将不负任何责任~ 大致分为以下项目：用户层： 界面 驱动管理模块 驱动层： 驱动模板库（即R0的STL） 驱动基础库 ARK驱动 库将采用静态库的方式编译，每个静态库项目都会有个Unit的编译选项方便调试~ ARK项目我将其命名为 Illidan Stormrage，即魔兽里面的那个帅锅~ 而驱动部分我将其命名为 Warglaive，就是它那把“埃辛诺斯战刃” 这一系列文章将会记录开发ARK这一路各个功能的实现方法，遇到的问题以及解决方案。 致谢毛哥, 羡B, ithurricanept (PowerTool作者), Tesla.Angela, 小丽 (我司大神..)… 感谢 毛哥 平日里的各种科普，各种唠叨~ 感谢 羡B 对我各种白痴问题解答~ 感谢 Ithurricanept 大神的工具，以及公众号分享的知识~ 感谢 TA 大神提供的基础教程，以及提供的论坛~ 感谢 小丽 对我潜移默化的影响和鞭策~ … …]]></content>
      <tags>
        <tag>内核</tag>
        <tag>ARK</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XP 兼容系列：神奇的静态对象 (magic statics)]]></title>
    <url>%2FStaticBlog%2F2016%2F01%2F13%2FXP-%E5%85%BC%E5%AE%B9%E7%B3%BB%E5%88%97%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1-magic-statics%2F</url>
    <content type="text"><![CDATA[神奇的静态对象 (magic statics)前置声明：文章可能有错误的地方，希望各位童鞋能够提出~ 事故缘由…为了使用很爽的C++11 特性，我司最新项目是用的VS2015进行开发的。但是同时又要对XP做兼容（讲真，我个人是不支持对Win7之前的系统做兼容的，我觉得影响发展）。 我们写了个COM组件作为插件，和驱动进行通讯。在我们进行单元测试的时候，一切正常。但是出了测试安装包之后，发现加载插件会崩溃。然后我们挂载了Windbg神器来定位崩溃点。崩溃点是一个读取TLS，这个值为空(外部静态对象才会有TLS) 想到单元测试程序也是通过VS2015编译的。我们就比较两个进程有啥不一样。如图: 然后我们看一下 nt!_TEB 结构，发现 Tls Storage 就是 _TEB::ThreadLocalStoragePointer 字段。如图： 于是我们查了一下 ReactOS 0.3.15 看下这个字段到底是啥，找到了这个分配Tls的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpAllocateTls(VOID)&#123; PTEB Teb = NtCurrentTeb(); PLIST_ENTRY NextEntry, ListHead; PLDRP_TLS_DATA TlsData; SIZE_T TlsDataSize; PVOID *TlsVector; /* Check if we have any entries */ if (!LdrpNumberOfTlsEntries) return STATUS_SUCCESS; /* Allocate the vector array */ TlsVector = RtlAllocateHeap(RtlGetProcessHeap(), 0, LdrpNumberOfTlsEntries * sizeof(PVOID)); if (!TlsVector) return STATUS_NO_MEMORY; Teb-&gt;ThreadLocalStoragePointer = TlsVector; /* Loop the TLS Array */ ListHead = &amp;LdrpTlsList; NextEntry = ListHead-&gt;Flink; while (NextEntry != ListHead) &#123; /* Get the entry */ TlsData = CONTAINING_RECORD(NextEntry, LDRP_TLS_DATA, TlsLinks); NextEntry = NextEntry-&gt;Flink; /* Allocate this vector */ TlsDataSize = TlsData-&gt;TlsDirectory.EndAddressOfRawData - TlsData-&gt;TlsDirectory.StartAddressOfRawData; TlsVector[TlsData-&gt;TlsDirectory.Characteristics] = RtlAllocateHeap(RtlGetProcessHeap(), 0, TlsDataSize); if (!TlsVector[TlsData-&gt;TlsDirectory.Characteristics]) &#123; /* Out of memory */ return STATUS_NO_MEMORY; &#125; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: TlsVector %x Index %d = %x copied from %x to %x\n&quot;, TlsVector, TlsData-&gt;TlsDirectory.Characteristics, &amp;TlsVector[TlsData-&gt;TlsDirectory.Characteristics], TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsVector[TlsData-&gt;TlsDirectory.Characteristics]); &#125; /* Copy the data */ RtlCopyMemory(TlsVector[TlsData-&gt;TlsDirectory.Characteristics], (PVOID)TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsDataSize); &#125; /* Done */ return STATUS_SUCCESS;&#125; 但是这个函数并不能得到太多有用信息。我们又看了下谁调用了它，得到了 LdrpInitializeTls 这个函数，从这个函数里面，我们就知道，实际上 _TEB::ThreadLocalStoragePointer 这个字段就是 初始化好的PE文件里面的 Tls 表。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpInitializeTls(VOID)&#123; PLIST_ENTRY NextEntry, ListHead; PLDR_DATA_TABLE_ENTRY LdrEntry; PIMAGE_TLS_DIRECTORY TlsDirectory; PLDRP_TLS_DATA TlsData; ULONG Size; /* Initialize the TLS List */ InitializeListHead(&amp;LdrpTlsList); /* Loop all the modules */ ListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList; NextEntry = ListHead-&gt;Flink; while (ListHead != NextEntry) &#123; /* Get the entry */ LdrEntry = CONTAINING_RECORD(NextEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); NextEntry = NextEntry-&gt;Flink; /* Get the TLS directory */ TlsDirectory = RtlImageDirectoryEntryToData(LdrEntry-&gt;DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &amp;Size); /* Check if we have a directory */ if (!TlsDirectory) continue; /* Check if the image has TLS */ if (!LdrpImageHasTls) LdrpImageHasTls = TRUE; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: Tls Found in %wZ at %p\n&quot;, &amp;LdrEntry-&gt;BaseDllName, TlsDirectory); &#125; /* Allocate an entry */ TlsData = RtlAllocateHeap(RtlGetProcessHeap(), 0, sizeof(LDRP_TLS_DATA)); if (!TlsData) return STATUS_NO_MEMORY; /* Lock the DLL and mark it for TLS Usage */ LdrEntry-&gt;LoadCount = -1; LdrEntry-&gt;TlsIndex = -1; /* Save the cached TLS data */ TlsData-&gt;TlsDirectory = *TlsDirectory; InsertTailList(&amp;LdrpTlsList, &amp;TlsData-&gt;TlsLinks); /* Update the index */ *(PLONG)TlsData-&gt;TlsDirectory.AddressOfIndex = LdrpNumberOfTlsEntries; TlsData-&gt;TlsDirectory.Characteristics = LdrpNumberOfTlsEntries++; &#125; /* Done setting up TLS, allocate entries */ return LdrpAllocateTls();&#125; 到了这步，我们以为可以很容易的解决问题，既然需要Tls目录，那我们给它一个不就行了？所以我们给测试代码添加了一个Tls目录..1234567#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)#pragma data_seg(&quot;.CRT$XLB&quot;) PIMAGE_TLS_CALLBACK TlsCallBackArray[] = &#123; TlsCallBackFunction &#125;;#pragma data_seg() 不过我们还是太天真了..我们的Tls的回调啥也没做，所以在程序执行的时候，执行到并没有初始化的对象直接崩溃了..（对，VS2015生成的Tls表（回调）就是用来初始化静态对象的。） 后来…我们在 MSDN 发现一个相关的说明 Starting in C++11, a static local variable initialization is guaranteed to be thread-safe.This feature is sometimes called magic statics.However, in a multithreaded application all subsequent assignments must be synchronized.The thread-safe statics feature can be disabled by using the /Zc:threadSafeInit- flag to avoid taking a dependency on the CRT. 大致意思是，由于在C++11开始可以保证静态本地变量初始化时是线程安全的，即“神奇的静态对象”但是这个特性是默认需要CRT支持的，所以要关闭则需要增加一条编译选项1/Zc:threadSafeInit- 这样在XP上运行就不会出现问题了。 好了，结束~以此记录，来避免自己再遇到同样的坑 (●ˇ∀ˇ●) 引用链接：Storage class (C++)]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>XP 兼容系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 基本使用]]></title>
    <url>%2FStaticBlog%2F2016%2F01%2F11%2FHexo-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Hexo 安装步骤 安装node.js 全局安装 hexo npm install -g hexo-cli 如果有版本什么的警告可以试试这个 npm install --unsafe-perm --verbose -g hexo cd &lt;file folder&gt; 到指定目录 hexo init 初始化hexo npm install 安装依赖 hexo generate 生成静态网页 hexo server 在服务器上运行 可以登录 Loaclhost 测试了 hexo new post “标题” 创建一个博文 MD博文示例 title: 博文标题 data : 2015-12-13 19:05:28 tags : 标签 updata: 最后修改时间 comments:定义能否评论此文章（true） categories: 文章分类 &lt;!-- more --&gt; 使文章在 more 位置折叠 多级分类123categories: - Sports - Baseball 配置文件——“_config.yml” 主题在 themes 目录 默认主题在 themes/landscape 目录 可以在配置文件里面改 部署设置 在配置文件 deploy 项 type: git (github 也是 git) repository: 库地址 branch: 分支 更新新版本 hexo npm update -g hexo 查看 hexo 版本 hexo version 常用命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清楚缓存，网页正常情况写可以忽略此条命令hexo g #生成静态页面hexo d #部署 （要先在 _Config.yml 配置文件配置 deploy 项） 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令作用是一样的hexo generate --deployhexo deploy --generate hexo deploy -ghexo server -g 模板hexo new &quot;postname&quot; #新建文章hexo new page &quot;pagename&quot; #新建页面 变量 描述 :layout 布局 :title 标题 :date 文件建立日期 其实这是测试表格的..]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>